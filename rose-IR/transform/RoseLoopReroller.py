
from RoseType import RoseType
from RoseValue import RoseValue
from RoseAbstractions import *
from RoseValues import *
from RoseBitVectorOperation import *
from RoseBitVectorOperations import *
from RoseOperations import *


def GetOffsetsBetweenWindows(Window1 : list, Window2 : list, OffsetsList : list = []):
  assert len(Window1) == len(Window2)
  if OffsetsList == []:
    #OffsetsList = list() * len(Window1)
    for Index in range(len(Window1)):
      OffsetsList.append(list())
  for Index in range(len(Window1)):
    # Check if the bitwidths of the values generated by the ops
    # in the two windows are the same.
    if Window1[Index].getOutputBitwidth() != Window2[Index].getOutputBitwidth():
      return None
    NumNonBVOperands1 = Window1[Index].getNumNonBVOperands()
    NumNonBVOperands2 = Window2[Index].getNumNonBVOperands()
    if NumNonBVOperands1 != NumNonBVOperands2:
      return None
    # If this operation has not indexing operands, add None
    if NumNonBVOperands1 == 0:
      OffsetsList[Index] =  None
      continue
    # Get offsets between instructions
    LowIndex1 = Window1[Index].getLowIndex()
    LowIndex2 = Window2[Index].getLowIndex()
    HighIndex1 = Window1[Index].getHighIndex()
    HighIndex2 = Window2[Index].getHighIndex()
    if not isinstance(LowIndex1, RoseConstant) \
    or not isinstance(LowIndex2, RoseConstant) \
    or not isinstance(HighIndex1, RoseConstant) \
    or not isinstance(HighIndex2, RoseConstant):
      return None
    NewOffsetsList = []
    NewOffsetsList.append(LowIndex2.getValue() - LowIndex1.getValue())
    NewOffsetsList.append(HighIndex2.getValue() - HighIndex1.getValue())
    # Check if the given offsets match the newly computed offsets
    if OffsetsList[Index] == []:
      OffsetsList[Index] = NewOffsetsList
      continue
    if OffsetsList[Index] != NewOffsetsList:
      return None
  print(OffsetsList)
  return OffsetsList


def GetValidRerollableCandidates(RerollableCandidateWindows : list):
  print("++++++++++++++++++++++++++++++++++++++++++++++++")
  # Collect list of rerollable windows in a set.
  RerollableCandidatesList = list()
  WindowsList = list()
  OffsetsList = list()
  for Window in RerollableCandidateWindows:
    if WindowsList == []:
      WindowsList = [Window]
      continue
    # Now check if the window should be added to the current window list.
    # If the window lenghts different, they cannot be part of a set.
    if len(WindowsList[0]) != len(Window):
      # This is the end of the window list.
      # If we didn't capture multiple windows, we must discard the list
      if len(WindowsList) != 1:
        # Add the window list to the candidate list
        RerollableCandidatesList.append(WindowsList)
      # Empty the list and continue
      WindowsList = [Window]
      continue
    # Now lets see if the window should be added to the window list
    CheckWindow = WindowsList[len(WindowsList) - 1]
    NewOffsetsList = GetOffsetsBetweenWindows(CheckWindow, Window, OffsetsList)
    if NewOffsetsList == None:
      # This is the end of the window list.
      # If we didn't capture multiple windows, we must discard the list
      if len(WindowsList) != 1:
        # Add the window list to the candidate list
        RerollableCandidatesList.append(WindowsList)
      # Empty the list and continue
      WindowsList = [Window]
      continue
    # If the offsets list is empty. Fill it up.
    if OffsetsList == []:
      OffsetsList = NewOffsetsList
    assert OffsetsList == NewOffsetsList
    # Add the window to the list
    print("ADD WINDOW TO THE LIST")
    WindowsList.append(Window)
  # Put in the last window list
  if WindowsList != []:
    RerollableCandidatesList.append(WindowsList)

  for WindowList in RerollableCandidatesList:
    print("--WINDOW LIST:")
    for Window in WindowList:
      print("--WINDOW:")
      for Op in Window:
        Op.print()
  return RerollableCandidatesList


def RunRerollerOnBlock(Block : RoseBlock, BlockToRerollableCandidatesMap : dict):
  print("RUN REROLLER ON BLOCK")
  print("BLOCK:")
  print(Block)
  Block.print()
  # Collect groups instructions that are rerollable.
  # This only works on bitvector operations.
  # Window is the moving window through code that
  # collects rellolable set of operations.
  # A legal window will end with a bvinsert operation.
  RerollableCandidateWindows = []
  Window = []
  TotalNumInsts = Block.getNumOperations()
  for Index in range(TotalNumInsts):
    Operation = Block.getOperation(Index)
    # Once we hit an instruction that cannot reroll, 
    # we quit if we have found some candidates already.
    # If not, we keep looking.
    if not isinstance(Operation, RoseCallOp) \
    and not isinstance(Operation, RoseBitVectorOp):
      if len(RerollableCandidateWindows) == 0:
        continue
      else:
        break
    if Window == []:
      Window.append(Operation)
      continue
    # This op can be a candidate for being added to the window
    PutOpInWindow = True
    for Op in Window:
      # Check if the bitvector opcode and bitvector operands match
      if Op.getOpcode() == Operation.getOpcode() \
      and Op.getBitVectorOperands() == Operation.getBitVectorOperands():
          PutOpInWindow = False
          break
    if PutOpInWindow == True:
      Window.append(Operation)
    else:
      # This is the end of the window. Assert that this window
      # ends with a bvinsert operation.
      assert len(Window) > 0
      LastOp = Window[len(Window) - 1]
      assert isinstance(LastOp, RoseBVInsertSliceOp)
      # Insert the window to the candidates list and empty the window
      RerollableCandidateWindows.append(Window)
      Window = [Operation]

  # Get a set of rerollable sets
  RerollableCandidatesList = GetValidRerollableCandidates(RerollableCandidateWindows)
  print(RerollableCandidatesList)

  # Add the set to the block map
  BlockToRerollableCandidatesMap[Block] = RerollableCandidatesList
  return BlockToRerollableCandidatesMap


def RunRerollerOnRegion(Region, BlockToRerollableCandidatesMap : dict):
  # Iterate over all the contents of this region
  assert not isinstance(Region, RoseBlock)
  for Abstraction in Region.getChildren():
    # Run reroller on a nested function
    if isinstance(Abstraction, RoseFunction):
      RunRerollerOnFunction(Abstraction)
      continue
    # Reroller only operates on blocks
    if not isinstance(Abstraction, RoseBlock):
      print("REGION:")
      Abstraction.print()
      BlockToRerollableCandidatesMap = RunRerollerOnRegion(Abstraction, \
                                            BlockToRerollableCandidatesMap)
      continue
    BlockToRerollableCandidatesMap = RunRerollerOnBlock(Abstraction, \
                                            BlockToRerollableCandidatesMap)
  return BlockToRerollableCandidatesMap



def GetLowOffsetsWithinWindow(Window : list):
  LowOffsetsList = list()
  StartIndex = None
  for Op in Window:
    if Op.getNumNonBVOperands() == 0:
      LowOffsetsList.append(None)
      continue
    # Now we are dealing with bitvector ops that index into bitvectors
    # First get the start index and get offsets relative to
    LowIndex = Op.getLowIndex()
    assert isinstance(LowIndex, RoseConstant)
    if StartIndex == None:
      StartIndex = LowIndex.getValue()
    LowOffsetsList.append(LowIndex.getValue() - StartIndex)
  return LowOffsetsList


def GetFirstLowIndexInWindow(Window : list):
  for Op in Window:
    if Op.getNumNonBVOperands() == 0:
      continue
    # Now we are dealing with bitvector ops that index into bitvectors
    # First get the start index and get offsets relative to
    assert isinstance(Op.getLowIndex(), RoseConstant)
    return Op.getLowIndex().getValue()
  return None


# We just get the difference between 
def GetStepForRerolledLoop(Window1 : list, Window2 : list):
  assert len(Window1) == len(Window2)
  for Index in range(len(Window1)):
    assert Window1[Index].getOutputBitwidth() == Window2[Index].getOutputBitwidth()
    NumNonBVOperands1 = Window1[Index].getNumNonBVOperands()
    NumNonBVOperands2 = Window2[Index].getNumNonBVOperands()
    assert NumNonBVOperands1 == NumNonBVOperands2
    # If this operation has not indexing operands, just move on
    if NumNonBVOperands1 == 0:
      continue
    # Get low offsets between instructions
    LowIndex1 = Window1[Index].getLowIndex()
    LowIndex2 = Window2[Index].getLowIndex()
    assert isinstance(LowIndex1, RoseConstant)
    assert isinstance(LowIndex2, RoseConstant)
    return (LowIndex2.getValue() - LowIndex1.getValue())
  return None


def RunRerollerOnFunction(Function : RoseFunction):
  print("RUN ON REROLLER FUNCTION")
  print("FUNCTION:")
  Function.print()
  # Mapping root instruction to list of redundant instructions
  BlockToRerollableCandidatesMap = dict()

  # Run loop reroller on the given function
  BlockToRerollableCandidatesMap = RunRerollerOnRegion(Function, \
                                    BlockToRerollableCandidatesMap)
  
  # Now that the map is populated, we reroll all the candidates
  print("MAPPINGS:")
  print(BlockToRerollableCandidatesMap)
  for Block, RerollableCandidatesList in BlockToRerollableCandidatesMap.items():
    for WindowList in RerollableCandidatesList:
      # Lets get the offsets across windows and other info for generating a loop
      LowOffsetsList = GetLowOffsetsWithinWindow(WindowList[0])
      Step = GetStepForRerolledLoop(WindowList[0], WindowList[1])
      Start = GetFirstLowIndexInWindow(WindowList[0])
      End = GetFirstLowIndexInWindow(WindowList[len(WindowList) - 1])
      print("START:")
      print(Start)
      print("END:")
      print(End)
      print("STEP:")
      print(Step)
      print("LowOffsetsList:")
      print(LowOffsetsList)
      # Generate a loop
      Loop = RoseForLoop.create("iterator", End, Start, Step)
      Iterator = Loop.getIterator()
      # Map to track old and new ops.
      OldToNewOPsMap = dict()
      # Insert operations in the generated loop.
      for OpIndex, Op in enumerate(WindowList[0]):
        # Handle ops that do not have indices in operands
        if Op.getNumNonBVOperands() == 0:
          NewOp = Op
          for Index, Operand in enumerate(Op.getOperands()):
            NewOperand = OldToNewOPsMap.get(Operand, RoseUndefValue())
            if NewOperand == RoseUndefValue():
              # Operand is coming from some other source, just use 
              # the same operand as the old op.
              NewOperand = Op.getOperand(Index)
            NewOp.setOperand(Index, NewOperand)
          OldToNewOPsMap[Op] = NewOp
          Loop.addAbstraction(NewOp)
          continue
        # Handle instructions with indices as operands
        LowOffset = LowOffsetsList[OpIndex]
        assert LowOffset != None
        if LowOffset != 0:
          # Generate an add instruction
          LowOffsetVal = RoseConstant(LowOffset, Iterator.getType())
          LowIndex = RoseAddOp.create("low.offset." + str(OpIndex), [Iterator, LowOffsetVal]) 
          Loop.addAbstraction(LowIndex)
        else:
          LowIndex = Iterator
        OpBitWidthVal = RoseConstant(Op.getOutputBitwidth(), Iterator.getType())
        HighIndex = RoseAddOp.create("high.offset." + str(OpIndex), [LowIndex, OpBitWidthVal]) 
        Loop.addAbstraction(HighIndex)
        NewOp = Op
        for Index, Operand in enumerate(Op.getOperands()):
          if Index == Op.getLowIndexPos():
            NewOp.setOperand(Index, LowIndex)
            continue
          if Index == Op.getHighIndexPos():
            NewOp.setOperand(Index, HighIndex)
            continue
          if isinstance(Operand, RoseConstant):
            # Just copy this constant over
            NewOp.setOperand(Index, Operand)
            continue
          NewOperand = OldToNewOPsMap.get(Operand, RoseUndefValue())
          if NewOperand == RoseUndefValue():
            # Operand is coming from some other source, just use 
            # the same operand as the old op.
            NewOperand = Op.getOperand(Index)
          NewOp.setOperand(Index, NewOperand)
        OldToNewOPsMap[Op] = NewOp
        Loop.addAbstraction(NewOp)
      # This is the full loop
      Loop.print()

      




# Runs Loop reroller
def Run(Function : RoseFunction):
  print("RUN LOOP REROLLER")
  RunRerollerOnFunction(Function)
  Function.print()



