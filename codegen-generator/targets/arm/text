CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
BEGIN
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    if sub_op then
    BEGIN
        Elem[result, e, esize] = element1 - element2;
    END
    else
    BEGIN
        Elem[result, e, esize] = element1 + element2;

    END
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
BEGIN
    if pair then
    BEGIN
        element1 = Elem[concat, 2*e, esize];
        element2 = Elem[concat, (2*e)+1, esize];
    END
    else
    BEGIN
        element1 = Elem[operand1, e, esize];
        element2 = Elem[operand2, e, esize];
    END
    Elem[result, e, esize] = FPAdd(element1, element2, FPCR[]);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize)   operand1 = Vpart[n, part];
bits(datasize)   operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
integer sum;

for e = 0 to elements-1
BEGIN
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    if sub_op then
    BEGIN
        sum = element1 - element2;
    END
    else
    BEGIN
        sum = element1 + element2;
    END
    Elem[result, e, 2*esize] = sum[2*esize-1:0];

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand1 = V[n];
bits(datasize)   operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
integer sum;

for e = 0 to elements-1
BEGIN
    element1 = Int(Elem[operand1, e, 2*esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    if sub_op then
    BEGIN
        sum = element1 - element2;
    END
    else
    BEGIN
        sum = element1 + element2;
    END
    Elem[result, e, 2*esize] = sum[2*esize-1:0];

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer sum;

for e = 0 to elements-1
BEGIN
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    sum = element1 + element2;
    Elem[result, e, esize] = sum[esize:1];

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;

for e = 0 to elements-1
BEGIN
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    Elem[result, e, esize] = (element1 + element2 + 1)[esize:1];

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer sum;
boolean sat;

for e = 0 to elements-1
BEGIN
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    sum = element1 + element2;
    (Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned);
    if sat then FPSR.QC = '1';

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;

bits(datasize) operand2 = V[d];
integer op1;
integer op2;
boolean sat;

for e = 0 to elements-1
BEGIN
    op1 = Int(Elem[operand, e, esize], !unsigned);
    op2 = Int(Elem[operand2, e, esize], unsigned);
    (Elem[result, e, esize], sat) = SatQ(op1 + op2, esize, unsigned);
    if sat then FPSR.QC = '1';
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand1 = V[n];
bits(2*datasize) operand2 = V[m];
bits(datasize)   result;
integer round_const = if round then 1 << (esize - 1) else 0;
bits(2*esize) element1;
bits(2*esize) element2;
bits(2*esize) sum;

for e = 0 to elements-1
BEGIN
    element1 = Elem[operand1, e, 2*esize];
    element2 = Elem[operand2, e, 2*esize];
    if sub_op then
    BEGIN
        sum = element1 - element2;
    END
    else
    BEGIN
        sum = element1 + element2;
    END
    sum = sum + round_const;
    Elem[result, e, esize] = sum[2*esize-1:esize];

END
Vpart[d, part] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
bits(esize) product;

for e = 0 to elements-1
BEGIN
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    if poly then
    BEGIN
        product = PolynomialMult(element1, element2)[esize-1:0];
    END
    else
    BEGIN
        product = (UInt(element1) * UInt(element2))[esize-1:0];
    END
    Elem[result, e, esize] = product;

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
BEGIN
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPMul(element1, element2, FPCR[]);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];

bits(esize) element1;
bits(esize) element2;
FPCRType fpcr    = FPCR[];
boolean merge    = elements == 1 && IsMerging(fpcr);
bits(128) result = if merge then V[n] else Zeros();

for e = 0 to elements-1
BEGIN
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPMulX(element1, element2, fpcr);
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
BEGIN
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPDiv(element1, element2, FPCR[]);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
bits(esize) product;

for e = 0 to elements-1
BEGIN
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    product = (UInt(element1) * UInt(element2))[esize-1:0];
    if sub_op then
    BEGIN
        Elem[result, e, esize] = Elem[operand3, e, esize] - product;
    END
    else
    BEGIN
        Elem[result, e, esize] = Elem[operand3, e, esize] + product;

    END
END
V[d] = result;






CheckFPAdvSIMDEnabled64();
bits(datasize)   operand1 = Vpart[n, part];
bits(datasize)   operand2 = Vpart[m, part];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
bits(2*esize) accum;

for e = 0 to elements-1
BEGIN
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    product = (element1 * element2)[2*esize-1:0];
    if sub_op then
    BEGIN
        accum = Elem[operand3, e, 2*esize] - product;
    END
    else
    BEGIN
        accum = Elem[operand3, e, 2*esize] + product;
    END
    Elem[result, e, 2*esize] = accum;

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
BEGIN
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    if sub_op then element1 = FPNeg(element1);
    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR[]);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();

bits(esize) operanda = V[a];
bits(esize) operand1 = V[n];
bits(esize) operand2 = V[m];

FPCRType fpcr = FPCR[];
boolean merge    = IsMerging(fpcr);
bits(128) result = if merge then V[a] else Zeros();

if opa_neg then operanda = FPNeg(operanda);
if op1_neg then operand1 = FPNeg(operand1);
Elem[result, 0, esize] = FPMulAdd(operanda, operand1, operand2, fpcr);

V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer round_const = if rounding then 1 << (esize - 1) else 0;
integer element1;
integer element2;
integer product;
boolean sat;

for e = 0 to elements-1
BEGIN
    element1 = SInt(Elem[operand1, e, esize]);
    element2 = SInt(Elem[operand2, e, esize]);
    product = (2 * element1 * element2) + round_const;
    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);
    if sat then FPSR.QC = '1';

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize)   operand1 = Vpart[n, part];
bits(datasize)   operand2 = Vpart[m, part];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
integer accum;
boolean sat1;
boolean sat2;

for e = 0 to elements-1
BEGIN
    element1 = SInt(Elem[operand1, e, esize]);
    element2 = SInt(Elem[operand2, e, esize]);
    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);
    if sub_op then
    BEGIN
        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);
    END
    else
    BEGIN
        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);
    END
    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);
    if sat1 || sat2 then FPSR.QC = '1';

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize)   operand1 = Vpart[n, part];
bits(datasize)   operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;

for e = 0 to elements-1
BEGIN
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    Elem[result, e, 2*esize] = (element1 * element2)[2*esize-1:0];

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize)   operand1 = Vpart[n, part];
bits(datasize)   operand2 = Vpart[m, part];
bits(2*datasize) result;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
BEGIN
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    Elem[result, e, 2*esize] = PolynomialMult(element1, element2);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize)   operand1 = Vpart[n, part];
bits(datasize)   operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
boolean sat;

for e = 0 to elements-1
BEGIN
    element1 = SInt(Elem[operand1, e, esize]);
    element2 = SInt(Elem[operand2, e, esize]);
    (product, sat) = SignedSatQ(2 * element1 * element2, 2*esize);
    Elem[result, e, 2*esize] = product;
    if sat then FPSR.QC = '1';

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];

bits(esize) element1;
bits(esize) element2;
bits(esize) diff;
FPCRType fpcr = FPCR[];
bits(datasize) result;

for e = 0 to elements-1
BEGIN
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    diff = FPSub(element1, element2, fpcr);
    Elem[result, e, esize] = if abs then FPAbs(diff) else diff;

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer diff;

for e = 0 to elements-1
BEGIN
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    diff = element1 - element2;
    Elem[result, e, esize] = diff[esize:1];

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer diff;
boolean sat;

for e = 0 to elements-1
BEGIN
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    diff = element1 - element2;
    (Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned);
    if sat then FPSR.QC = '1';

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
boolean test_passed;

for e = 0 to elements-1
BEGIN
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    if and_test then
    BEGIN
        test_passed = !IsZero(element1 AND element2);
    END
    else
    BEGIN
        test_passed = (element1 == element2);
    END
    Elem[result, e, esize] = if test_passed then Ones() else Zeros();

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];

bits(esize) element1;
bits(esize) element2;
boolean test_passed;
FPCRType fpcr    = FPCR[];
boolean merge    = elements == 1 && IsMerging(fpcr);
bits(128) result = if merge then V[m] else Zeros();

for e = 0 to elements-1
BEGIN
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    if abs then
    BEGIN
        element1 = FPAbs(element1);
        element2 = FPAbs(element2);
    END
    case cmp of
    BEGIN
        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, fpcr);
        when CompareOp_GE test_passed = FPCompareGE(element1, element2, fpcr);
        when CompareOp_GT test_passed = FPCompareGT(element1, element2, fpcr);
    END
    Elem[result, e, esize] = if test_passed then Ones() else Zeros();

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;
boolean test_passed;

for e = 0 to elements-1
BEGIN
    element = SInt(Elem[operand, e, esize]);
    case comparison of
    BEGIN
        when CompareOp_GT test_passed = element > 0;
        when CompareOp_GE test_passed = element >= 0;
        when CompareOp_EQ test_passed = element == 0;
        when CompareOp_LE test_passed = element <= 0;
        when CompareOp_LT test_passed = element < 0;
    END
    Elem[result, e, esize] = if test_passed then Ones() else Zeros();

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) zero = FPZero('0');
bits(esize) element;
boolean test_passed;

for e = 0 to elements-1
BEGIN
    element = Elem[operand, e, esize];
    case comparison of
    BEGIN
        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR[]);
        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR[]);
        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR[]);
        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR[]);
        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR[]);
    END
    Elem[result, e, esize] = if test_passed then Ones() else Zeros();

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
boolean test_passed;

for e = 0 to elements-1
BEGIN
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;
    Elem[result, e, esize] = if test_passed then Ones() else Zeros();

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
bits(esize) absdiff;

result = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
BEGIN
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    absdiff = Abs(element1 - element2)[esize-1:0];
    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];

bits(esize) element1;
bits(esize) element2;
bits(esize) diff;
FPCRType fpcr    = FPCR[];
boolean merge    = elements == 1 && IsMerging(fpcr);
bits(128) result = if merge then V[n] else Zeros();

for e = 0 to elements-1
BEGIN
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    diff = FPSub(element1, element2, fpcr);
    Elem[result, e, esize] = if abs then FPAbs(diff) else diff;

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize)   operand1 = Vpart[n, part];
bits(datasize)   operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) absdiff;

result = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
BEGIN
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    absdiff = Abs(element1 - element2)[2*esize-1:0];
    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer maxmin;

for e = 0 to elements-1
BEGIN
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
    Elem[result, e, esize] = maxmin[esize-1:0];

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
BEGIN
    if pair then
    BEGIN
        element1 = Elem[concat, 2*e, esize];
        element2 = Elem[concat, (2*e)+1, esize];
    END
    else
    BEGIN
        element1 = Elem[operand1, e, esize];
        element2 = Elem[operand2, e, esize];

    END
    if minimum then
    BEGIN
        Elem[result, e, esize] = FPMin(element1, element2, FPCR[]);
    END
    else
    BEGIN
        Elem[result, e, esize] = FPMax(element1, element2, FPCR[]);

    END
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
BEGIN
    if pair then
    BEGIN
        element1 = Elem[concat, 2*e, esize];
        element2 = Elem[concat, (2*e)+1, esize];
    END
    else
    BEGIN
        element1 = Elem[operand1, e, esize];
        element2 = Elem[operand2, e, esize];

    END
    if minimum then
    BEGIN
        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR[]);
    END
    else
    BEGIN
        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR[]);

    END
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;

integer round_const = 0;
integer shift;
integer element;
boolean sat;

for e = 0 to elements-1
BEGIN
    shift = SInt(Elem[operand2, e, esize][7:0]);
    if rounding then
    BEGIN
        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift 
    END
    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
    if saturating then
    BEGIN
        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
        if sat then FPSR.QC = '1';
    END
    else
    BEGIN
        Elem[result, e, esize] = element[esize-1:0];

    END
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand  = V[n];
bits(datasize) operand2;
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;

operand2 = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
BEGIN
    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
    Elem[result, e, esize] = Elem[operand2, e, esize] + element[esize-1:0];

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand  = V[n];
bits(datasize) result;

for e = 0 to elements-1
BEGIN
    Elem[result, e, esize] = LSL(Elem[operand, e, esize], shift);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand  = V[n];
bits(datasize) result;
integer element;
boolean sat;

for e = 0 to elements-1
BEGIN
    element = Int(Elem[operand, e, esize], src_unsigned) << shift;
    (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);
    if sat then FPSR.QC = '1';

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize*2) operand = V[n];
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;

for e = 0 to elements-1
BEGIN
    element = (UInt(Elem[operand, e, 2*esize]) + round_const) >> shift;
    Elem[result, e, esize] = element[esize-1:0];

END
Vpart[d, part] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize*2) operand = V[n];
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
boolean sat;

for e = 0 to elements-1
BEGIN
    element = (SInt(Elem[operand, e, 2*esize]) + round_const) >> shift;
    (Elem[result, e, esize], sat) = UnsignedSatQ(element, esize);
    if sat then FPSR.QC = '1';

END
Vpart[d, part] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize*2) operand = V[n];
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
boolean sat;

for e = 0 to elements-1
BEGIN
    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;
    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
    if sat then FPSR.QC = '1';

END
Vpart[d, part] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = Vpart[n, part];
bits(datasize*2) result;
integer element;

for e = 0 to elements-1
BEGIN
    element = Int(Elem[operand, e, esize], unsigned) << shift;
    Elem[result, e, 2*esize] = element[2*esize-1:0];

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand  = V[n];
bits(datasize) operand2 = V[d];
bits(datasize) result;
bits(esize) mask = LSR(Ones(esize), shift);
bits(esize) shifted;

for e = 0 to elements-1
BEGIN
    shifted = LSR(Elem[operand, e, esize], shift);
    Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand  = V[n];
bits(datasize) operand2 = V[d];
bits(datasize) result;
bits(esize) mask = LSL(Ones(esize), shift);
bits(esize) shifted;

for e = 0 to elements-1
BEGIN
    shifted = LSL(Elem[operand, e, esize], shift);
    Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand  = V[n];

bits(esize) element;
FPCRType fpcr    = FPCR[];
boolean merge    = elements == 1 && IsMerging(fpcr);
bits(128) result = if merge then V[d] else Zeros();
for e = 0 to elements-1
BEGIN
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, fpcr, rounding);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];

bits(esize) element;
FPCRType fpcr    = FPCR[];
boolean merge    = elements == 1 && IsMerging(fpcr);
bits(128) result = if merge then V[d] else Zeros();

for e = 0 to elements-1
BEGIN
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, fpcr, rounding);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand  = V[n];

bits(esize) element;
FPCRType fpcr    = FPCR[];
boolean merge    = elements == 1 && IsMerging(fpcr);
bits(128) result = if merge then V[d] else Zeros();

for e = 0 to elements-1
BEGIN
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, fpcr, rounding);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand = V[n];
bits(datasize) result;

for e = 0 to elements-1
BEGIN
    Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR[]);

END
Vpart[d, part] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = Vpart[n, part];
bits(2*datasize) result;

for e = 0 to elements-1
BEGIN
    Elem[result, e, 2*esize] = FPConvert(Elem[operand, e, esize], FPCR[]);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();

bits(2*datasize) operand = V[n];
FPCRType fpcr    = FPCR[];
boolean merge    = elements == 1 && IsMerging(fpcr);
bits(128) result = if merge then V[d] else Zeros();

for e = 0 to elements-1
BEGIN
    Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], fpcr, FPRounding_ODD);

END
if merge then
BEGIN
    V[d] = result;
END
else
BEGIN
    Vpart[d, part] = Elem[result, 0, datasize];



END
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;

for e = 0 to elements-1
BEGIN
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPRoundInt(element, FPCR[], rounding, exact);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand = V[n];
bits(datasize) result;
bits(2*esize) element;

for e = 0 to elements-1
BEGIN
    element = Elem[operand, e, 2*esize];
    Elem[result, e, esize] = element[esize-1:0];
END
Vpart[d, part] = result;



CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand = V[n];
bits(datasize) result;
bits(2*esize) element;
boolean sat;

for e = 0 to elements-1
BEGIN
    element = Elem[operand, e, 2*esize];
    (Elem[result, e, esize], sat) = SatQ(Int(element, unsigned), esize, unsigned);
    if sat then FPSR.QC = '1';

END
Vpart[d, part] = result;



CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand = V[n];
bits(datasize) result;
bits(2*esize) element;
boolean sat;

for e = 0 to elements-1
BEGIN
    element = Elem[operand, e, 2*esize];
    (Elem[result, e, esize], sat) = UnsignedSatQ(SInt(element), esize);
    if sat then FPSR.QC = '1';

END
Vpart[d, part] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;

for e = 0 to elements-1
BEGIN
    element = SInt(Elem[operand, e, esize]);
    if neg then
    BEGIN
        element = -element;
    END
    else
    BEGIN
        element = Abs(element);
    END
    Elem[result, e, esize] = element[esize-1:0];                

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;

for e = 0 to elements-1
BEGIN
    element = Elem[operand, e, esize];
    if neg then
    BEGIN
        element = FPNeg(element);
    END
    else
    BEGIN
        element = FPAbs(element);
    END
    Elem[result, e, esize] = element;

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;
boolean sat;

for e = 0 to elements-1
BEGIN
    element = SInt(Elem[operand, e, esize]);
    if neg then
    BEGIN
        element = -element;
    END
    else
    BEGIN
        element = Abs(element);
    END
    (Elem[result, e, esize], sat) = SignedSatQ(element, esize);         
    if sat then FPSR.QC = '1';

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;

integer count;
for e = 0 to elements-1
BEGIN
    if countop == CountOp_CLS then
    BEGIN
        count = CountLeadingSignBits(Elem[operand, e, esize]);
    END
    else
    BEGIN
        count = CountLeadingZeroBits(Elem[operand, e, esize]);
    END
    Elem[result, e, esize] = count[esize-1:0];
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;

integer count;
for e = 0 to elements-1
BEGIN
    count = BitCount(Elem[operand, e, esize]);
    Elem[result, e, esize] = count[esize-1:0];
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(32) element;

for e = 0 to elements-1
BEGIN
    element = Elem[operand, e, 32];
    Elem[result, e, 32] = UnsignedRecipEstimate(element);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];

FPCRType fpcr    = FPCR[];
boolean merge    = elements == 1 && IsMerging(fpcr);
bits(128) result = if merge then V[d] else Zeros();
bits(esize) element;

for e = 0 to elements-1
BEGIN
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPRecipEstimate(element, FPCR[]);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];

bits(esize) element1;
bits(esize) element2;
FPCRType fpcr    = FPCR[];
boolean merge    = elements == 1 && IsMerging(fpcr);
bits(128) result = if merge then V[n] else Zeros();

for e = 0 to elements-1
BEGIN
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPRecipStepFused(element1, element2);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;

for e = 0 to elements-1
BEGIN
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPSqrt(element, FPCR[]);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(32) element;

for e = 0 to elements-1
BEGIN
    element = Elem[operand, e, 32];
    Elem[result, e, 32] = UnsignedRSqrtEstimate(element);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];

bits(esize) element;
FPCRType fpcr    = FPCR[];
boolean merge    = elements == 1 && IsMerging(fpcr);
bits(128) result = if merge then V[d] else Zeros();

for e = 0 to elements-1
BEGIN
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPRSqrtEstimate(element, fpcr);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];

bits(esize) element1;
bits(esize) element2;
FPCRType fpcr    = FPCR[];
boolean merge    = elements == 1 && IsMerging(fpcr);
bits(128) result = if merge then V[n] else Zeros();

for e = 0 to elements-1
BEGIN
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPRSqrtStepFused(element1, element2);

END
V[d] = result;







CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;

if invert then operand2 = NOT(operand2);

case op of
BEGIN
    when LogicalOp_AND
    BEGIN
        result = operand1 AND operand2;
    END
    when LogicalOp_ORR
    BEGIN
        result = operand1 OR operand2;

    END
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1;
bits(datasize) operand2;
bits(datasize) operand3;
bits(datasize) operand4 = V[n];

case op of
BEGIN
    when VBitOp_VEOR
    BEGIN
        operand1 = V[m];
        operand2 = Zeros();
        operand3 = Ones();
    END
    when VBitOp_VBSL
    BEGIN
        operand1 = V[m];
        operand2 = operand1;
        operand3 = V[d];
    END
    when VBitOp_VBIT
    BEGIN
        operand1 = V[d];
        operand2 = operand1;
        operand3 = V[m];
    END
    when VBitOp_VBIF
    BEGIN
        operand1 = V[d];
        operand2 = operand1;
        operand3 = NOT(V[m]);

    END
END
V[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);



CheckFPAdvSIMDEnabled64();
bits(idxdsize) operand = V[n];
bits(128) result;

result = V[d];
Elem[result, dst_index, esize] = Elem[operand, src_index, esize];
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(idxdsize) operand = V[n];
bits(datasize) result;
bits(esize) element;

element = Elem[operand, index, esize];
for e = 0 to elements-1
BEGIN
    Elem[result, e, esize] = element;
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
bits(esize) rev;

for e = 0 to elements-1
BEGIN
    element = Elem[operand, e, esize];
    for i = 0 to esize-1
    BEGIN
        rev[esize-1-i] = element[i];
    END
    Elem[result, e, esize] = rev;

END
V[d] = result;



CheckFPAdvSIMDEnabled64();

bits(64) address;
bits(64) offs;
bits(datasize) rval;
integer tt;
constant integer ebytes = esize DIV 8;

if HaveMTE2Ext() then
BEGIN
    SetTagCheckedInstruction(tag_checked);

END
if n == 31 then
BEGIN
    CheckSPAlignment();
    address = SP[];
END
else
BEGIN
    address = X[n];

END
offs = Zeros();
for r = 0 to rpt-1
BEGIN
    for e = 0 to elements-1
    BEGIN
        tt = (t + r) MOD 32;
        for s = 0 to selem-1
        BEGIN
            rval = V[tt];
            if memop == MemOp_LOAD then
            BEGIN
                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];
                V[tt] = rval;
            END
            else // memop == MemOp_STORE
            BEGIN
                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
            END
            offs = offs + ebytes;
            tt = (tt + 1) MOD 32;

        END
    END
END
if wback then
BEGIN
    if m != 31 then
    BEGIN
        offs = X[m];
    END
    if n == 31 then
    BEGIN
        SP[] = address + offs;
    END
    else
    BEGIN
        X[n] = address + offs;



    END
END
if HaveMTE2Ext() then
BEGIN
    SetTagCheckedInstruction(tag_checked);

END
CheckFPAdvSIMDEnabled64();

bits(64) address;
bits(64) offs;
bits(128) rval;
bits(esize) element;
constant integer ebytes = esize DIV 8;

if n == 31 then
BEGIN
    CheckSPAlignment();
    address = SP[];
END
else
BEGIN
    address = X[n];

END
offs = Zeros();
if replicate then
BEGIN
    // load and replicate to all elements
    for s = 0 to selem-1
    BEGIN
        element = Mem[address + offs, ebytes, AccType_VEC];
        // replicate to fill 128- or 64-bit register
        V[t] = Replicate(element, datasize DIV esize);
        offs = offs + ebytes;
        t = (t + 1) MOD 32;
    END
END
else
BEGIN
    // load/store one element per register
    for s = 0 to selem-1
    BEGIN
        rval = V[t];
        if memop == MemOp_LOAD then
        BEGIN
            // insert into one lane of 128-bit register
            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
            V[t] = rval;
        END
        else // memop == MemOp_STORE
        BEGIN
            // extract from one lane of 128-bit register
            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
        END
        offs = offs + ebytes;
        t = (t + 1) MOD 32;

    END
END
if wback then
BEGIN
    if m != 31 then
    BEGIN
        offs = X[m];
    END
    if n == 31 then
    BEGIN
        SP[] = address + offs;
    END
    else
    BEGIN
        X[n] = address + offs;



    END
END
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
BEGIN
    element1 = Elem[concat, 2*e, esize];
    element2 = Elem[concat, (2*e)+1, esize];
    Elem[result, e, esize] = element1 + element2;

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;

bits(2*esize) sum;
integer op1;
integer op2;

if acc then result = V[d];
for e = 0 to elements-1
BEGIN
    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);
    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);
    sum = (op1 + op2)[2*esize-1:0];
    if acc then
    BEGIN
        Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;
    END
    else
    BEGIN
        Elem[result, e, 2*esize] = sum;

    END
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
integer element1;
integer element2;
integer maxmin;

for e = 0 to elements-1
BEGIN
    element1 = Int(Elem[concat, 2*e, esize], unsigned);
    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);
    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
    Elem[result, e, esize] = maxmin[esize-1:0];

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(op, operand, esize);



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
integer sum;

sum = Int(Elem[operand, 0, esize], unsigned);
for e = 1 to elements-1
BEGIN
    sum = sum + Int(Elem[operand, e, esize], unsigned);

END
V[d] = sum[2*esize-1:0];



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
integer maxmin;
integer element;

maxmin = Int(Elem[operand, 0, esize], unsigned);
for e = 1 to elements-1
BEGIN
    element = Int(Elem[operand, e, esize], unsigned);
    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);

END
V[d] = maxmin[esize-1:0];



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];

V[d] = Reduce(op, operand, esize);



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
boolean altfp = FALSE;
V[d] = Reduce(op, operand, esize, altfp);



CheckFPAdvSIMDEnabled64();
bits(datasize) hi = V[m];
bits(datasize) lo = V[n];
bits(datasize*2) concat = hi : lo;

V[d] = concat[position+datasize-1:position];



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element = 0;
integer rev_element;
for c = 0 to containers-1
BEGIN
    rev_element = element + elements_per_container - 1;
    for e = 0 to elements_per_container-1
    BEGIN
        Elem[result, rev_element, esize] = Elem[operand, element, esize];
        element = element + 1;
        rev_element = rev_element - 1;

    END
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;

integer base = part * pairs;

for p = 0 to pairs-1
BEGIN
    Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];
    Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operandl = V[n];
bits(datasize) operandh = V[m];
bits(datasize) result;

bits(datasize*2) zipped = operandh:operandl;
for e = 0 to elements-1
BEGIN
    Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;

for p = 0 to pairs-1
BEGIN
    Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];
    Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) indices = V[m];
bits(128*regs) table = Zeros();
bits(datasize) result;
integer index;

// Create table from registers
for i = 0 to regs - 1
BEGIN
    table[128*i+127:128*i] = V[n];
    n = (n + 1) MOD 32;

END
result = if is_tbl then Zeros() else V[d];
for i = 0 to elements - 1
BEGIN
    index = UInt(Elem[indices, i, 8]);
    if index < 16 * regs then
    BEGIN
        Elem[result, i, 8] = Elem[table, index, 8];

    END
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(idxdsize) operand = V[n];

X[d] = ZeroExtend(Elem[operand, index, esize], datasize);



CheckFPAdvSIMDEnabled64();
bits(idxdsize) operand = V[n];

X[d] = SignExtend(Elem[operand, index, esize], datasize);



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];

FPCRType fpcr    = FPCR[];
boolean merge    = elements == 1 && IsMerging(fpcr);
bits(128) result = if merge then V[d] else Zeros();
bits(esize) element;

for e = 0 to elements-1
BEGIN
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPRecpX(element, fpcr);

END
V[d] = result;



if HaveMTE2Ext() then
BEGIN
    SetTagCheckedInstruction(tag_checked);

END
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(datasize) data;

if n == 31 then
BEGIN
    CheckSPAlignment();
    address = SP[];
END
else
BEGIN
    address = X[n];

END
if ! postindex then
BEGIN
    address = address + offset;

END
case memop of
BEGIN
    when MemOp_STORE
    BEGIN
        data = V[t];
        Mem[address, datasize DIV 8, acctype] = data;

    END
    when MemOp_LOAD
    BEGIN
        data = Mem[address, datasize DIV 8, acctype];
        V[t] = data;

    END
END
if wback then
BEGIN
    if postindex then
    BEGIN
        address = address + offset;
    END
    if n == 31 then
    BEGIN
        SP[] = address;
    END
    else
    BEGIN
        X[n] = address;



    END
END
AArch64.CheckFPAdvSIMDEnabled();

bits(128) operand1 = V[d];
bits(128) operand2 = V[n];
bits(128) result;
result = operand1 EOR operand2;
if decrypt then
BEGIN
    result = AESInvSubBytes(AESInvShiftRows(result));
END
else
BEGIN
    result = AESSubBytes(AESShiftRows(result));

END
V[d] = result;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) operand = V[n];
bits(128) result;
if decrypt then
BEGIN
    result = AESInvMixColumns(operand);
END
else
BEGIN
    result = AESMixColumns(operand);
END
V[d] = result;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) X = V[d];
bits(32)  Y = V[n];     // Note: 32 not 128 bits wide
bits(128) W = V[m];
bits(32)  t;

for e = 0 to 3
BEGIN
    t = SHAchoose(X[63:32], X[95:64], X[127:96]);
    Y = Y + ROL(X[31:0], 5) + t + Elem[W, e, 32];
    X[63:32] = ROL(X[63:32], 30);
    [Y, X] = ROL(Y : X, 32);
END
V[d] = X;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) X = V[d];
bits(32)  Y = V[n];     // Note: 32 not 128 bits wide
bits(128) W = V[m];
bits(32)  t;

for e = 0 to 3
BEGIN
    t = SHAparity(X[63:32], X[95:64], X[127:96]);
    Y = Y + ROL(X[31:0], 5) + t + Elem[W, e, 32];
    X[63:32] = ROL(X[63:32], 30);
    [Y, X] = ROL(Y : X, 32);
END
V[d] = X;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) X = V[d];
bits(32)  Y = V[n];     // Note: 32 not 128 bits wide
bits(128) W = V[m];
bits(32)  t;

for e = 0 to 3
BEGIN
    t = SHAmajority(X[63:32], X[95:64], X[127:96]);
    Y = Y + ROL(X[31:0], 5) + t + Elem[W, e, 32];
    X[63:32] = ROL(X[63:32], 30);
    [Y, X] = ROL(Y : X, 32);
END
V[d] = X;



AArch64.CheckFPAdvSIMDEnabled();

bits(32) operand = V[n];        // read element [0] only,  [1-3] zeroed
V[d] = ROL(operand, 30);



AArch64.CheckFPAdvSIMDEnabled();

bits(128) operand1 = V[d];
bits(128) operand2 = V[n];
bits(128) operand3 = V[m];
bits(128) result;

result = operand2[63:0] : operand1[127:64];
result = result EOR operand1 EOR operand3;
V[d] = result;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) operand1 = V[d];
bits(128) operand2 = V[n];
bits(128) result;
bits(128) T = operand1 EOR LSR(operand2, 32);
result[31:0]   = ROL(T[31:0],   1);
result[63:32]  = ROL(T[63:32],  1);
result[95:64]  = ROL(T[95:64],  1);
result[127:96] = ROL(T[127:96], 1) EOR ROL(T[31:0], 2);
V[d] = result;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) result;
if part1 then
BEGIN
    result = SHA256hash(V[d], V[n], V[m], TRUE);
END
else
BEGIN
    result = SHA256hash(V[n], V[d], V[m], FALSE);
END
V[d] = result;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) operand1 = V[d];
bits(128) operand2 = V[n];
bits(128) result;
bits(128) T = operand2[31:0] : operand1[127:32];
bits(32) elt;

for e = 0 to 3
BEGIN
    elt = Elem[T, e, 32];
    elt = ROR(elt, 7) EOR ROR(elt, 18) EOR LSR(elt, 3);
    Elem[result, e, 32] = elt + Elem[operand1, e, 32];
END
V[d] = result;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) operand1 = V[d];
bits(128) operand2 = V[n];
bits(128) operand3 = V[m];
bits(128) result;
bits(128) T0 = operand3[31:0] : operand2[127:32];
bits(64) T1;
bits(32) elt;

T1 = operand3[127:64];
for e = 0 to 1
BEGIN
    elt = Elem[T1, e, 32];
    elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);
    elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];
    Elem[result, e, 32] = elt;

END
T1 = result[63:0];
for e = 2 to 3
BEGIN
    elt = Elem[T1, e - 2, 32];
    elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);
    elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];
    Elem[result, e, 32] = elt;

END
V[d] = result;



bits(32)      acc     = X[n];   // accumulator
bits(size)    val     = X[m];   // input value
bits(32)      poly    = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)[31:0];

bits(32+size) tempacc = BitReverse(acc) : Zeros(size);
bits(size+32) tempval = BitReverse(val) : Zeros(32);

// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation
X[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
integer rounding_const = if rounding then 1 << (esize - 1) else 0;
integer element1;
integer element2;
integer element3;
integer product;
boolean sat;

for e = 0 to elements-1
BEGIN
    element1 = SInt(Elem[operand1, e, esize]);
    element2 = SInt(Elem[operand2, e, esize]);
    element3 = SInt(Elem[operand3, e, esize]);
    if sub_op then
    BEGIN
        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);
    END
    else
    BEGIN
        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);
    END
    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);
    if sat then FPSR.QC = '1';

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;

result = V[d];
for e = 0 to elements-1 
BEGIN
    integer res = 0;
    integer element1, element2;
    for i = 0 to 3 
    BEGIN
        if signed then
        BEGIN
            element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); 
            element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);
        END
        else 
        BEGIN
            element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); 
            element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);
        END
        res = res + element1 * element2; 
    END
    Elem[result, e, esize] = Elem[result, e, esize] + res;
END
V[d] = result;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vtmp;  
bits(64)  MSigma1;
bits(64)  tmp;
bits(128) X = V[n];
bits(128) Y = V[m];
bits(128) W = V[d];

MSigma1 =  ROR(Y[127:64], 14) EOR ROR(Y[127:64],18) EOR ROR(Y[127:64],41);
Vtmp[127:64] =  (Y[127:64] AND X[63:0]) EOR (NOT(Y[127:64]) AND X[127:64]);
Vtmp[127:64] = (Vtmp[127:64] + MSigma1 +  W[127:64]);
tmp = Vtmp[127:64] + Y[63:0];
MSigma1 = ROR(tmp, 14) EOR ROR(tmp,18) EOR ROR(tmp,41);
Vtmp[63:0] = (tmp AND Y[127:64]) EOR (NOT(tmp) AND X[63:0]);
Vtmp[63:0] = (Vtmp[63:0] + MSigma1 + W[63:0]);
V[d] =  Vtmp;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vtmp;  
bits(64) NSigma0;
bits(64) tmp;
bits(128) X = V[n];
bits(128) Y = V[m];
bits(128) W = V[d];

NSigma0 =  ROR(Y[63:0], 28) EOR ROR(Y[63:0],34) EOR ROR(Y[63:0],39);
Vtmp[127:64] = (X[63:0] AND Y[127:64]) EOR (X[63:0] AND Y[63:0]) EOR (Y[127:64] AND Y[63:0]);
Vtmp[127:64] = (Vtmp[127:64] + NSigma0 +  W[127:64]);
NSigma0 =  ROR(Vtmp[127:64], 28) EOR ROR(Vtmp[127:64],34) EOR ROR(Vtmp[127:64],39);
Vtmp[63:0] =   (Vtmp[127:64] AND Y[63:0]) EOR (Vtmp[127:64] AND Y[127:64]) EOR (Y[127:64] AND Y[63:0]);
Vtmp[63:0] =   (Vtmp[63:0] + NSigma0 + W[63:0]);

V[d] = Vtmp;



AArch64.CheckFPAdvSIMDEnabled();

bits(64) sig0;
bits(128) Vtmp;
bits(128) X = V[n];
bits(128) W = V[d]; 
sig0 = ROR(W[127:64], 1) EOR ROR(W[127:64], 8) EOR ('0000000':W[127:71]);
Vtmp[63:0] = W[63:0] + sig0;
sig0 = ROR(X[63:0], 1) EOR ROR(X[63:0], 8) EOR ('0000000':X[63:7]);
Vtmp[127:64] = W[127:64] + sig0;
V[d] = Vtmp;



AArch64.CheckFPAdvSIMDEnabled();

bits(64) sig1;
bits(128) Vtmp;
bits(128) X = V[n];
bits(128) Y = V[m];
bits(128) W = V[d];

sig1 = ROR(X[127:64], 19) EOR ROR(X[127:64],61) EOR ('000000':X[127:70]);
Vtmp[127:64] = W[127:64] + sig1 + Y[127:64];
sig1 = ROR(X[63:0], 19) EOR ROR(X[63:0],61) EOR ('000000':X[63:6]);
Vtmp[63:0] = W[63:0] + sig1 + Y[63:0];
V[d] = Vtmp;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Va = V[a];
V[d] = Vn EOR Vm EOR Va;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
V[d] = Vn EOR (ROL(Vm[127:64],1):ROL(Vm[63:0], 1));



AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) tmp;
tmp = Vn EOR Vm; 
V[d] = ROR(tmp[127:64], UInt(imm6)):ROR(tmp[63:0], UInt(imm6));



AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Va = V[a];
V[d] = Vn EOR (Vm AND NOT(Va));



AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(128) Va = V[a];
Vd[127:96] = ROL((ROL(Vn[127:96],12) + Vm[127:96] + Va[127:96]) , 7);
Vd[95:0] = Zeros();
V[d] = Vd;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(32) WjPrime;
bits(128) result; 
bits(32) TT1;
bits(32) SS2;

WjPrime = Elem[Vm,i,32];
SS2 = Vn[127:96] EOR ROL(Vd[127:96],12); 
TT1 = Vd[63:32] EOR (Vd[127:96] EOR Vd[95:64]);
TT1 = (TT1 + Vd[31:0] + SS2 + WjPrime)[31:0];
result[31:0] = Vd[63:32];
result[63:32] = ROL(Vd[95:64],9); 
result[95:64] = Vd[127:96]; 
result[127:96] = TT1; 
V[d] = result;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(32) WjPrime;
bits(128) result; 
bits(32) TT1;
bits(32) SS2;

WjPrime = Elem[Vm,i,32];
SS2 = Vn[127:96] EOR ROL(Vd[127:96],12); 
TT1 = (Vd[127:96] AND Vd[63:32]) OR (Vd[127:96] AND Vd[95:64]) OR (Vd[63:32] AND Vd[95:64]); 
TT1 = (TT1 + Vd[31:0] + SS2 + WjPrime)[31:0];
result[31:0] = Vd[63:32];
result[63:32] = ROL(Vd[95:64],9); 
result[95:64] = Vd[127:96]; 
result[127:96] = TT1; 
V[d] = result;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(32) Wj;
bits(128) result; 
bits(32) TT2;

Wj = Elem[Vm,i,32];
TT2 = Vd[63:32] EOR (Vd[127:96] EOR Vd[95:64]);
TT2 = (TT2 + Vd[31:0] + Vn[127:96] + Wj)[31:0];

result[31:0] = Vd[63:32];
result[63:32] = ROL(Vd[95:64],19); 
result[95:64] = Vd[127:96]; 
result[127:96] = TT2 EOR ROL(TT2,9) EOR ROL(TT2,17); 
V[d] = result;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(32) Wj;
bits(128) result; 
bits(32) TT2;

Wj = Elem[Vm,i,32];
TT2 = (Vd[127:96] AND Vd[95:64]) OR (NOT(Vd[127:96]) AND Vd[63:32]); 
TT2 = (TT2 + Vd[31:0] + Vn[127:96] + Wj)[31:0];

result[31:0] = Vd[63:32];
result[63:32] = ROL(Vd[95:64],19); 
result[95:64] = Vd[127:96]; 
result[127:96] = TT2 EOR ROL(TT2,9) EOR ROL(TT2,17); 
V[d] = result;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(128) result; 

result[95:0] = (Vd EOR Vn)[95:0] EOR (ROL(Vm[127:96],15):ROL(Vm[95:64],15):ROL(Vm[63:32],15));

for i = 0 to 3
BEGIN
    if i == 3 then 
    BEGIN
        result[127:96] = (Vd EOR Vn)[127:96] EOR (ROL(result[31:0],15));
    END
    result[(32*i)+31:(32*i)] = result[(32*i)+31:(32*i)] EOR ROL(result[(32*i)+31:(32*i)],15) EOR ROL(result[(32*i)+31:(32*i)],23);
END
V[d] = result;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(128) result; 
bits(128) tmp;
bits(32) tmp2;
tmp[127:0] = Vn EOR (ROL(Vm[127:96],7):ROL(Vm[95:64],7):ROL(Vm[63:32],7):ROL(Vm[31:0],7)); 
result[127:0] = Vd[127:0] EOR tmp[127:0];
tmp2 = ROL(tmp[31:0],15);
tmp2 = tmp2 EOR ROL(tmp2,15) EOR ROL(tmp2,23);
result[127:96] = result[127:96] EOR tmp2;
V[d]= result;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vn = V[n];
bits(32) intval; 
bits(8) sboxout;
bits(128) roundresult;
bits(32) roundkey;

roundresult=V[d];
for index = 0 to 3
BEGIN
    roundkey = Elem[Vn,index,32];

    intval = roundresult[127:96] EOR roundresult[95:64] EOR roundresult[63:32] EOR roundkey; 

    for i = 0 to 3  
    BEGIN
        Elem[intval,i,8]  = Sbox(Elem[intval,i,8]); 

    END
    intval = intval EOR ROL(intval,2) EOR ROL(intval,10) EOR ROL(intval,18) EOR ROL(intval,24);
    intval = intval EOR roundresult[31:0]; 

    roundresult[31:0] = roundresult[63:32];
    roundresult[63:32] = roundresult[95:64];
    roundresult[95:64] = roundresult[127:96];
    roundresult[127:96] = intval; 
END
V[d] = roundresult;



AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(32) intval; 
bits(8) sboxout;
bits(128) result;
bits(32) const;
bits(128) roundresult;

roundresult = V[n];
for index = 0 to 3 
BEGIN
    const = Elem[Vm,index,32];

    intval = roundresult[127:96] EOR roundresult[95:64] EOR roundresult[63:32] EOR const; 

    for i = 0 to 3  
    BEGIN
        Elem[intval,i,8] = Sbox(Elem[intval,i,8]); 

    END
    intval = intval EOR ROL(intval,13) EOR ROL(intval,23);
    intval = intval EOR roundresult[31:0]; 

    roundresult[31:0] = roundresult[63:32];
    roundresult[63:32] = roundresult[95:64];
    roundresult[95:64] = roundresult[127:96];
    roundresult[127:96] = intval; 
END
V[d] = roundresult;



CheckFPAdvSIMDEnabled64();
bits(datasize DIV 2) operand1 = Vpart[n,part];
bits(datasize DIV 2) operand2 = Vpart[m,part];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize DIV 2) element1;
bits(esize DIV 2) element2;

for e = 0 to elements-1
BEGIN
    element1 = Elem[operand1, e, esize DIV 2];
    element2 = Elem[operand2, e, esize DIV 2];
    if sub_op then element1 = FPNeg(element1);
    Elem[result,e,esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR[]);
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize) element1;
bits(esize) element3;

for e = 0 to (elements DIV 2) -1 
BEGIN
    case rot of 
    BEGIN
        when '0'
        BEGIN
            element1 = FPNeg(Elem[operand2, e*2+1, esize]); 
            element3 = Elem[operand2, e*2, esize];
        END
        when '1'
        BEGIN
            element1 = Elem[operand2, e*2+1, esize]; 
            element3 = FPNeg(Elem[operand2, e*2, esize]);   
        END
    END
    Elem[result, e*2,   esize] = FPAdd(Elem[operand1, e*2, esize], element1, FPCR[]);
    Elem[result, e*2+1, esize] = FPAdd(Elem[operand1, e*2+1, esize], element3, FPCR[]);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
bits(esize) element3;
bits(esize) element4;
FPCRType fpcr = FPCR[];

for e = 0 to (elements DIV 2) -1
BEGIN
    case rot of
    BEGIN
        when '00'
        BEGIN
            element1 = Elem[operand2, e*2, esize];
            element2 = Elem[operand1, e*2, esize];
            element3 = Elem[operand2, e*2+1, esize];
            element4 = Elem[operand1, e*2, esize];
        END
        when '01'
        BEGIN
            element1 = FPNeg(Elem[operand2, e*2+1, esize]);
            element2 = Elem[operand1, e*2+1, esize];
            element3 = Elem[operand2, e*2, esize];
            element4 = Elem[operand1, e*2+1, esize];
        END
        when '10'
        BEGIN
            element1 = FPNeg(Elem[operand2, e*2, esize]);
            element2 = Elem[operand1, e*2, esize];
            element3 = FPNeg(Elem[operand2, e*2+1, esize]);
            element4 = Elem[operand1, e*2, esize];
        END
        when '11'
        BEGIN
            element1 = Elem[operand2, e*2+1, esize];
            element2 = Elem[operand1, e*2+1, esize];
            element3 = FPNeg(Elem[operand2, e*2, esize]);
            element4 = Elem[operand1, e*2+1, esize];

        END
    END
    Elem[result, e*2,   esize] = FPMulAdd(Elem[operand3, e*2, esize], element2, element1, fpcr);
    Elem[result, e*2+1, esize] = FPMulAdd(Elem[operand3, e*2+1, esize], element4, element3, fpcr);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;

for e = 0 to elements-1
BEGIN
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPRoundIntN(element, FPCR[], rounding, intsize);

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(128) operand1 = V[n];
bits(128) operand2 = V[m];
bits(128) addend   = V[d];

V[d] = MatMulAdd(addend, operand1, operand2, op1_unsigned, op2_unsigned);



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;

for e = 0 to elements-1
BEGIN
    bits(32) res = Elem[operand3, e, 32];
    for b = 0 to 3
    BEGIN
        integer element1 = UInt(Elem[operand1, 4 * e + b, 8]);
        integer element2 = SInt(Elem[operand2, 4 * e + b, 8]);
        res = res + element1 * element2;
    END
    Elem[result, e, 32] = res;

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(128)      operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;

for e = 0 to elements-1
BEGIN
    bits(32) res = Elem[operand3, e, 32];
    for b = 0 to 3
    BEGIN
        integer element1 = Int(Elem[operand1, 4 * e + b, 8], op1_unsigned);
        integer element2 = Int(Elem[operand2, 4 * i + b, 8], op2_unsigned);
        res = res + element1 * element2;
    END
    Elem[result, e, 32] = res;
END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand = Vpart[n, part];
bits(2*datasize) result;
integer element;

for e = 0 to elements-1
BEGIN
    element = Int(Elem[operand, e, esize], unsigned) << shift;
    Elem[result, e, 2*esize] = element[2*esize-1:0];

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(128) operand = V[n];
bits(64) result;

for e = 0 to elements-1
BEGIN
    Elem[result, e, 16] = FPConvertBF(Elem[operand, e, 32], FPCR[]);

END
Vpart[d, part] = result;



CheckFPAdvSIMDEnabled64();

bits(32) operand = V[n];
FPCRType fpcr    = FPCR[];
boolean merge    = IsMerging(fpcr);
bits(128) result = if merge then V[d] else Zeros();

Elem[result, 0, 16] = FPConvertBF(operand, fpcr);

V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;

for e = 0 to elements-1
BEGIN
    bits(16) elt1_a = Elem[operand1, 2 * e + 0, 16];
    bits(16) elt1_b = Elem[operand1, 2 * e + 1, 16];
    bits(16) elt2_a = Elem[operand2, 2 * e + 0, 16];
    bits(16) elt2_b = Elem[operand2, 2 * e + 1, 16];

    bits(32) sum = Elem[operand3, e, 32];
    sum = BFDotAdd(sum, elt1_a, elt1_b, elt2_a, elt2_b, FPCR[]);
    Elem[result, e, 32] = sum;

END
V[d] = result;



CheckFPAdvSIMDEnabled64();
bits(128) op1 = V[n];
bits(128) op2 = V[m];
bits(128) acc = V[d];

V[d] = BFMatMulAdd(acc, op1, op2);



CheckFPAdvSIMDEnabled64();
bits(128) operand1 = V[n];
bits(128) operand2 = V[m];
bits(128) operand3 = V[d];
bits(128) result;

for e = 0 to elements-1
BEGIN
    bits(32) element1 = Elem[operand1, 2 * e + sel, 16] : Zeros(16);
    bits(32) element2 = Elem[operand2, 2 * e + sel, 16] : Zeros(16);
    bits(32) addend   = Elem[operand3, e, 32];
    Elem[result, e, 32] = BFMulAdd(addend, element1, element2, FPCR[]);

END
V[d] = result;



