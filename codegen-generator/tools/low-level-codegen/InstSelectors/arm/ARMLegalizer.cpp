//============================== Hydride File =================================
//
// Part of the Hydride Compiler Infrastructure. 
// <Placeholder for license information> 
//
//=============================================================================
//
// Do NOT modify this file. It is automatically generated. 
//
//=============================================================================


#include "llvm/IR/Function.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/IR/Type.h"
#include "llvm/InitializePasses.h"
#include "llvm/Pass.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/Debug.h"
#include "llvm/Transforms/Scalar.h"
#include "Legalizer.h"
using namespace boost::multiprecision::literals;
namespace llvm {

class ARMLegalizationPass : public FunctionPass {
public:
    static char ID;

    ARMLegalizationPass() : FunctionPass(ID) {}

    bool runOnFunction(Function &F);

    void getAnalysisUsage(AnalysisUsage &AU) const {}
};

}
    
using namespace llvm;

class ARMLegalizer : public Legalizer {
public:

virtual bool legalize(Instruction *I) {
  auto *CI = dyn_cast<CallInst>(I);
  if (CI == nullptr) {
    return false;
  }
  if (InstToInstMap[CI] != nullptr) {
    return false;
  }
  
    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqmovn_s32_dsl",
"llvm.hydride.vqmovn_u16_dsl",
"llvm.hydride.vqmovn_s16_dsl",
"llvm.hydride.vqmovnd_s64_dsl",
"llvm.hydride.vqmovun_s32_dsl",
"llvm.hydride.vqmovun_s64_dsl",
"llvm.hydride.vqmovnd_u64_dsl",
"llvm.hydride.vqmovns_s32_dsl",
"llvm.hydride.vqmovund_s64_dsl",
"llvm.hydride.vqmovn_s64_dsl",
"llvm.hydride.vqmovnh_u16_dsl",
"llvm.hydride.vqmovnh_s16_dsl",
"llvm.hydride.vqmovun_s16_dsl",
"llvm.hydride.vqmovn_u32_dsl",
"llvm.hydride.vqmovns_u32_dsl",
"llvm.hydride.vqmovuns_s32_dsl",
"llvm.hydride.vqmovunh_s16_dsl",
"llvm.hydride.vqmovn_u64_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovn_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovn_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovn_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovn_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovn_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovn_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 32)
       && isAMatch(CI, 2, 32)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 32)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovnd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovnd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovun_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovun_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovun_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovun_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 32)
       && isAMatch(CI, 2, 32)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 32)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovnd_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovnd_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 16)
       && isAMatch(CI, 2, 16)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 16)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovns_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovns_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 32)
       && isAMatch(CI, 2, 32)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 32)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovund_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovund_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovn_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovn_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 8)
       && isAMatch(CI, 2, 8)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 8)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovnh_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovnh_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 8)
       && isAMatch(CI, 2, 8)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 8)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovnh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovnh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovun_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovun_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovn_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovn_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 16)
       && isAMatch(CI, 2, 16)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 16)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovns_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovns_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 16)
       && isAMatch(CI, 2, 16)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 16)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovuns_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovuns_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 8)
       && isAMatch(CI, 2, 8)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 8)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovunh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovunh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovn_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovn_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmull_s32_dsl",
"llvm.hydride.vqdmulls_s32_dsl",
"llvm.hydride.vqdmullh_s16_dsl",
"llvm.hydride.vqdmull_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmull_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmull_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 3, 32)
       && isAMatch(CI, 4, 32)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmulls_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmulls_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 3, 16)
       && isAMatch(CI, 4, 16)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmullh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmullh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmull_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmull_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmlsls_s32_dsl",
"llvm.hydride.vqdmlsl_s32_dsl",
"llvm.hydride.vqdmlsl_s16_dsl",
"llvm.hydride.vqdmlslh_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 32)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 2)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 64)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlsls_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlsls_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 2)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 64)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlsl_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlsl_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 2)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 32)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlsl_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlsl_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 16)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 2)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 32)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlslh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlslh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vcgtzq_s8_dsl",
"llvm.hydride.vcgtzd_s64_dsl",
"llvm.hydride.vcgtz_s32_dsl",
"llvm.hydride.vcgtzq_s32_dsl",
"llvm.hydride.vcgtzq_s64_dsl",
"llvm.hydride.vcgtzq_s16_dsl",
"llvm.hydride.vcgtz_s64_dsl",
"llvm.hydride.vcgtz_s8_dsl",
"llvm.hydride.vcgtz_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtzq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtzq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtzd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtzd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtz_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtz_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtzq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtzq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtzq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtzq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtzq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtzq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtz_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtz_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtz_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtz_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtz_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtz_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmlsl_u32_dsl",
"llvm.hydride.vmlsl_s8_dsl",
"llvm.hydride.vmlsl_u8_dsl",
"llvm.hydride.vmlsl_s16_dsl",
"llvm.hydride.vmlsl_u16_dsl",
"llvm.hydride.vmlsl_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vtrn1_u16_dsl",
"llvm.hydride.vtrn1_s32_dsl",
"llvm.hydride.vtrn1q_u16_dsl",
"llvm.hydride.vtrn1q_u64_dsl",
"llvm.hydride.vtrn1_s16_dsl",
"llvm.hydride.vtrn1_u8_dsl",
"llvm.hydride.vtrn1q_u8_dsl",
"llvm.hydride.vtrn1q_s32_dsl",
"llvm.hydride.vtrn1q_s16_dsl",
"llvm.hydride.vtrn1_s8_dsl",
"llvm.hydride.vtrn1q_s64_dsl",
"llvm.hydride.vtrn1q_u32_dsl",
"llvm.hydride.vtrn1q_s8_dsl",
"llvm.hydride.vtrn1_u32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 16)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn1_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn1_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 32)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn1_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn1_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 16)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn1q_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn1q_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 64)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn1q_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn1q_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 16)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn1_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn1_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 8)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn1_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn1_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 8)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn1q_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn1q_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 32)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn1q_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn1q_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 16)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn1q_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn1q_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 8)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn1_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn1_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 64)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn1q_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn1q_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 32)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn1q_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn1q_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 8)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn1q_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn1q_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 32)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn1_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn1_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vneg_s32_dsl",
"llvm.hydride.vnegd_s64_dsl",
"llvm.hydride.vneg_s64_dsl",
"llvm.hydride.vnegq_s32_dsl",
"llvm.hydride.vnegq_s8_dsl",
"llvm.hydride.vnegq_s64_dsl",
"llvm.hydride.vneg_s8_dsl",
"llvm.hydride.vneg_s16_dsl",
"llvm.hydride.vnegq_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vneg_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vneg_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vnegd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vnegd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vneg_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vneg_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vnegq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vnegq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vnegq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vnegq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vnegq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vnegq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vneg_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vneg_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vneg_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vneg_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vnegq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vnegq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vuqadd_s64_dsl",
"llvm.hydride.vuqaddb_s8_dsl",
"llvm.hydride.vuqaddd_s64_dsl",
"llvm.hydride.vuqaddq_s32_dsl",
"llvm.hydride.vsqadd_u8_dsl",
"llvm.hydride.vsqaddq_u16_dsl",
"llvm.hydride.vsqadd_u16_dsl",
"llvm.hydride.vsqaddd_u64_dsl",
"llvm.hydride.vsqaddq_u64_dsl",
"llvm.hydride.vsqaddb_u8_dsl",
"llvm.hydride.vuqaddh_s16_dsl",
"llvm.hydride.vsqaddq_u32_dsl",
"llvm.hydride.vuqadd_s32_dsl",
"llvm.hydride.vsqaddq_u8_dsl",
"llvm.hydride.vuqadd_s8_dsl",
"llvm.hydride.vsqadd_u32_dsl",
"llvm.hydride.vsqadd_u64_dsl",
"llvm.hydride.vsqaddh_u16_dsl",
"llvm.hydride.vuqaddq_s16_dsl",
"llvm.hydride.vuqadds_s32_dsl",
"llvm.hydride.vuqaddq_s64_dsl",
"llvm.hydride.vuqaddq_s8_dsl",
"llvm.hydride.vuqadd_s16_dsl",
"llvm.hydride.vsqadds_u32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vuqadd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuqadd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 8)
       && isAMatch(CI, 3, 8)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vuqaddb_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuqaddb_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vuqaddd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuqaddd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vuqaddq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuqaddq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsqadd_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsqadd_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsqaddq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsqaddq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsqadd_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsqadd_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsqaddd_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsqaddd_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsqaddq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsqaddq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 8)
       && isAMatch(CI, 3, 8)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsqaddb_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsqaddb_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 16)
       && isAMatch(CI, 3, 16)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vuqaddh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuqaddh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsqaddq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsqaddq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vuqadd_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuqadd_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsqaddq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsqaddq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vuqadd_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuqadd_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsqadd_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsqadd_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsqadd_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsqadd_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 16)
       && isAMatch(CI, 3, 16)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsqaddh_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsqaddh_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vuqaddq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuqaddq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 32)
       && isAMatch(CI, 3, 32)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vuqadds_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuqadds_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vuqaddq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuqaddq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vuqaddq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuqaddq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vuqadd_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuqadd_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 32)
       && isAMatch(CI, 3, 32)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsqadds_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsqadds_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmlsl_n_s16_dsl",
"llvm.hydride.vmlsl_n_u16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_n_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_n_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vorrq_u16_dsl",
"llvm.hydride.vorr_s64_dsl",
"llvm.hydride.vorr_s16_dsl",
"llvm.hydride.vorr_s8_dsl",
"llvm.hydride.vorr_s32_dsl",
"llvm.hydride.vorrq_s8_dsl",
"llvm.hydride.vorr_u8_dsl",
"llvm.hydride.vorr_u16_dsl",
"llvm.hydride.vorr_u32_dsl",
"llvm.hydride.vorrq_u32_dsl",
"llvm.hydride.vorr_u64_dsl",
"llvm.hydride.vorrq_u64_dsl",
"llvm.hydride.vorrq_s32_dsl",
"llvm.hydride.vorrq_s64_dsl",
"llvm.hydride.vorrq_u8_dsl",
"llvm.hydride.vorrq_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            { 
              auto *InstFunction = I->getModule()->getFunction("vorrq_u16_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorr_s64_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorr_s16_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorr_s8_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorr_s32_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorrq_s8_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorr_u8_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorr_u16_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorr_u32_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorrq_u32_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorr_u64_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorrq_u64_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorrq_s32_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorrq_s64_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorrq_u8_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorrq_s16_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vaddl_u8_dsl",
"llvm.hydride.vaddl_s32_dsl",
"llvm.hydride.vaddl_s16_dsl",
"llvm.hydride.vaddl_u16_dsl",
"llvm.hydride.vaddl_u32_dsl",
"llvm.hydride.vaddl_s8_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vaddl_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddl_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddl_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddl_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddl_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddl_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vaddl_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddl_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vaddl_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddl_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddl_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddl_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmull_high_n_u16_dsl",
"llvm.hydride.vmull_high_n_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_high_n_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_high_n_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_high_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_high_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vaddl_high_u16_dsl",
"llvm.hydride.vaddl_high_u32_dsl",
"llvm.hydride.vaddl_high_s8_dsl",
"llvm.hydride.vaddl_high_s32_dsl",
"llvm.hydride.vaddl_high_s16_dsl",
"llvm.hydride.vaddl_high_u8_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddl_high_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddl_high_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddl_high_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddl_high_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddl_high_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddl_high_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddl_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddl_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddl_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddl_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddl_high_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddl_high_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmlsl_high_n_u16_dsl",
"llvm.hydride.vmlsl_high_n_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 16)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_high_n_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_high_n_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 16)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_high_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_high_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqrdmlah_s32_dsl",
"llvm.hydride.vqrdmlah_s16_dsl",
"llvm.hydride.vqrdmlahq_s32_dsl",
"llvm.hydride.vqrdmlahq_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x20_cppi)
       && isAMatch(CI, 1, 0x2_cppi)
       && isAMatch(CI, 2, 0x80000000_cppi)
       && isAMatch(CI, 3, 0x20_cppi)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 64)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, -1)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmlah_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmlah_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x10_cppi)
       && isAMatch(CI, 1, 0x2_cppi)
       && isAMatch(CI, 2, 0x8000_cppi)
       && isAMatch(CI, 3, 0x10_cppi)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 64)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, -1)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmlah_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmlah_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x20_cppi)
       && isAMatch(CI, 1, 0x2_cppi)
       && isAMatch(CI, 2, 0x80000000_cppi)
       && isAMatch(CI, 3, 0x20_cppi)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 128)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 128)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, -1)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmlahq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmlahq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x10_cppi)
       && isAMatch(CI, 1, 0x2_cppi)
       && isAMatch(CI, 2, 0x8000_cppi)
       && isAMatch(CI, 3, 0x10_cppi)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 128)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 128)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, -1)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmlahq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmlahq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmlal_n_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 2)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 32)
       && isAMatch(CI, 18, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlal_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlal_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmovn_high_u32_dsl",
"llvm.hydride.vmovn_high_u16_dsl",
"llvm.hydride.vmovn_high_s32_dsl",
"llvm.hydride.vmovn_high_u64_dsl",
"llvm.hydride.vmovn_high_s16_dsl",
"llvm.hydride.vmovn_high_s64_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovn_high_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovn_high_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovn_high_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovn_high_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovn_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovn_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovn_high_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovn_high_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovn_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovn_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovn_high_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovn_high_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vaddw_s32_dsl",
"llvm.hydride.vaddw_s8_dsl",
"llvm.hydride.vaddw_s16_dsl",
"llvm.hydride.vaddw_u32_dsl",
"llvm.hydride.vaddw_u8_dsl",
"llvm.hydride.vaddw_u16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddw_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddw_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddw_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddw_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddw_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddw_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddw_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddw_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddw_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddw_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddw_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddw_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmlal_high_s16_dsl",
"llvm.hydride.vqdmlal_high_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 32)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 16)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlal_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlal_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 64)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 32)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlal_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlal_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vshl_u32_dsl",
"llvm.hydride.vshl_s32_dsl",
"llvm.hydride.vshlq_u32_dsl",
"llvm.hydride.vshlq_u16_dsl",
"llvm.hydride.vshl_u64_dsl",
"llvm.hydride.vshld_u64_dsl",
"llvm.hydride.vshl_s64_dsl",
"llvm.hydride.vshl_u16_dsl",
"llvm.hydride.vshlq_u64_dsl",
"llvm.hydride.vshlq_s16_dsl",
"llvm.hydride.vshl_s16_dsl",
"llvm.hydride.vshlq_s32_dsl",
"llvm.hydride.vshlq_s64_dsl",
"llvm.hydride.vshld_s64_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vshl_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshl_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vshl_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshl_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vshlq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshlq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vshlq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshlq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vshl_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshl_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vshld_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshld_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vshl_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshl_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vshl_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshl_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vshlq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshlq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vshlq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshlq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vshl_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshl_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vshlq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshlq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vshlq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshlq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vshld_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshld_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmlal_n_u32_dsl",
"llvm.hydride.vmlal_n_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_n_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_n_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vbicq_s32_dsl",
"llvm.hydride.vbicq_u64_dsl",
"llvm.hydride.vbicq_s16_dsl",
"llvm.hydride.vbicq_s64_dsl",
"llvm.hydride.vbicq_u8_dsl",
"llvm.hydride.vbic_u16_dsl",
"llvm.hydride.vbicq_u16_dsl",
"llvm.hydride.vbic_s16_dsl",
"llvm.hydride.vbicq_u32_dsl",
"llvm.hydride.vbic_s32_dsl",
"llvm.hydride.vbic_u8_dsl",
"llvm.hydride.vbic_u64_dsl",
"llvm.hydride.vbicq_s8_dsl",
"llvm.hydride.vbic_s64_dsl",
"llvm.hydride.vbic_s8_dsl",
"llvm.hydride.vbic_u32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            { 
              auto *InstFunction = I->getModule()->getFunction("vbicq_s32_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbicq_u64_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbicq_s16_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbicq_s64_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbicq_u8_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbic_u16_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbicq_u16_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbic_s16_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbicq_u32_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbic_s32_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbic_u8_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbic_u64_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbicq_s8_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbic_s64_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbic_s8_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbic_u32_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vceq_s16_dsl",
"llvm.hydride.vceq_u16_dsl",
"llvm.hydride.vceq_u8_dsl",
"llvm.hydride.vceqd_s64_dsl",
"llvm.hydride.vceq_u64_dsl",
"llvm.hydride.vceqq_u64_dsl",
"llvm.hydride.vceqq_u8_dsl",
"llvm.hydride.vceqq_u16_dsl",
"llvm.hydride.vceqq_s16_dsl",
"llvm.hydride.vceqq_s32_dsl",
"llvm.hydride.vceq_s8_dsl",
"llvm.hydride.vceqq_s8_dsl",
"llvm.hydride.vceq_u32_dsl",
"llvm.hydride.vceq_s64_dsl",
"llvm.hydride.vceqq_s64_dsl",
"llvm.hydride.vceq_s32_dsl",
"llvm.hydride.vceqd_u64_dsl",
"llvm.hydride.vceqq_u32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vceq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vceq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vceq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vceqd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vceq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vceqq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vceqq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vceqq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vceqq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vceqq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vceq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vceqq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vceq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vceq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vceqq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vceq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vceqd_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqd_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vceqq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,1,-1,0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vsubw_s8_dsl",
"llvm.hydride.vsubw_s16_dsl",
"llvm.hydride.vsubw_u8_dsl",
"llvm.hydride.vsubw_u32_dsl",
"llvm.hydride.vsubw_s32_dsl",
"llvm.hydride.vsubw_u16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubw_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubw_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubw_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubw_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubw_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubw_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubw_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubw_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubw_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubw_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubw_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubw_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vsubw_high_s32_dsl",
"llvm.hydride.vsubw_high_u32_dsl",
"llvm.hydride.vsubw_high_u8_dsl",
"llvm.hydride.vsubw_high_u16_dsl",
"llvm.hydride.vsubw_high_s8_dsl",
"llvm.hydride.vsubw_high_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubw_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubw_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vsubw_high_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubw_high_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vsubw_high_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubw_high_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vsubw_high_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubw_high_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubw_high_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubw_high_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubw_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubw_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqrshl_s16_dsl",
"llvm.hydride.vqrshld_u64_dsl",
"llvm.hydride.vqrshlh_u16_dsl",
"llvm.hydride.vqrshls_u32_dsl",
"llvm.hydride.vqrshlq_u16_dsl",
"llvm.hydride.vqrshlq_s32_dsl",
"llvm.hydride.vqrshlq_s64_dsl",
"llvm.hydride.vqrshlq_u32_dsl",
"llvm.hydride.vqrshls_s32_dsl",
"llvm.hydride.vqrshlq_s16_dsl",
"llvm.hydride.vqrshld_s64_dsl",
"llvm.hydride.vqrshl_u64_dsl",
"llvm.hydride.vqrshlq_u64_dsl",
"llvm.hydride.vqrshl_u16_dsl",
"llvm.hydride.vqrshl_u32_dsl",
"llvm.hydride.vqrshlh_s16_dsl",
"llvm.hydride.vqrshl_s64_dsl",
"llvm.hydride.vqrshl_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshl_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshl_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshld_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshld_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 16)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshlh_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshlh_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 32)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshls_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshls_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshlq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshlq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshlq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshlq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshlq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshlq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshlq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshlq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 32)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshls_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshls_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshlq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshlq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshld_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshld_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshl_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshl_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshlq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshlq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshl_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshl_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshl_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshl_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 16)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshlh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshlh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshl_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshl_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshl_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshl_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vtrn2q_s8_dsl",
"llvm.hydride.vtrn2_u16_dsl",
"llvm.hydride.vtrn2q_u16_dsl",
"llvm.hydride.vtrn2_s32_dsl",
"llvm.hydride.vtrn2q_s32_dsl",
"llvm.hydride.vtrn2q_u64_dsl",
"llvm.hydride.vtrn2q_s16_dsl",
"llvm.hydride.vtrn2_s8_dsl",
"llvm.hydride.vtrn2_u32_dsl",
"llvm.hydride.vtrn2q_u8_dsl",
"llvm.hydride.vtrn2q_s64_dsl",
"llvm.hydride.vtrn2_s16_dsl",
"llvm.hydride.vtrn2_u8_dsl",
"llvm.hydride.vtrn2q_u32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 4)
       && isAMatch(CI, 13, 2)
       && isAMatch(CI, 14, 8)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn2q_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn2q_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 8)
       && isAMatch(CI, 13, 2)
       && isAMatch(CI, 14, 16)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn2_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn2_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 8)
       && isAMatch(CI, 13, 2)
       && isAMatch(CI, 14, 16)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn2q_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn2q_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 16)
       && isAMatch(CI, 13, 2)
       && isAMatch(CI, 14, 32)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn2_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn2_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 16)
       && isAMatch(CI, 13, 2)
       && isAMatch(CI, 14, 32)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn2q_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn2q_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 64)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 32)
       && isAMatch(CI, 13, 2)
       && isAMatch(CI, 14, 64)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn2q_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn2q_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 8)
       && isAMatch(CI, 13, 2)
       && isAMatch(CI, 14, 16)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn2q_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn2q_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 4)
       && isAMatch(CI, 13, 2)
       && isAMatch(CI, 14, 8)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn2_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn2_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 16)
       && isAMatch(CI, 13, 2)
       && isAMatch(CI, 14, 32)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn2_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn2_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 4)
       && isAMatch(CI, 13, 2)
       && isAMatch(CI, 14, 8)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn2q_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn2q_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 64)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 32)
       && isAMatch(CI, 13, 2)
       && isAMatch(CI, 14, 64)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn2q_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn2q_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 8)
       && isAMatch(CI, 13, 2)
       && isAMatch(CI, 14, 16)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn2_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn2_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 4)
       && isAMatch(CI, 13, 2)
       && isAMatch(CI, 14, 8)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn2_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn2_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 16)
       && isAMatch(CI, 13, 2)
       && isAMatch(CI, 14, 32)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vtrn2q_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtrn2q_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmulq_s8_dsl",
"llvm.hydride.vmul_s32_dsl",
"llvm.hydride.vmul_s8_dsl",
"llvm.hydride.vmulq_u16_dsl",
"llvm.hydride.vmul_u32_dsl",
"llvm.hydride.vmul_u16_dsl",
"llvm.hydride.vmul_s16_dsl",
"llvm.hydride.vmulq_u8_dsl",
"llvm.hydride.vmul_u8_dsl",
"llvm.hydride.vmulq_s32_dsl",
"llvm.hydride.vmulq_s16_dsl",
"llvm.hydride.vmulq_u32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmulq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmulq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmul_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmul_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmul_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmul_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmulq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmulq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmul_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmul_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmul_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmul_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmul_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmul_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmulq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmulq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmul_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmul_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmulq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmulq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmulq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmulq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmulq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmulq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmulq_n_s32_dsl",
"llvm.hydride.vmul_n_s32_dsl",
"llvm.hydride.vmulq_n_u32_dsl",
"llvm.hydride.vmul_n_u32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmulq_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmulq_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmul_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmul_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmulq_n_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmulq_n_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmul_n_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmul_n_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmax_u16_dsl",
"llvm.hydride.vmaxq_u32_dsl",
"llvm.hydride.vmaxq_s16_dsl",
"llvm.hydride.vmaxq_s32_dsl",
"llvm.hydride.vmax_s32_dsl",
"llvm.hydride.vmax_s8_dsl",
"llvm.hydride.vmax_u8_dsl",
"llvm.hydride.vmax_s16_dsl",
"llvm.hydride.vmaxq_u16_dsl",
"llvm.hydride.vmax_u32_dsl",
"llvm.hydride.vmaxq_s8_dsl",
"llvm.hydride.vmaxq_u8_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmax_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmax_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmaxq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmaxq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmaxq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmaxq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmaxq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmaxq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmax_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmax_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmax_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmax_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmax_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmax_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmax_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmax_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmaxq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmaxq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmax_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmax_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmaxq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmaxq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmaxq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmaxq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vclt_s16_dsl",
"llvm.hydride.vcltq_u8_dsl",
"llvm.hydride.vclt_u16_dsl",
"llvm.hydride.vcltq_s8_dsl",
"llvm.hydride.vcltq_s32_dsl",
"llvm.hydride.vcltq_s16_dsl",
"llvm.hydride.vcltq_u16_dsl",
"llvm.hydride.vcltq_s64_dsl",
"llvm.hydride.vcltd_s64_dsl",
"llvm.hydride.vcltd_u64_dsl",
"llvm.hydride.vclt_s64_dsl",
"llvm.hydride.vclt_u8_dsl",
"llvm.hydride.vclt_u32_dsl",
"llvm.hydride.vclt_s32_dsl",
"llvm.hydride.vcltq_u32_dsl",
"llvm.hydride.vclt_u64_dsl",
"llvm.hydride.vclt_s8_dsl",
"llvm.hydride.vcltq_u64_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vclt_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vclt_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcltq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vclt_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vclt_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcltq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcltq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcltq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcltq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcltq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcltd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcltd_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltd_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vclt_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vclt_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vclt_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vclt_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vclt_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vclt_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vclt_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vclt_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcltq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vclt_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vclt_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vclt_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vclt_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcltq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmull_n_u32_dsl",
"llvm.hydride.vmull_n_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_n_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_n_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmull_n_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmull_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmull_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmlal_high_n_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 32)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 16)
       && isAMatch(CI, 18, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlal_high_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlal_high_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmlal_high_n_u32_dsl",
"llvm.hydride.vmlal_high_n_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 32)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_high_n_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_high_n_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 32)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_high_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_high_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vbcaxq_u8_dsl",
"llvm.hydride.vbcaxq_s32_dsl",
"llvm.hydride.vbcaxq_s64_dsl",
"llvm.hydride.vbcaxq_u32_dsl",
"llvm.hydride.vbcaxq_u64_dsl",
"llvm.hydride.vbcaxq_s16_dsl",
"llvm.hydride.vbcaxq_u16_dsl",
"llvm.hydride.vbcaxq_s8_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            { 
              auto *InstFunction = I->getModule()->getFunction("vbcaxq_u8_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbcaxq_s32_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbcaxq_s64_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbcaxq_u32_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbcaxq_u64_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbcaxq_s16_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbcaxq_u16_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbcaxq_s8_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vrax1q_u64_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)) {
              auto *InstFunction = I->getModule()->getFunction("vrax1q_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrax1q_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmlsq_n_u32_dsl",
"llvm.hydride.vmls_n_s32_dsl",
"llvm.hydride.vmlsq_n_s32_dsl",
"llvm.hydride.vmls_n_u32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsq_n_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsq_n_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmls_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmls_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsq_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsq_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmls_n_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmls_n_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmlal_u16_dsl",
"llvm.hydride.vmlal_s16_dsl",
"llvm.hydride.vmlal_s8_dsl",
"llvm.hydride.vmlal_u8_dsl",
"llvm.hydride.vmlal_s32_dsl",
"llvm.hydride.vmlal_u32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vhaddq_u16_dsl",
"llvm.hydride.vhadd_u8_dsl",
"llvm.hydride.vhadd_u16_dsl",
"llvm.hydride.vhaddq_u8_dsl",
"llvm.hydride.vhaddq_s16_dsl",
"llvm.hydride.vhaddq_s8_dsl",
"llvm.hydride.vhadd_u32_dsl",
"llvm.hydride.vhadd_s8_dsl",
"llvm.hydride.vhadd_s16_dsl",
"llvm.hydride.vhaddq_u32_dsl",
"llvm.hydride.vhadd_s32_dsl",
"llvm.hydride.vhaddq_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vhaddq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhaddq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vhadd_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhadd_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vhadd_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhadd_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vhaddq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhaddq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vhaddq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhaddq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vhaddq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhaddq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vhadd_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhadd_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vhadd_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhadd_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vhadd_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhadd_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vhaddq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhaddq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vhadd_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhadd_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vhaddq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhaddq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vceqz_s8_dsl",
"llvm.hydride.vceqzq_u16_dsl",
"llvm.hydride.vceqzq_u8_dsl",
"llvm.hydride.vceqz_u64_dsl",
"llvm.hydride.vceqzq_u64_dsl",
"llvm.hydride.vceqzq_s32_dsl",
"llvm.hydride.vceqzd_s64_dsl",
"llvm.hydride.vceqzq_s64_dsl",
"llvm.hydride.vceqzq_s8_dsl",
"llvm.hydride.vceqz_u8_dsl",
"llvm.hydride.vceqz_s16_dsl",
"llvm.hydride.vceqzd_u64_dsl",
"llvm.hydride.vceqz_s32_dsl",
"llvm.hydride.vceqzq_u32_dsl",
"llvm.hydride.vceqz_u16_dsl",
"llvm.hydride.vceqz_s64_dsl",
"llvm.hydride.vceqz_u32_dsl",
"llvm.hydride.vceqzq_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqz_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqz_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xffff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqzq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqzq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqzq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqzq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqz_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqz_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqzq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqzq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xffffffff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqzq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqzq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqzd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqzd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqzq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqzq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqzq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqzq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqz_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqz_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xffff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqz_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqz_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqzd_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqzd_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xffffffff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqz_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqz_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xffffffff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqzq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqzq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xffff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqz_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqz_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqz_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqz_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xffffffff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqz_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqz_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 0xffff_cppi)
       && isAMatch(CI, 3, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vceqzq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vceqzq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqsubq_u16_dsl",
"llvm.hydride.vqsub_s16_dsl",
"llvm.hydride.vqsub_u8_dsl",
"llvm.hydride.vqsubq_u32_dsl",
"llvm.hydride.vqsub_s8_dsl",
"llvm.hydride.vqsubd_u64_dsl",
"llvm.hydride.vqsub_u32_dsl",
"llvm.hydride.vqsubq_s16_dsl",
"llvm.hydride.vqsub_u16_dsl",
"llvm.hydride.vqsubb_s8_dsl",
"llvm.hydride.vqsub_s32_dsl",
"llvm.hydride.vqsubb_u8_dsl",
"llvm.hydride.vqsubq_s64_dsl",
"llvm.hydride.vqsubq_s8_dsl",
"llvm.hydride.vqsub_s64_dsl",
"llvm.hydride.vqsubq_u64_dsl",
"llvm.hydride.vqsubd_s64_dsl",
"llvm.hydride.vqsubs_s32_dsl",
"llvm.hydride.vqsub_u64_dsl",
"llvm.hydride.vqsubh_s16_dsl",
"llvm.hydride.vqsubq_u8_dsl",
"llvm.hydride.vqsubh_u16_dsl",
"llvm.hydride.vqsubq_s32_dsl",
"llvm.hydride.vqsubs_u32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqsubq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsubq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqsub_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsub_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqsub_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsub_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqsubq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsubq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqsub_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsub_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqsubd_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsubd_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqsub_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsub_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqsubq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsubq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqsub_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsub_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 8)
       && isAMatch(CI, 3, 8)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqsubb_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsubb_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqsub_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsub_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 8)
       && isAMatch(CI, 3, 8)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqsubb_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsubb_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqsubq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsubq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqsubq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsubq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqsub_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsub_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqsubq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsubq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqsubd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsubd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 32)
       && isAMatch(CI, 3, 32)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqsubs_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsubs_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqsub_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsub_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 16)
       && isAMatch(CI, 3, 16)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqsubh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsubh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqsubq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsubq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 16)
       && isAMatch(CI, 3, 16)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqsubh_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsubh_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqsubq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsubq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 32)
       && isAMatch(CI, 3, 32)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqsubs_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqsubs_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqshlq_u8_dsl",
"llvm.hydride.vqshl_u8_dsl",
"llvm.hydride.vqshlb_u8_dsl",
"llvm.hydride.vqshlq_s8_dsl",
"llvm.hydride.vqshl_s8_dsl",
"llvm.hydride.vqshlb_s8_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqshlq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshlq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqshl_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshl_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 8)
       && isAMatch(CI, 4, 8)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqshlb_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshlb_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqshlq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshlq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqshl_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshl_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 8)
       && isAMatch(CI, 4, 8)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqshlb_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshlb_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmovl_high_u8_dsl",
"llvm.hydride.vmovl_high_s8_dsl",
"llvm.hydride.vmovl_high_s32_dsl",
"llvm.hydride.vmovl_high_u16_dsl",
"llvm.hydride.vmovl_high_u32_dsl",
"llvm.hydride.vmovl_high_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovl_high_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovl_high_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovl_high_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovl_high_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovl_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovl_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovl_high_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovl_high_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovl_high_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovl_high_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovl_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovl_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmlsl_high_s16_dsl",
"llvm.hydride.vmlsl_high_u32_dsl",
"llvm.hydride.vmlsl_high_u8_dsl",
"llvm.hydride.vmlsl_high_u16_dsl",
"llvm.hydride.vmlsl_high_s32_dsl",
"llvm.hydride.vmlsl_high_s8_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_high_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_high_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_high_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_high_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_high_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_high_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_high_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_high_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vcle_u16_dsl",
"llvm.hydride.vcle_u64_dsl",
"llvm.hydride.vcleq_u32_dsl",
"llvm.hydride.vcleq_u16_dsl",
"llvm.hydride.vcle_s64_dsl",
"llvm.hydride.vcle_s32_dsl",
"llvm.hydride.vcle_u8_dsl",
"llvm.hydride.vcle_s8_dsl",
"llvm.hydride.vcleq_u64_dsl",
"llvm.hydride.vcleq_s8_dsl",
"llvm.hydride.vcle_u32_dsl",
"llvm.hydride.vcled_s64_dsl",
"llvm.hydride.vcleq_u8_dsl",
"llvm.hydride.vcled_u64_dsl",
"llvm.hydride.vcleq_s16_dsl",
"llvm.hydride.vcleq_s64_dsl",
"llvm.hydride.vcleq_s32_dsl",
"llvm.hydride.vcle_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffff_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcle_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcle_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcle_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcle_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffff_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcleq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcleq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffff_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcleq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcleq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcle_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcle_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffff_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcle_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcle_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xff_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcle_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcle_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xff_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcle_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcle_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcleq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcleq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xff_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcleq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcleq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffff_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcle_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcle_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcled_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcled_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xff_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcleq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcleq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcled_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcled_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffff_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcleq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcleq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcleq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcleq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffff_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcleq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcleq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffff_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcle_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcle_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vrshlq_s8_dsl",
"llvm.hydride.vrshl_s8_dsl",
"llvm.hydride.vrshl_u8_dsl",
"llvm.hydride.vrshlq_u8_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vrshlq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshlq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vrshl_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshl_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vrshl_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshl_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vrshlq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshlq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vandq_u16_dsl",
"llvm.hydride.vand_u16_dsl",
"llvm.hydride.vand_u32_dsl",
"llvm.hydride.vand_u64_dsl",
"llvm.hydride.vand_s64_dsl",
"llvm.hydride.vandq_s32_dsl",
"llvm.hydride.vand_u8_dsl",
"llvm.hydride.vandq_s16_dsl",
"llvm.hydride.vandq_u8_dsl",
"llvm.hydride.vandq_u32_dsl",
"llvm.hydride.vandq_u64_dsl",
"llvm.hydride.vand_s8_dsl",
"llvm.hydride.vandq_s8_dsl",
"llvm.hydride.vandq_s64_dsl",
"llvm.hydride.vand_s32_dsl",
"llvm.hydride.vand_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            { 
              auto *InstFunction = I->getModule()->getFunction("vandq_u16_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vand_u16_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vand_u32_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vand_u64_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vand_s64_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vandq_s32_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vand_u8_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vandq_s16_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vandq_u8_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vandq_u32_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vandq_u64_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vand_s8_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vandq_s8_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vandq_s64_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vand_s32_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vand_s16_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmull_high_u16_dsl",
"llvm.hydride.vmull_high_s8_dsl",
"llvm.hydride.vmull_high_s16_dsl",
"llvm.hydride.vmull_high_s32_dsl",
"llvm.hydride.vmull_high_u8_dsl",
"llvm.hydride.vmull_high_u32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_high_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_high_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_high_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_high_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_high_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_high_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_high_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_high_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqrdmlahs_s32_dsl",
"llvm.hydride.vqrdmlshq_s32_dsl",
"llvm.hydride.vqrdmlsh_s32_dsl",
"llvm.hydride.vqrdmlshq_s16_dsl",
"llvm.hydride.vqrdmlahh_s16_dsl",
"llvm.hydride.vqrdmlshh_s16_dsl",
"llvm.hydride.vqrdmlsh_s16_dsl",
"llvm.hydride.vqrdmlshs_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x20_cppi)
       && isAMatch(CI, 1, 0x2_cppi)
       && isAMatch(CI, 2, 0x80000000_cppi)
       && isAMatch(CI, 3, 0x20_cppi)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, -1)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmlahs_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmlahs_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x20_cppi)
       && isAMatch(CI, 1, 0x2_cppi)
       && isAMatch(CI, 2, 0x80000000_cppi)
       && isAMatch(CI, 3, 0x20_cppi)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 128)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 128)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, -1)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmlshq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmlshq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x20_cppi)
       && isAMatch(CI, 1, 0x2_cppi)
       && isAMatch(CI, 2, 0x80000000_cppi)
       && isAMatch(CI, 3, 0x20_cppi)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 64)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, -1)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmlsh_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmlsh_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x10_cppi)
       && isAMatch(CI, 1, 0x2_cppi)
       && isAMatch(CI, 2, 0x8000_cppi)
       && isAMatch(CI, 3, 0x10_cppi)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 128)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 128)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, -1)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmlshq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmlshq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x10_cppi)
       && isAMatch(CI, 1, 0x2_cppi)
       && isAMatch(CI, 2, 0x8000_cppi)
       && isAMatch(CI, 3, 0x10_cppi)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, -1)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmlahh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmlahh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x10_cppi)
       && isAMatch(CI, 1, 0x2_cppi)
       && isAMatch(CI, 2, 0x8000_cppi)
       && isAMatch(CI, 3, 0x10_cppi)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, -1)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmlshh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmlshh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x10_cppi)
       && isAMatch(CI, 1, 0x2_cppi)
       && isAMatch(CI, 2, 0x8000_cppi)
       && isAMatch(CI, 3, 0x10_cppi)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 64)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, -1)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmlsh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmlsh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x20_cppi)
       && isAMatch(CI, 1, 0x2_cppi)
       && isAMatch(CI, 2, 0x80000000_cppi)
       && isAMatch(CI, 3, 0x20_cppi)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, -1)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmlshs_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmlshs_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vsubl_s8_dsl",
"llvm.hydride.vsubl_u16_dsl",
"llvm.hydride.vsubl_s16_dsl",
"llvm.hydride.vsubl_u8_dsl",
"llvm.hydride.vsubl_u32_dsl",
"llvm.hydride.vsubl_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubl_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubl_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vsubl_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubl_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubl_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubl_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vsubl_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubl_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vsubl_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubl_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubl_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubl_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmlal_high_s8_dsl",
"llvm.hydride.vmlal_high_u8_dsl",
"llvm.hydride.vmlal_high_u32_dsl",
"llvm.hydride.vmlal_high_s16_dsl",
"llvm.hydride.vmlal_high_u16_dsl",
"llvm.hydride.vmlal_high_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_high_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_high_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_high_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_high_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_high_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_high_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_high_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_high_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmls_n_u16_dsl",
"llvm.hydride.vmls_n_s16_dsl",
"llvm.hydride.vmlsq_n_u16_dsl",
"llvm.hydride.vmlsq_n_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmls_n_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmls_n_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmls_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmls_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsq_n_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsq_n_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsq_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsq_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmlsl_high_n_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 64)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 32)
       && isAMatch(CI, 18, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlsl_high_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlsl_high_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vzip1_u16_dsl",
"llvm.hydride.vzip1q_s16_dsl",
"llvm.hydride.vzip1q_u32_dsl",
"llvm.hydride.vzip1_u8_dsl",
"llvm.hydride.vzip1_s32_dsl",
"llvm.hydride.vzip1q_s32_dsl",
"llvm.hydride.vzip1_s16_dsl",
"llvm.hydride.vzip1_u32_dsl",
"llvm.hydride.vzip1_s8_dsl",
"llvm.hydride.vzip1q_u16_dsl",
"llvm.hydride.vzip1q_s8_dsl",
"llvm.hydride.vzip1q_u8_dsl",
"llvm.hydride.vzip1q_s64_dsl",
"llvm.hydride.vzip1q_u64_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vzip1_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip1_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vzip1q_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip1q_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vzip1q_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip1q_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vzip1_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip1_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vzip1_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip1_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vzip1q_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip1q_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vzip1_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip1_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vzip1_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip1_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vzip1_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip1_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vzip1q_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip1q_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vzip1q_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip1q_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vzip1q_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip1q_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 64)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vzip1q_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip1q_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 64)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vzip1q_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip1q_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmlsl_high_n_s32_dsl",
"llvm.hydride.vmlsl_high_n_u32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 32)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_high_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_high_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 32)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_high_n_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_high_n_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vorn_s8_dsl",
"llvm.hydride.vorn_s32_dsl",
"llvm.hydride.vorn_u64_dsl",
"llvm.hydride.vornq_u16_dsl",
"llvm.hydride.vorn_s64_dsl",
"llvm.hydride.vornq_u32_dsl",
"llvm.hydride.vornq_s64_dsl",
"llvm.hydride.vorn_s16_dsl",
"llvm.hydride.vornq_u8_dsl",
"llvm.hydride.vornq_s8_dsl",
"llvm.hydride.vornq_s32_dsl",
"llvm.hydride.vorn_u32_dsl",
"llvm.hydride.vornq_s16_dsl",
"llvm.hydride.vorn_u16_dsl",
"llvm.hydride.vorn_u8_dsl",
"llvm.hydride.vornq_u64_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            { 
              auto *InstFunction = I->getModule()->getFunction("vorn_s8_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorn_s32_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorn_u64_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vornq_u16_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorn_s64_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vornq_u32_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vornq_s64_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorn_s16_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vornq_u8_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vornq_s8_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vornq_s32_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorn_u32_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vornq_s16_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorn_u16_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vorn_u8_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vornq_u64_wrapper"); 
              std::vector<int> Permutation = {0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.veorq_s16_dsl",
"llvm.hydride.veorq_u32_dsl",
"llvm.hydride.veor_u32_dsl",
"llvm.hydride.veorq_s64_dsl",
"llvm.hydride.veor_s32_dsl",
"llvm.hydride.veor_u64_dsl",
"llvm.hydride.veorq_s32_dsl",
"llvm.hydride.veor_u8_dsl",
"llvm.hydride.veorq_s8_dsl",
"llvm.hydride.veor_u16_dsl",
"llvm.hydride.veor_s16_dsl",
"llvm.hydride.veorq_u8_dsl",
"llvm.hydride.veor_s8_dsl",
"llvm.hydride.veorq_u64_dsl",
"llvm.hydride.veor_s64_dsl",
"llvm.hydride.veorq_u16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0xffffffffffffffffffffffffffffffff_cppi)) {
              auto *InstFunction = I->getModule()->getFunction("veorq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "veorq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffffffffffffffffffff_cppi)) {
              auto *InstFunction = I->getModule()->getFunction("veorq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "veorq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)) {
              auto *InstFunction = I->getModule()->getFunction("veor_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "veor_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffffffffffffffffffff_cppi)) {
              auto *InstFunction = I->getModule()->getFunction("veorq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "veorq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)) {
              auto *InstFunction = I->getModule()->getFunction("veor_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "veor_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)) {
              auto *InstFunction = I->getModule()->getFunction("veor_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "veor_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffffffffffffffffffff_cppi)) {
              auto *InstFunction = I->getModule()->getFunction("veorq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "veorq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)) {
              auto *InstFunction = I->getModule()->getFunction("veor_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "veor_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffffffffffffffffffff_cppi)) {
              auto *InstFunction = I->getModule()->getFunction("veorq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "veorq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)) {
              auto *InstFunction = I->getModule()->getFunction("veor_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "veor_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)) {
              auto *InstFunction = I->getModule()->getFunction("veor_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "veor_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffffffffffffffffffff_cppi)) {
              auto *InstFunction = I->getModule()->getFunction("veorq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "veorq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)) {
              auto *InstFunction = I->getModule()->getFunction("veor_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "veor_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffffffffffffffffffff_cppi)) {
              auto *InstFunction = I->getModule()->getFunction("veorq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "veorq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)) {
              auto *InstFunction = I->getModule()->getFunction("veor_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "veor_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffffffffffffffffffff_cppi)) {
              auto *InstFunction = I->getModule()->getFunction("veorq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "veorq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmla_n_s16_dsl",
"llvm.hydride.vmla_n_u16_dsl",
"llvm.hydride.vmlaq_n_s16_dsl",
"llvm.hydride.vmlaq_n_u16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmla_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmla_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmla_n_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmla_n_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlaq_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlaq_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlaq_n_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlaq_n_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vaddq_s16_dsl",
"llvm.hydride.vadd_s8_dsl",
"llvm.hydride.vadd_s16_dsl",
"llvm.hydride.vaddq_s64_dsl",
"llvm.hydride.vaddd_u64_dsl",
"llvm.hydride.vadd_u8_dsl",
"llvm.hydride.vaddq_u64_dsl",
"llvm.hydride.vaddd_s64_dsl",
"llvm.hydride.vaddq_s8_dsl",
"llvm.hydride.vaddq_u32_dsl",
"llvm.hydride.vaddq_u8_dsl",
"llvm.hydride.vadd_u64_dsl",
"llvm.hydride.vadd_s32_dsl",
"llvm.hydride.vadd_u32_dsl",
"llvm.hydride.vadd_s64_dsl",
"llvm.hydride.vadd_u16_dsl",
"llvm.hydride.vaddq_s32_dsl",
"llvm.hydride.vaddq_u16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vadd_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vadd_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vadd_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vadd_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddd_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddd_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vadd_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vadd_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vadd_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vadd_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vadd_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vadd_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vadd_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vadd_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vadd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vadd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vadd_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vadd_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmull_u32_dsl",
"llvm.hydride.vmull_u8_dsl",
"llvm.hydride.vmull_u16_dsl",
"llvm.hydride.vmull_s8_dsl",
"llvm.hydride.vmull_s16_dsl",
"llvm.hydride.vmull_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmovq_n_s16_dsl",
"llvm.hydride.vmov_n_s32_dsl",
"llvm.hydride.vmovq_n_u8_dsl",
"llvm.hydride.vdupq_n_u16_dsl",
"llvm.hydride.vdupq_n_u64_dsl",
"llvm.hydride.vdupq_n_u32_dsl",
"llvm.hydride.vdupq_n_s64_dsl",
"llvm.hydride.vmovq_n_u32_dsl",
"llvm.hydride.vdupq_n_s16_dsl",
"llvm.hydride.vdupq_n_u8_dsl",
"llvm.hydride.vmov_n_u16_dsl",
"llvm.hydride.vmovq_n_s64_dsl",
"llvm.hydride.vdupq_n_s8_dsl",
"llvm.hydride.vmov_n_u8_dsl",
"llvm.hydride.vmov_n_u32_dsl",
"llvm.hydride.vdup_n_u16_dsl",
"llvm.hydride.vdup_n_u8_dsl",
"llvm.hydride.vmovq_n_s32_dsl",
"llvm.hydride.vmovq_n_u16_dsl",
"llvm.hydride.vdup_n_u32_dsl",
"llvm.hydride.vmov_n_s16_dsl",
"llvm.hydride.vmov_n_s8_dsl",
"llvm.hydride.vmovq_n_s8_dsl",
"llvm.hydride.vmovq_n_u64_dsl",
"llvm.hydride.vdup_n_s8_dsl",
"llvm.hydride.vdup_n_s16_dsl",
"llvm.hydride.vdupq_n_s32_dsl",
"llvm.hydride.vdup_n_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vmovq_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovq_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vmov_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmov_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vmovq_n_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovq_n_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vdupq_n_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vdupq_n_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vdupq_n_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vdupq_n_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vdupq_n_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vdupq_n_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vdupq_n_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vdupq_n_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vmovq_n_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovq_n_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vdupq_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vdupq_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vdupq_n_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vdupq_n_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vmov_n_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmov_n_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vmovq_n_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovq_n_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vdupq_n_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vdupq_n_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vmov_n_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmov_n_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vmov_n_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmov_n_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vdup_n_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vdup_n_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vdup_n_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vdup_n_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vmovq_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovq_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vmovq_n_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovq_n_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vdup_n_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vdup_n_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vmov_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmov_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vmov_n_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmov_n_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vmovq_n_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovq_n_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vmovq_n_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovq_n_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vdup_n_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vdup_n_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vdup_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vdup_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vdupq_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vdupq_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vdup_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vdup_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqmovn_high_u64_dsl",
"llvm.hydride.vqmovn_high_u32_dsl",
"llvm.hydride.vqmovn_high_s64_dsl",
"llvm.hydride.vqmovn_high_u16_dsl",
"llvm.hydride.vqmovn_high_s16_dsl",
"llvm.hydride.vqmovun_high_s16_dsl",
"llvm.hydride.vqmovun_high_s32_dsl",
"llvm.hydride.vqmovun_high_s64_dsl",
"llvm.hydride.vqmovn_high_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovn_high_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovn_high_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovn_high_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovn_high_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovn_high_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovn_high_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovn_high_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovn_high_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovn_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovn_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovun_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovun_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovun_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovun_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovun_high_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovun_high_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqmovn_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqmovn_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vpmin_s8_dsl",
"llvm.hydride.vpmin_s16_dsl",
"llvm.hydride.vpmin_s32_dsl",
"llvm.hydride.vpmin_u16_dsl",
"llvm.hydride.vpminq_u32_dsl",
"llvm.hydride.vpminq_s32_dsl",
"llvm.hydride.vpminq_u16_dsl",
"llvm.hydride.vpmin_u8_dsl",
"llvm.hydride.vpminq_u8_dsl",
"llvm.hydride.vpminq_s16_dsl",
"llvm.hydride.vpmin_u32_dsl",
"llvm.hydride.vpminq_s8_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 8)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmin_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmin_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 16)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmin_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmin_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 16)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 32)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmin_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmin_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)
       && isAMatch(CI, 14, 0)
       && isAMatch(CI, 15, 16)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmin_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmin_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 16)
       && isAMatch(CI, 14, 0)
       && isAMatch(CI, 15, 32)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpminq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpminq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 16)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 32)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpminq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpminq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)
       && isAMatch(CI, 14, 0)
       && isAMatch(CI, 15, 16)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpminq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpminq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)
       && isAMatch(CI, 14, 0)
       && isAMatch(CI, 15, 8)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmin_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmin_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)
       && isAMatch(CI, 14, 0)
       && isAMatch(CI, 15, 8)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpminq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpminq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 16)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpminq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpminq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 16)
       && isAMatch(CI, 14, 0)
       && isAMatch(CI, 15, 32)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmin_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmin_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 8)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpminq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpminq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmla_n_u32_dsl",
"llvm.hydride.vmlaq_n_s32_dsl",
"llvm.hydride.vmla_n_s32_dsl",
"llvm.hydride.vmlaq_n_u32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmla_n_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmla_n_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlaq_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlaq_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmla_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmla_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlaq_n_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlaq_n_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmull_high_n_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmull_high_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmull_high_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmin_s32_dsl",
"llvm.hydride.vminq_s8_dsl",
"llvm.hydride.vminq_s32_dsl",
"llvm.hydride.vmin_u8_dsl",
"llvm.hydride.vmin_u16_dsl",
"llvm.hydride.vminq_u16_dsl",
"llvm.hydride.vmin_s8_dsl",
"llvm.hydride.vmin_u32_dsl",
"llvm.hydride.vmin_s16_dsl",
"llvm.hydride.vminq_u32_dsl",
"llvm.hydride.vminq_s16_dsl",
"llvm.hydride.vminq_u8_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmin_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmin_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vminq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vminq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vminq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vminq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmin_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmin_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmin_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmin_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vminq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vminq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmin_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmin_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmin_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmin_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmin_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmin_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vminq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vminq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vminq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vminq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vminq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vminq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vpaddq_s8_dsl",
"llvm.hydride.vpaddq_s16_dsl",
"llvm.hydride.vpadd_u16_dsl",
"llvm.hydride.vpaddq_s32_dsl",
"llvm.hydride.vpaddq_u64_dsl",
"llvm.hydride.vpaddq_s64_dsl",
"llvm.hydride.vpaddq_u16_dsl",
"llvm.hydride.vpadd_s32_dsl",
"llvm.hydride.vpaddq_u8_dsl",
"llvm.hydride.vpaddq_u32_dsl",
"llvm.hydride.vpadd_u32_dsl",
"llvm.hydride.vpadd_s8_dsl",
"llvm.hydride.vpadd_u8_dsl",
"llvm.hydride.vpadd_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 8)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 4)
       && isAMatch(CI, 11, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vpaddq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpaddq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 16)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vpaddq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpaddq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 16)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vpadd_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpadd_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 32)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vpaddq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpaddq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vpaddq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpaddq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vpaddq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpaddq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 16)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vpaddq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpaddq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 32)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vpadd_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpadd_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 8)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 4)
       && isAMatch(CI, 11, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vpaddq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpaddq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 32)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vpaddq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpaddq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 32)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vpadd_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpadd_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 8)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 4)
       && isAMatch(CI, 11, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vpadd_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpadd_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 8)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 4)
       && isAMatch(CI, 11, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vpadd_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpadd_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 16)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vpadd_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpadd_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmull_high_n_u32_dsl",
"llvm.hydride.vmull_high_n_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_high_n_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_high_n_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_high_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_high_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vcltz_s32_dsl",
"llvm.hydride.vcltzq_s16_dsl",
"llvm.hydride.vcltzq_s32_dsl",
"llvm.hydride.vcltzq_s64_dsl",
"llvm.hydride.vcltz_s16_dsl",
"llvm.hydride.vcltzq_s8_dsl",
"llvm.hydride.vcltz_s8_dsl",
"llvm.hydride.vcltzd_s64_dsl",
"llvm.hydride.vcltz_s64_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcltz_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltz_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcltzq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltzq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcltzq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltzq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcltzq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltzq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcltz_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltz_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcltzq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltzq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcltz_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltz_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcltzd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltzd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 1, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcltz_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcltz_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vaddhn_high_u64_dsl",
"llvm.hydride.vraddhn_high_s16_dsl",
"llvm.hydride.vaddhn_high_s64_dsl",
"llvm.hydride.vraddhn_high_s32_dsl",
"llvm.hydride.vraddhn_high_u64_dsl",
"llvm.hydride.vraddhn_high_u16_dsl",
"llvm.hydride.vaddhn_high_u16_dsl",
"llvm.hydride.vraddhn_high_u32_dsl",
"llvm.hydride.vaddhn_high_s16_dsl",
"llvm.hydride.vraddhn_high_s64_dsl",
"llvm.hydride.vaddhn_high_s32_dsl",
"llvm.hydride.vaddhn_high_u32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddhn_high_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddhn_high_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x80_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vraddhn_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vraddhn_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddhn_high_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddhn_high_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x8000_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vraddhn_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vraddhn_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x80000000_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vraddhn_high_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vraddhn_high_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x80_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vraddhn_high_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vraddhn_high_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddhn_high_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddhn_high_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x8000_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vraddhn_high_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vraddhn_high_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddhn_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddhn_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x80000000_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vraddhn_high_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vraddhn_high_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddhn_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddhn_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddhn_high_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddhn_high_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqrdmulhs_s32_dsl",
"llvm.hydride.vqrdmulhh_s16_dsl",
"llvm.hydride.vqdmulhq_s32_dsl",
"llvm.hydride.vqdmulhh_s16_dsl",
"llvm.hydride.vqrdmulhq_s32_dsl",
"llvm.hydride.vqrdmulh_s16_dsl",
"llvm.hydride.vqdmulh_s16_dsl",
"llvm.hydride.vqrdmulh_s32_dsl",
"llvm.hydride.vqdmulh_s32_dsl",
"llvm.hydride.vqrdmulhq_s16_dsl",
"llvm.hydride.vqdmulhs_s32_dsl",
"llvm.hydride.vqdmulhq_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x80000000_cppi)
       && isAMatch(CI, 2, 0x20_cppi)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmulhs_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmulhs_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x8000_cppi)
       && isAMatch(CI, 2, 0x10_cppi)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmulhh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmulhh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x20_cppi)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 128)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmulhq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmulhq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x10_cppi)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmulhh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmulhh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x80000000_cppi)
       && isAMatch(CI, 2, 0x20_cppi)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 128)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmulhq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmulhq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x8000_cppi)
       && isAMatch(CI, 2, 0x10_cppi)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmulh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmulh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x10_cppi)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmulh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmulh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x80000000_cppi)
       && isAMatch(CI, 2, 0x20_cppi)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmulh_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmulh_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x20_cppi)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmulh_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmulh_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x8000_cppi)
       && isAMatch(CI, 2, 0x10_cppi)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 128)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmulhq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmulhq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x20_cppi)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmulhs_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmulhs_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x10_cppi)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 128)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmulhq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmulhq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vzip2q_u64_dsl",
"llvm.hydride.vzip2q_s8_dsl",
"llvm.hydride.vzip2_u8_dsl",
"llvm.hydride.vzip2q_s64_dsl",
"llvm.hydride.vzip2q_u16_dsl",
"llvm.hydride.vzip2_u32_dsl",
"llvm.hydride.vzip2_s8_dsl",
"llvm.hydride.vzip2_s32_dsl",
"llvm.hydride.vzip2q_u8_dsl",
"llvm.hydride.vzip2q_s32_dsl",
"llvm.hydride.vzip2_s16_dsl",
"llvm.hydride.vzip2_u16_dsl",
"llvm.hydride.vzip2q_u32_dsl",
"llvm.hydride.vzip2q_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 64)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)
       && isAMatch(CI, 13, 64)
       && isAMatch(CI, 14, 64)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 64)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 32)
       && isAMatch(CI, 19, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vzip2q_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip2q_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 2)
       && isAMatch(CI, 13, 8)
       && isAMatch(CI, 14, 8)
       && isAMatch(CI, 15, 8)
       && isAMatch(CI, 16, 8)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 4)
       && isAMatch(CI, 19, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vzip2q_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip2q_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 4)
       && isAMatch(CI, 12, 2)
       && isAMatch(CI, 13, 8)
       && isAMatch(CI, 14, 8)
       && isAMatch(CI, 15, 4)
       && isAMatch(CI, 16, 8)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 4)
       && isAMatch(CI, 19, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vzip2_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip2_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 64)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)
       && isAMatch(CI, 13, 64)
       && isAMatch(CI, 14, 64)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 64)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 32)
       && isAMatch(CI, 19, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vzip2q_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip2q_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 4)
       && isAMatch(CI, 12, 2)
       && isAMatch(CI, 13, 16)
       && isAMatch(CI, 14, 16)
       && isAMatch(CI, 15, 4)
       && isAMatch(CI, 16, 16)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 8)
       && isAMatch(CI, 19, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vzip2q_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip2q_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)
       && isAMatch(CI, 13, 32)
       && isAMatch(CI, 14, 32)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 32)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 16)
       && isAMatch(CI, 19, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vzip2_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip2_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 4)
       && isAMatch(CI, 12, 2)
       && isAMatch(CI, 13, 8)
       && isAMatch(CI, 14, 8)
       && isAMatch(CI, 15, 4)
       && isAMatch(CI, 16, 8)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 4)
       && isAMatch(CI, 19, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vzip2_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip2_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)
       && isAMatch(CI, 13, 32)
       && isAMatch(CI, 14, 32)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 32)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 16)
       && isAMatch(CI, 19, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vzip2_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip2_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 2)
       && isAMatch(CI, 13, 8)
       && isAMatch(CI, 14, 8)
       && isAMatch(CI, 15, 8)
       && isAMatch(CI, 16, 8)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 4)
       && isAMatch(CI, 19, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vzip2q_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip2q_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 2)
       && isAMatch(CI, 13, 32)
       && isAMatch(CI, 14, 32)
       && isAMatch(CI, 15, 2)
       && isAMatch(CI, 16, 32)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 16)
       && isAMatch(CI, 19, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vzip2q_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip2q_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 2)
       && isAMatch(CI, 13, 16)
       && isAMatch(CI, 14, 16)
       && isAMatch(CI, 15, 2)
       && isAMatch(CI, 16, 16)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 8)
       && isAMatch(CI, 19, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vzip2_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip2_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 2)
       && isAMatch(CI, 13, 16)
       && isAMatch(CI, 14, 16)
       && isAMatch(CI, 15, 2)
       && isAMatch(CI, 16, 16)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 8)
       && isAMatch(CI, 19, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vzip2_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip2_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 2)
       && isAMatch(CI, 13, 32)
       && isAMatch(CI, 14, 32)
       && isAMatch(CI, 15, 2)
       && isAMatch(CI, 16, 32)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 16)
       && isAMatch(CI, 19, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vzip2q_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip2q_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 4)
       && isAMatch(CI, 12, 2)
       && isAMatch(CI, 13, 16)
       && isAMatch(CI, 14, 16)
       && isAMatch(CI, 15, 4)
       && isAMatch(CI, 16, 16)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 8)
       && isAMatch(CI, 19, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vzip2q_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vzip2q_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vrhaddq_s16_dsl",
"llvm.hydride.vrhaddq_s32_dsl",
"llvm.hydride.vrhaddq_u8_dsl",
"llvm.hydride.vrhaddq_u32_dsl",
"llvm.hydride.vrhadd_u8_dsl",
"llvm.hydride.vrhadd_s16_dsl",
"llvm.hydride.vrhadd_u32_dsl",
"llvm.hydride.vrhadd_u16_dsl",
"llvm.hydride.vrhadd_s32_dsl",
"llvm.hydride.vrhaddq_u16_dsl",
"llvm.hydride.vrhaddq_s8_dsl",
"llvm.hydride.vrhadd_s8_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vrhaddq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrhaddq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vrhaddq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrhaddq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vrhaddq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrhaddq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vrhaddq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrhaddq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vrhadd_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrhadd_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vrhadd_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrhadd_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vrhadd_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrhadd_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vrhadd_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrhadd_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vrhadd_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrhadd_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vrhaddq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrhaddq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vrhaddq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrhaddq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vrhadd_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrhadd_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmul_n_u16_dsl",
"llvm.hydride.vmul_n_s16_dsl",
"llvm.hydride.vmulq_n_s16_dsl",
"llvm.hydride.vmulq_n_u16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmul_n_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmul_n_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmul_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmul_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmulq_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmulq_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmulq_n_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmulq_n_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmulhq_n_s32_dsl",
"llvm.hydride.vqrdmulhq_n_s32_dsl",
"llvm.hydride.vqrdmulh_n_s32_dsl",
"llvm.hydride.vqdmulh_n_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x20_cppi)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 128)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmulhq_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmulhq_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x80000000_cppi)
       && isAMatch(CI, 2, 0x20_cppi)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 128)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmulhq_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmulhq_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x80000000_cppi)
       && isAMatch(CI, 2, 0x20_cppi)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmulh_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmulh_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x20_cppi)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmulh_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmulh_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmlsl_n_s32_dsl",
"llvm.hydride.vmlsl_n_u32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsl_n_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsl_n_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vshl_s8_dsl",
"llvm.hydride.vshlq_s8_dsl",
"llvm.hydride.vshlq_u8_dsl",
"llvm.hydride.vshl_u8_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vshl_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshl_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vshlq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshlq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vshlq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshlq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vshl_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vshl_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqneg_s64_dsl",
"llvm.hydride.vqneg_s8_dsl",
"llvm.hydride.vqnegq_s8_dsl",
"llvm.hydride.vqnegq_s64_dsl",
"llvm.hydride.vqnegb_s8_dsl",
"llvm.hydride.vqnegq_s32_dsl",
"llvm.hydride.vqnegs_s32_dsl",
"llvm.hydride.vqnegq_s16_dsl",
"llvm.hydride.vqneg_s32_dsl",
"llvm.hydride.vqnegh_s16_dsl",
"llvm.hydride.vqneg_s16_dsl",
"llvm.hydride.vqnegd_s64_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqneg_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqneg_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqneg_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqneg_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqnegq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqnegq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqnegq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqnegq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 8)
       && isAMatch(CI, 2, 8)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 8)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqnegb_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqnegb_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqnegq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqnegq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 32)
       && isAMatch(CI, 2, 32)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 32)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqnegs_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqnegs_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqnegq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqnegq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqneg_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqneg_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 16)
       && isAMatch(CI, 2, 16)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 16)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqnegh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqnegh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqneg_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqneg_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqnegd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqnegd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqshl_s64_dsl",
"llvm.hydride.vqshlq_s16_dsl",
"llvm.hydride.vqshlh_u16_dsl",
"llvm.hydride.vqshlq_u64_dsl",
"llvm.hydride.vqshl_s16_dsl",
"llvm.hydride.vqshl_s32_dsl",
"llvm.hydride.vqshl_u32_dsl",
"llvm.hydride.vqshld_s64_dsl",
"llvm.hydride.vqshld_u64_dsl",
"llvm.hydride.vqshlq_u16_dsl",
"llvm.hydride.vqshl_u16_dsl",
"llvm.hydride.vqshlq_s32_dsl",
"llvm.hydride.vqshlq_u32_dsl",
"llvm.hydride.vqshlq_s64_dsl",
"llvm.hydride.vqshls_u32_dsl",
"llvm.hydride.vqshl_u64_dsl",
"llvm.hydride.vqshlh_s16_dsl",
"llvm.hydride.vqshls_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vqshl_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshl_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqshlq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshlq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 16)
       && isAMatch(CI, 4, 16)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqshlh_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshlh_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vqshlq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshlq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqshl_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshl_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vqshl_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshl_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vqshl_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshl_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vqshld_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshld_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vqshld_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshld_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqshlq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshlq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqshl_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshl_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vqshlq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshlq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vqshlq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshlq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vqshlq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshlq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 32)
       && isAMatch(CI, 4, 32)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vqshls_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshls_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vqshl_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshl_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 16)
       && isAMatch(CI, 4, 16)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqshlh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshlh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 32)
       && isAMatch(CI, 4, 32)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vqshls_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqshls_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vaddw_high_u8_dsl",
"llvm.hydride.vaddw_high_u16_dsl",
"llvm.hydride.vaddw_high_s8_dsl",
"llvm.hydride.vaddw_high_u32_dsl",
"llvm.hydride.vaddw_high_s32_dsl",
"llvm.hydride.vaddw_high_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vaddw_high_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddw_high_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vaddw_high_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddw_high_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddw_high_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddw_high_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vaddw_high_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddw_high_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddw_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddw_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vaddw_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddw_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmlsl_high_n_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 32)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 16)
       && isAMatch(CI, 18, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlsl_high_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlsl_high_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmlsl_n_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 2)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 32)
       && isAMatch(CI, 18, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlsl_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlsl_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmlal_n_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 64)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 2)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 64)
       && isAMatch(CI, 18, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlal_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlal_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vuzp2_s32_dsl",
"llvm.hydride.vuzp2_u16_dsl",
"llvm.hydride.vuzp2_s16_dsl",
"llvm.hydride.vuzp2q_u32_dsl",
"llvm.hydride.vuzp2_s8_dsl",
"llvm.hydride.vuzp2q_s32_dsl",
"llvm.hydride.vuzp2q_u8_dsl",
"llvm.hydride.vuzp2q_s64_dsl",
"llvm.hydride.vuzp2_u32_dsl",
"llvm.hydride.vuzp2q_u64_dsl",
"llvm.hydride.vuzp2q_u16_dsl",
"llvm.hydride.vuzp2_u8_dsl",
"llvm.hydride.vuzp2q_s16_dsl",
"llvm.hydride.vuzp2q_s8_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp2_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp2_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp2_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp2_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp2_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp2_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp2q_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp2q_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp2_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp2_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp2q_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp2q_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp2q_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp2q_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp2q_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp2q_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp2_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp2_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp2q_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp2q_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp2q_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp2q_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp2_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp2_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp2q_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp2q_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp2q_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp2q_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vraddhn_u64_dsl",
"llvm.hydride.vaddhn_u32_dsl",
"llvm.hydride.vaddhn_u64_dsl",
"llvm.hydride.vraddhn_s64_dsl",
"llvm.hydride.vraddhn_u32_dsl",
"llvm.hydride.vaddhn_u16_dsl",
"llvm.hydride.vraddhn_s16_dsl",
"llvm.hydride.vaddhn_s32_dsl",
"llvm.hydride.vaddhn_s64_dsl",
"llvm.hydride.vraddhn_s32_dsl",
"llvm.hydride.vaddhn_s16_dsl",
"llvm.hydride.vraddhn_u16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x80000000_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 64)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vraddhn_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vraddhn_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddhn_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddhn_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 64)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddhn_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddhn_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x80000000_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 64)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vraddhn_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vraddhn_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x8000_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vraddhn_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vraddhn_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddhn_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddhn_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x80_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vraddhn_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vraddhn_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddhn_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddhn_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 64)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddhn_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddhn_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x8000_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vraddhn_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vraddhn_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vaddhn_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vaddhn_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x80_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vraddhn_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vraddhn_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmlal_high_n_s16_dsl",
"llvm.hydride.vmlal_high_n_u16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 16)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_high_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_high_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 16)
       && isAMatch(CI, 13, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_high_n_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_high_n_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vclezq_s64_dsl",
"llvm.hydride.vclezq_s8_dsl",
"llvm.hydride.vclezq_s16_dsl",
"llvm.hydride.vclezd_s64_dsl",
"llvm.hydride.vclezq_s32_dsl",
"llvm.hydride.vclez_s16_dsl",
"llvm.hydride.vclez_s8_dsl",
"llvm.hydride.vclez_s64_dsl",
"llvm.hydride.vclez_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vclezq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vclezq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vclezq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vclezq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vclezq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vclezq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vclezd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vclezd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vclezq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vclezq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vclez_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vclez_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vclez_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vclez_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vclez_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vclez_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vclez_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vclez_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmulh_n_s16_dsl",
"llvm.hydride.vqdmulhq_n_s16_dsl",
"llvm.hydride.vqrdmulh_n_s16_dsl",
"llvm.hydride.vqrdmulhq_n_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x10_cppi)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmulh_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmulh_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x10_cppi)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 128)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmulhq_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmulhq_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x8000_cppi)
       && isAMatch(CI, 2, 0x10_cppi)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmulh_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmulh_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 1, 0x8000_cppi)
       && isAMatch(CI, 2, 0x10_cppi)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 128)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrdmulhq_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrdmulhq_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmull_high_s32_dsl",
"llvm.hydride.vqdmull_high_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmull_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmull_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmull_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmull_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmls_s16_dsl",
"llvm.hydride.vmls_u32_dsl",
"llvm.hydride.vmlsq_u32_dsl",
"llvm.hydride.vmlsq_s32_dsl",
"llvm.hydride.vmlsq_u16_dsl",
"llvm.hydride.vmls_u16_dsl",
"llvm.hydride.vmlsq_s16_dsl",
"llvm.hydride.vmls_u8_dsl",
"llvm.hydride.vmls_s32_dsl",
"llvm.hydride.vmls_s8_dsl",
"llvm.hydride.vmlsq_u8_dsl",
"llvm.hydride.vmlsq_s8_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmls_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmls_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmls_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmls_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmls_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmls_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmls_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmls_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmls_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmls_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmls_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmls_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlsq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlsq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmla_u32_dsl",
"llvm.hydride.vmlaq_s16_dsl",
"llvm.hydride.vmla_s8_dsl",
"llvm.hydride.vmlaq_u8_dsl",
"llvm.hydride.vmlaq_u16_dsl",
"llvm.hydride.vmlaq_u32_dsl",
"llvm.hydride.vmla_s16_dsl",
"llvm.hydride.vmla_s32_dsl",
"llvm.hydride.vmla_u16_dsl",
"llvm.hydride.vmlaq_s8_dsl",
"llvm.hydride.vmla_u8_dsl",
"llvm.hydride.vmlaq_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmla_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmla_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlaq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlaq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmla_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmla_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlaq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlaq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlaq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlaq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlaq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlaq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmla_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmla_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmla_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmla_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmla_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmla_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlaq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlaq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmla_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmla_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlaq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlaq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmovl_s32_dsl",
"llvm.hydride.vmovl_u32_dsl",
"llvm.hydride.vmovl_s16_dsl",
"llvm.hydride.vmovl_s8_dsl",
"llvm.hydride.vmovl_u8_dsl",
"llvm.hydride.vmovl_u16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmovl_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovl_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmovl_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovl_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmovl_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovl_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmovl_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovl_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmovl_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovl_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmovl_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovl_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqaddq_u16_dsl",
"llvm.hydride.vqaddh_u16_dsl",
"llvm.hydride.vqaddq_u64_dsl",
"llvm.hydride.vqadd_s8_dsl",
"llvm.hydride.vqaddq_s32_dsl",
"llvm.hydride.vqaddd_s64_dsl",
"llvm.hydride.vqaddq_s64_dsl",
"llvm.hydride.vqaddh_s16_dsl",
"llvm.hydride.vqadds_s32_dsl",
"llvm.hydride.vqaddq_u8_dsl",
"llvm.hydride.vqadd_u32_dsl",
"llvm.hydride.vqaddb_s8_dsl",
"llvm.hydride.vqadd_s32_dsl",
"llvm.hydride.vqadd_s64_dsl",
"llvm.hydride.vqaddq_s8_dsl",
"llvm.hydride.vqadd_s16_dsl",
"llvm.hydride.vqaddq_u32_dsl",
"llvm.hydride.vqaddd_u64_dsl",
"llvm.hydride.vqadd_u16_dsl",
"llvm.hydride.vqadd_u64_dsl",
"llvm.hydride.vqadds_u32_dsl",
"llvm.hydride.vqadd_u8_dsl",
"llvm.hydride.vqaddb_u8_dsl",
"llvm.hydride.vqaddq_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqaddq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqaddq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 16)
       && isAMatch(CI, 3, 16)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqaddh_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqaddh_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqaddq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqaddq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqadd_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqadd_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqaddq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqaddq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqaddd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqaddd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqaddq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqaddq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 16)
       && isAMatch(CI, 3, 16)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqaddh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqaddh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 32)
       && isAMatch(CI, 3, 32)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqadds_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqadds_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqaddq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqaddq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqadd_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqadd_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 8)
       && isAMatch(CI, 3, 8)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqaddb_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqaddb_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqadd_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqadd_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqadd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqadd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqaddq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqaddq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqadd_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqadd_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqaddq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqaddq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqaddd_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqaddd_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqadd_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqadd_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqadd_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqadd_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 32)
       && isAMatch(CI, 3, 32)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqadds_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqadds_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqadd_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqadd_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 8)
       && isAMatch(CI, 3, 8)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vqaddb_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqaddb_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqaddq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqaddq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vpmax_s8_dsl",
"llvm.hydride.vpmax_u16_dsl",
"llvm.hydride.vpmax_u32_dsl",
"llvm.hydride.vpmaxq_s32_dsl",
"llvm.hydride.vpmax_s16_dsl",
"llvm.hydride.vpmax_u8_dsl",
"llvm.hydride.vpmax_s32_dsl",
"llvm.hydride.vpmaxq_u8_dsl",
"llvm.hydride.vpmaxq_s16_dsl",
"llvm.hydride.vpmaxq_u32_dsl",
"llvm.hydride.vpmaxq_s8_dsl",
"llvm.hydride.vpmaxq_u16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 8)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmax_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmax_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)
       && isAMatch(CI, 14, 0)
       && isAMatch(CI, 15, 16)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmax_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmax_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 16)
       && isAMatch(CI, 14, 0)
       && isAMatch(CI, 15, 32)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmax_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmax_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 16)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 32)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmaxq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmaxq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 16)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmax_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmax_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)
       && isAMatch(CI, 14, 0)
       && isAMatch(CI, 15, 8)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmax_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmax_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 16)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 32)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmax_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmax_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)
       && isAMatch(CI, 14, 0)
       && isAMatch(CI, 15, 8)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmaxq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmaxq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 16)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmaxq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmaxq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 16)
       && isAMatch(CI, 14, 0)
       && isAMatch(CI, 15, 32)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmaxq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmaxq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 8)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 4)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 8)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmaxq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmaxq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 8)
       && isAMatch(CI, 14, 0)
       && isAMatch(CI, 15, 16)
       && isAMatch(CI, 16, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vpmaxq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vpmaxq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmull_n_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 2)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmull_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmull_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vhsub_s16_dsl",
"llvm.hydride.vhsubq_u32_dsl",
"llvm.hydride.vhsub_s8_dsl",
"llvm.hydride.vhsub_u8_dsl",
"llvm.hydride.vhsubq_s8_dsl",
"llvm.hydride.vhsub_u32_dsl",
"llvm.hydride.vhsubq_s16_dsl",
"llvm.hydride.vhsub_s32_dsl",
"llvm.hydride.vhsub_u16_dsl",
"llvm.hydride.vhsubq_u8_dsl",
"llvm.hydride.vhsubq_u16_dsl",
"llvm.hydride.vhsubq_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vhsub_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhsub_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vhsubq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhsubq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vhsub_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhsub_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vhsub_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhsub_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vhsubq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhsubq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vhsub_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhsub_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vhsubq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhsubq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vhsub_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhsub_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vhsub_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhsub_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vhsubq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhsubq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vhsubq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhsubq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vhsubq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vhsubq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmvn_s32_dsl",
"llvm.hydride.vmvnq_s16_dsl",
"llvm.hydride.vmvn_u8_dsl",
"llvm.hydride.vmvnq_u8_dsl",
"llvm.hydride.vmvn_u32_dsl",
"llvm.hydride.vmvnq_u32_dsl",
"llvm.hydride.vmvn_s16_dsl",
"llvm.hydride.vmvnq_s32_dsl",
"llvm.hydride.vmvnq_s8_dsl",
"llvm.hydride.vmvn_u16_dsl",
"llvm.hydride.vmvn_s8_dsl",
"llvm.hydride.vmvnq_u16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vmvn_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmvn_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vmvnq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmvnq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vmvn_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmvn_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vmvnq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmvnq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vmvn_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmvn_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vmvnq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmvnq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vmvn_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmvn_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vmvnq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmvnq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vmvnq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmvnq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vmvn_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmvn_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vmvn_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmvn_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vmvnq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmvnq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqabss_s32_dsl",
"llvm.hydride.vqabsq_s64_dsl",
"llvm.hydride.vqabsq_s16_dsl",
"llvm.hydride.vqabsd_s64_dsl",
"llvm.hydride.vqabsh_s16_dsl",
"llvm.hydride.vqabs_s32_dsl",
"llvm.hydride.vqabsq_s32_dsl",
"llvm.hydride.vqabs_s8_dsl",
"llvm.hydride.vqabsb_s8_dsl",
"llvm.hydride.vqabsq_s8_dsl",
"llvm.hydride.vqabs_s16_dsl",
"llvm.hydride.vqabs_s64_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 1, 32)
       && isAMatch(CI, 2, 32)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 32)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqabss_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqabss_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqabsq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqabsq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqabsq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqabsq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqabsd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqabsd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 16)
       && isAMatch(CI, 2, 16)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 16)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqabsh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqabsh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqabs_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqabs_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqabsq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqabsq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqabs_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqabs_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 8)
       && isAMatch(CI, 2, 8)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 8)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqabsb_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqabsb_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqabsq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqabsq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqabs_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqabs_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 1)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqabs_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqabs_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vtstq_u16_dsl",
"llvm.hydride.vtst_u64_dsl",
"llvm.hydride.vtstq_u8_dsl",
"llvm.hydride.vtst_s64_dsl",
"llvm.hydride.vtst_u16_dsl",
"llvm.hydride.vtst_s32_dsl",
"llvm.hydride.vtstq_s32_dsl",
"llvm.hydride.vtst_u8_dsl",
"llvm.hydride.vtst_u32_dsl",
"llvm.hydride.vtst_s16_dsl",
"llvm.hydride.vtstq_s8_dsl",
"llvm.hydride.vtstd_u64_dsl",
"llvm.hydride.vtstq_u32_dsl",
"llvm.hydride.vtstq_s64_dsl",
"llvm.hydride.vtstd_s64_dsl",
"llvm.hydride.vtst_s8_dsl",
"llvm.hydride.vtstq_s16_dsl",
"llvm.hydride.vtstq_u64_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vtstq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtstq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vtst_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtst_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vtstq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtstq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vtst_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtst_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vtst_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtst_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vtst_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtst_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vtstq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtstq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vtst_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtst_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vtst_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtst_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vtst_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtst_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vtstq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtstq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vtstd_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtstd_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)) {
              auto *InstFunction = I->getModule()->getFunction("vtstq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtstq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vtstq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtstq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vtstd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtstd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vtst_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtst_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)) {
              auto *InstFunction = I->getModule()->getFunction("vtstq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtstq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)) {
              auto *InstFunction = I->getModule()->getFunction("vtstq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vtstq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmull_n_s16_dsl",
"llvm.hydride.vmull_n_u16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 1)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 2)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmull_n_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmull_n_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vsubl_high_u16_dsl",
"llvm.hydride.vsubl_high_s16_dsl",
"llvm.hydride.vsubl_high_s8_dsl",
"llvm.hydride.vsubl_high_u32_dsl",
"llvm.hydride.vsubl_high_u8_dsl",
"llvm.hydride.vsubl_high_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubl_high_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubl_high_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubl_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubl_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubl_high_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubl_high_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubl_high_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubl_high_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubl_high_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubl_high_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 0)
       && isAMatch(CI, 8, -1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubl_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubl_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vcgezq_s32_dsl",
"llvm.hydride.vcgezd_s64_dsl",
"llvm.hydride.vcgezq_s64_dsl",
"llvm.hydride.vcgezq_s8_dsl",
"llvm.hydride.vcgez_s64_dsl",
"llvm.hydride.vcgez_s8_dsl",
"llvm.hydride.vcgez_s16_dsl",
"llvm.hydride.vcgezq_s16_dsl",
"llvm.hydride.vcgez_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgezq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgezq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgezd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgezd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgezq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgezq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgezq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgezq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgez_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgez_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgez_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgez_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgez_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgez_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgezq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgezq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 2, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgez_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgez_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vsubq_s32_dsl",
"llvm.hydride.vsub_s8_dsl",
"llvm.hydride.vsubq_u8_dsl",
"llvm.hydride.vsubq_s64_dsl",
"llvm.hydride.vsub_u32_dsl",
"llvm.hydride.vsub_s64_dsl",
"llvm.hydride.vsubq_s16_dsl",
"llvm.hydride.vsub_u64_dsl",
"llvm.hydride.vsub_s32_dsl",
"llvm.hydride.vsubq_u32_dsl",
"llvm.hydride.vsub_u8_dsl",
"llvm.hydride.vsubd_u64_dsl",
"llvm.hydride.vsubd_s64_dsl",
"llvm.hydride.vsubq_u16_dsl",
"llvm.hydride.vsubq_u64_dsl",
"llvm.hydride.vsub_u16_dsl",
"llvm.hydride.vsubq_s8_dsl",
"llvm.hydride.vsub_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsub_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsub_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsub_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsub_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsub_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsub_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsub_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsub_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsub_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsub_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsub_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsub_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubd_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubd_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsub_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsub_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsub_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsub_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vcge_s32_dsl",
"llvm.hydride.vcged_s64_dsl",
"llvm.hydride.vcge_s64_dsl",
"llvm.hydride.vcge_u64_dsl",
"llvm.hydride.vcgeq_s16_dsl",
"llvm.hydride.vcgeq_u8_dsl",
"llvm.hydride.vcgeq_s64_dsl",
"llvm.hydride.vcgeq_s32_dsl",
"llvm.hydride.vcgeq_u64_dsl",
"llvm.hydride.vcgeq_u32_dsl",
"llvm.hydride.vcge_s16_dsl",
"llvm.hydride.vcged_u64_dsl",
"llvm.hydride.vcgeq_s8_dsl",
"llvm.hydride.vcgeq_u16_dsl",
"llvm.hydride.vcge_s8_dsl",
"llvm.hydride.vcge_u32_dsl",
"llvm.hydride.vcge_u8_dsl",
"llvm.hydride.vcge_u16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcge_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcge_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcged_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcged_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcge_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcge_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcge_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcge_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgeq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgeq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcgeq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgeq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgeq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgeq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgeq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgeq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcgeq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgeq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcgeq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgeq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcge_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcge_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcged_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcged_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgeq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgeq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcgeq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgeq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcge_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcge_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcge_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcge_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcge_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcge_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcge_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcge_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vsubhn_s64_dsl",
"llvm.hydride.vsubhn_u16_dsl",
"llvm.hydride.vsubhn_s32_dsl",
"llvm.hydride.vrsubhn_u16_dsl",
"llvm.hydride.vrsubhn_s16_dsl",
"llvm.hydride.vsubhn_s16_dsl",
"llvm.hydride.vrsubhn_s64_dsl",
"llvm.hydride.vrsubhn_u64_dsl",
"llvm.hydride.vrsubhn_u32_dsl",
"llvm.hydride.vsubhn_u32_dsl",
"llvm.hydride.vsubhn_u64_dsl",
"llvm.hydride.vrsubhn_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 64)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubhn_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubhn_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubhn_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubhn_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubhn_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubhn_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x80_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vrsubhn_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrsubhn_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x80_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vrsubhn_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrsubhn_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 16)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubhn_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubhn_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x80000000_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 64)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vrsubhn_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrsubhn_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x80000000_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 64)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vrsubhn_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrsubhn_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x8000_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vrsubhn_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrsubhn_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubhn_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubhn_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 64)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vsubhn_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubhn_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x8000_cppi)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, -1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vrsubhn_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrsubhn_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vabs_s64_dsl",
"llvm.hydride.vabs_s8_dsl",
"llvm.hydride.vabsq_s16_dsl",
"llvm.hydride.vabs_s16_dsl",
"llvm.hydride.vabsd_s64_dsl",
"llvm.hydride.vabsq_s32_dsl",
"llvm.hydride.vabsq_s8_dsl",
"llvm.hydride.vabs_s32_dsl",
"llvm.hydride.vabsq_s64_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vabs_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vabs_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vabs_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vabs_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vabsq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vabsq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vabs_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vabs_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vabsd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vabsd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vabsq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vabsq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vabsq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vabsq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vabs_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vabs_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 128)
       && isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vabsq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vabsq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vuzp1q_u8_dsl",
"llvm.hydride.vuzp1q_s32_dsl",
"llvm.hydride.vuzp1q_u32_dsl",
"llvm.hydride.vuzp1q_s64_dsl",
"llvm.hydride.vuzp1q_s8_dsl",
"llvm.hydride.vuzp1q_u16_dsl",
"llvm.hydride.vuzp1_u32_dsl",
"llvm.hydride.vuzp1_s16_dsl",
"llvm.hydride.vuzp1_u8_dsl",
"llvm.hydride.vuzp1_u16_dsl",
"llvm.hydride.vuzp1q_u64_dsl",
"llvm.hydride.vuzp1_s8_dsl",
"llvm.hydride.vuzp1_s32_dsl",
"llvm.hydride.vuzp1q_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp1q_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp1q_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp1q_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp1q_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp1q_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp1q_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp1q_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp1q_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp1q_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp1q_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp1q_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp1q_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp1_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp1_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp1_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp1_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp1_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp1_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp1_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp1_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp1q_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp1q_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 8)
       && isAMatch(CI, 7, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp1_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp1_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 32)
       && isAMatch(CI, 7, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp1_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp1_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 2, 128)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 0)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 16)
       && isAMatch(CI, 7, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vuzp1q_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vuzp1q_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmlsl_high_s32_dsl",
"llvm.hydride.vqdmlsl_high_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 64)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 32)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlsl_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlsl_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 32)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 16)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlsl_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlsl_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vbsl_s16_dsl",
"llvm.hydride.vbslq_s32_dsl",
"llvm.hydride.vbslq_s16_dsl",
"llvm.hydride.vbslq_u8_dsl",
"llvm.hydride.vbsl_u32_dsl",
"llvm.hydride.vbsl_u16_dsl",
"llvm.hydride.vbslq_u64_dsl",
"llvm.hydride.vbsl_s64_dsl",
"llvm.hydride.vbslq_s8_dsl",
"llvm.hydride.vbslq_s64_dsl",
"llvm.hydride.vbslq_u16_dsl",
"llvm.hydride.vbslq_u32_dsl",
"llvm.hydride.vbsl_u64_dsl",
"llvm.hydride.vbsl_u8_dsl",
"llvm.hydride.vbsl_s8_dsl",
"llvm.hydride.vbsl_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            { 
              auto *InstFunction = I->getModule()->getFunction("vbsl_s16_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbslq_s32_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbslq_s16_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbslq_u8_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbsl_u32_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbsl_u16_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbslq_u64_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbsl_s64_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbslq_s8_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbslq_s64_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbslq_u16_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbslq_u32_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbsl_u64_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbsl_u8_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbsl_s8_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("vbsl_s32_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmlal_n_u16_dsl",
"llvm.hydride.vmlal_n_s16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 0)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_n_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_n_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 3, 64)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 64)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vmlal_n_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmlal_n_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vrshlq_s64_dsl",
"llvm.hydride.vrshl_u64_dsl",
"llvm.hydride.vrshl_s16_dsl",
"llvm.hydride.vrshl_s64_dsl",
"llvm.hydride.vrshld_u64_dsl",
"llvm.hydride.vrshl_u16_dsl",
"llvm.hydride.vrshl_s32_dsl",
"llvm.hydride.vrshlq_u16_dsl",
"llvm.hydride.vrshl_u32_dsl",
"llvm.hydride.vrshlq_u64_dsl",
"llvm.hydride.vrshlq_s32_dsl",
"llvm.hydride.vrshlq_u32_dsl",
"llvm.hydride.vrshlq_s16_dsl",
"llvm.hydride.vrshld_s64_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vrshlq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshlq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vrshl_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshl_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vrshl_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshl_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vrshl_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshl_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vrshld_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshld_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vrshl_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshl_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vrshl_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshl_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vrshlq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshlq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vrshl_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshl_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vrshlq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshlq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vrshlq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshlq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 0)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 4)) {
              auto *InstFunction = I->getModule()->getFunction("vrshlq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshlq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vrshlq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshlq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, -1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 8)) {
              auto *InstFunction = I->getModule()->getFunction("vrshld_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrshld_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmlal_s16_dsl",
"llvm.hydride.vqdmlalh_s16_dsl",
"llvm.hydride.vqdmlal_s32_dsl",
"llvm.hydride.vqdmlals_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 2)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 32)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlal_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlal_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 16)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 16)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 2)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 32)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlalh_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlalh_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 2)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 64)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlal_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlal_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 32)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 32)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 64)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 2)
       && isAMatch(CI, 15, 1)
       && isAMatch(CI, 16, 64)
       && isAMatch(CI, 17, 1)
       && isAMatch(CI, 18, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlals_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlals_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vmovn_s16_dsl",
"llvm.hydride.vmovn_u32_dsl",
"llvm.hydride.vmovn_s64_dsl",
"llvm.hydride.vmovn_u64_dsl",
"llvm.hydride.vmovn_s32_dsl",
"llvm.hydride.vmovn_u16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovn_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovn_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovn_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovn_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovn_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovn_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 32)
       && isAMatch(CI, 6, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovn_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovn_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 16)
       && isAMatch(CI, 6, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovn_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovn_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 1, 64)
       && isAMatch(CI, 2, 64)
       && isAMatch(CI, 3, 0)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vmovn_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vmovn_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {0,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vcgtd_u64_dsl",
"llvm.hydride.vcgtq_s16_dsl",
"llvm.hydride.vcgtd_s64_dsl",
"llvm.hydride.vcgtq_u16_dsl",
"llvm.hydride.vcgt_s16_dsl",
"llvm.hydride.vcgtq_u8_dsl",
"llvm.hydride.vcgt_u8_dsl",
"llvm.hydride.vcgt_u32_dsl",
"llvm.hydride.vcgt_u64_dsl",
"llvm.hydride.vcgtq_s8_dsl",
"llvm.hydride.vcgtq_u32_dsl",
"llvm.hydride.vcgtq_u64_dsl",
"llvm.hydride.vcgtq_s32_dsl",
"llvm.hydride.vcgt_s8_dsl",
"llvm.hydride.vcgt_s32_dsl",
"llvm.hydride.vcgtq_s64_dsl",
"llvm.hydride.vcgt_s64_dsl",
"llvm.hydride.vcgt_u16_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtd_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtd_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtq_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtq_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtd_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtd_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtq_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtq_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgt_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgt_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcgt_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgt_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcgt_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgt_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcgt_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgt_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtq_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtq_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtq_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtq_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtq_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtq_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgt_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgt_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgt_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgt_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgtq_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgtq_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffffffffffffffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vcgt_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgt_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0xffff_cppi)
       && isAMatch(CI, 1, 0x0_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 0)
       && isAMatch(CI, 11, 0)) {
              auto *InstFunction = I->getModule()->getFunction("vcgt_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vcgt_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqrshl_u8_dsl",
"llvm.hydride.vqrshlq_u8_dsl",
"llvm.hydride.vqrshl_s8_dsl",
"llvm.hydride.vqrshlq_s8_dsl",
"llvm.hydride.vqrshlb_u8_dsl",
"llvm.hydride.vqrshlb_s8_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshl_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshl_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshlq_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshlq_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshl_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshl_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshlq_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshlq_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 8)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 0)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 0)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshlb_u8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshlb_u8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x1_cppi)
       && isAMatch(CI, 1, 0x1_cppi)
       && isAMatch(CI, 4, 8)
       && isAMatch(CI, 5, 8)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 8)
       && isAMatch(CI, 8, 8)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, -1)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqrshlb_s8_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqrshlb_s8_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmlal_high_n_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, -1)
       && isAMatch(CI, 12, 1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 64)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 32)
       && isAMatch(CI, 18, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlal_high_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlal_high_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmull_high_n_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 3, 128)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 0)
       && isAMatch(CI, 6, 128)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 1)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 1)
       && isAMatch(CI, 11, 32)
       && isAMatch(CI, 12, 2)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmull_high_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmull_high_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.veor3q_u16_dsl",
"llvm.hydride.veor3q_u8_dsl",
"llvm.hydride.veor3q_s16_dsl",
"llvm.hydride.veor3q_u32_dsl",
"llvm.hydride.veor3q_s32_dsl",
"llvm.hydride.veor3q_s64_dsl",
"llvm.hydride.veor3q_s8_dsl",
"llvm.hydride.veor3q_u64_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            { 
              auto *InstFunction = I->getModule()->getFunction("veor3q_u16_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("veor3q_u8_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("veor3q_s16_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("veor3q_u32_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("veor3q_s32_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("veor3q_s64_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("veor3q_s8_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
          
            { 
              auto *InstFunction = I->getModule()->getFunction("veor3q_u64_wrapper"); 
              std::vector<int> Permutation = {0,1,2}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true;
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vqdmlsl_n_s32_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x2_cppi)
       && isAMatch(CI, 4, 64)
       && isAMatch(CI, 5, 64)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 64)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 1)
       && isAMatch(CI, 10, 64)
       && isAMatch(CI, 11, 1)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, 1)
       && isAMatch(CI, 14, 1)
       && isAMatch(CI, 15, 2)
       && isAMatch(CI, 16, 1)
       && isAMatch(CI, 17, 64)
       && isAMatch(CI, 18, 1)) {
              auto *InstFunction = I->getModule()->getFunction("vqdmlsl_n_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vqdmlsl_n_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    

    {
      std::vector<std::string> InstNames = {"llvm.hydride.vrsubhn_high_u32_dsl",
"llvm.hydride.vsubhn_high_u32_dsl",
"llvm.hydride.vrsubhn_high_u16_dsl",
"llvm.hydride.vsubhn_high_s32_dsl",
"llvm.hydride.vrsubhn_high_u64_dsl",
"llvm.hydride.vsubhn_high_u16_dsl",
"llvm.hydride.vrsubhn_high_s16_dsl",
"llvm.hydride.vrsubhn_high_s32_dsl",
"llvm.hydride.vsubhn_high_s16_dsl",
"llvm.hydride.vsubhn_high_s64_dsl",
"llvm.hydride.vsubhn_high_u64_dsl",
"llvm.hydride.vrsubhn_high_s64_dsl"};
      if(isNameMatch(CI, InstNames)) { 
        
            if(isAMatch(CI, 0, 0x8000_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vrsubhn_high_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrsubhn_high_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubhn_high_u32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubhn_high_u32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x80_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vrsubhn_high_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrsubhn_high_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubhn_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubhn_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x80000000_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vrsubhn_high_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrsubhn_high_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubhn_high_u16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubhn_high_u16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x80_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vrsubhn_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrsubhn_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x8000_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 32)
       && isAMatch(CI, 9, 16)
       && isAMatch(CI, 10, 16)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vrsubhn_high_s32_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrsubhn_high_s32_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 16)
       && isAMatch(CI, 9, 8)
       && isAMatch(CI, 10, 8)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubhn_high_s16_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubhn_high_s16_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubhn_high_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubhn_high_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x0_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vsubhn_high_u64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vsubhn_high_u64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
          
            if(isAMatch(CI, 0, 0x80000000_cppi)
       && isAMatch(CI, 4, 128)
       && isAMatch(CI, 5, 128)
       && isAMatch(CI, 6, 0)
       && isAMatch(CI, 7, 128)
       && isAMatch(CI, 8, 64)
       && isAMatch(CI, 9, 32)
       && isAMatch(CI, 10, 32)
       && isAMatch(CI, 11, 2)
       && isAMatch(CI, 12, -1)
       && isAMatch(CI, 13, -1)) {
              auto *InstFunction = I->getModule()->getFunction("vrsubhn_high_s64_wrapper"); 
              errs() << "INST FUNCTION NAME: " << "vrsubhn_high_s64_wrapper" << "\n"; 
              std::vector<int> Permutation = {-1,0,1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
              std::vector<Value *> Args = getArgsAfterPermutation(CI, InstFunction, Permutation, CI); 
              if (Args.size() != 0) {
                auto *NewCallInst = CallInst::Create(InstFunction, Args, "", CI); 
                errs() << "NEW INSTUCTION:" << *NewCallInst << "\n"; 
                InstToInstMap[CI] = NewCallInst; 
                ToBeRemoved.insert(CI); 
                return true; 
              }
            } 
           
      } 
    }
    
  return false;
}
    

};


bool ARMLegalizationPass::runOnFunction(Function &F) {
  if (F.getName().contains("hydride") == false) {
    return false;
  }
  // Initialize the legalizer
  errs() << "LEGALIZATION BEGIN\n";
  Legalizer *L = new ARMLegalizer();
  return L->legalize(F);
}
    
    
char ARMLegalizationPass::ID = 0;
static RegisterPass<ARMLegalizationPass> X("ARM-hydride-legalize", 
                                          "Pass to legalize tensor intrinsics");
    