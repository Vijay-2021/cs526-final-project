module name=median3x3, target=x86-64-noos-avx-avx2-avx512-avx512_skylake-f16c-fma-no_asserts-no_bounds_query-sse41
external func median3x3_par_for_output_s0_y_y (__user_context, output.s0.y.y, closure_arg) {
let closure_prototype = (void *)make_struct((void *)reinterpret((uint64)0), (void *)reinterpret((uint64)0), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
let input = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 0)
let output = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 1)
let input.extent.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 2)
let input.min.0 = load_typed_struct_member((void *)closure_arg, closure_prototype, 3)
let input.min.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 4)
let input.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 5)
let output.extent.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 6)
let output.min.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 7)
let output.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 8)
let t650 = load_typed_struct_member((void *)closure_arg, closure_prototype, 9)
let t652 = load_typed_struct_member((void *)closure_arg, closure_prototype, 10)
let t653 = load_typed_struct_member((void *)closure_arg, closure_prototype, 11)
let t660 = load_typed_struct_member((void *)closure_arg, closure_prototype, 12)
let t661 = load_typed_struct_member((void *)closure_arg, closure_prototype, 13)
let t663 = load_typed_struct_member((void *)closure_arg, closure_prototype, 14)
let t664 = load_typed_struct_member((void *)closure_arg, closure_prototype, 15)
let t665 = load_typed_struct_member((void *)closure_arg, closure_prototype, 16)
let t666 = load_typed_struct_member((void *)closure_arg, closure_prototype, 17)
let t668 = load_typed_struct_member((void *)closure_arg, closure_prototype, 18)
let t669 = load_typed_struct_member((void *)closure_arg, closure_prototype, 19)
let t670 = load_typed_struct_member((void *)closure_arg, closure_prototype, 20)
let t671 = load_typed_struct_member((void *)closure_arg, closure_prototype, 21)
let t672 = load_typed_struct_member((void *)closure_arg, closure_prototype, 22)
let output.s0.y.yi.base.s = min(output.s0.y.y*34, output.extent.1 + -34)
let bounded_input.y.min_realized = let t755 = (output.min.1 + output.s0.y.yi.base.s) in min(max(min(t755 + 1, input.extent.1), 1), min(max(min(input.extent.1 + -1, t755), 0), max(min(t755, input.extent.1), 1) + -1))
let bounded_input.y.extent_realized = let t756 = (output.min.1 + min(output.s0.y.y*34, output.extent.1 + -34)) in (let t757 = ((output.s0.y.y*34) + output.min.1) in (let t758 = (output.extent.1 + output.min.1) in (max(min(t756 + 35, input.extent.1), 1) - min(max(min(t756 + 1, input.extent.1), 1), min(max(min(t757, min(t758, input.extent.1 + 33) + -34), 0), max(min(min(t758 + -34, input.extent.1), t757), 1) + -1)))))
allocate bounded_input[uint8 * (t650 + 34) * bounded_input.y.extent_realized] in Stack
let t683 = output.s0.y.y*34
let t684 = min(output.extent.1 + -34, t683)
let t685 = output.extent.1 + output.min.1
let t680 = min(t685 + -34, input.extent.1)
let t679 = min(input.extent.1 + 33, t685)
let t681 = ((t669 + 1)/32)*32
let t678 = output.min.1 + t683
let t673 = output.min.1 + output.s0.y.yi.base.s
for (output.s0.y.yi.yi, 0, 2) {
 let bounded_input.s0.y.min_2 = let t759 = ((output.s0.y.yi.yi*17) + t673) in select(0 < output.s0.y.yi.yi, max(min(t759 + 1, input.extent.1), 1), min(max(min(input.extent.1 + -1, t759), 0), max(min(t759, input.extent.1), 1) + -1))
 produce bounded_input {
  let t693 = output.min.1 + t684
  let t694 = output.s0.y.yi.yi*17
  let t695 = 0 < output.s0.y.yi.yi
  let t696 = t693 + t694
  let t686 = max(min(t696 + 18, input.extent.1), 1) - select(t695, max(min(t696 + 1, input.extent.1), 1), min(max(min(input.extent.1 + -1, t696), 0), max(min(input.extent.1, t696), 1) + -1))
  let t692 = t671 - t652
  let t689 = bounded_input.s0.y.min_2 - input.min.1
  for (bounded_input.s0.y.rebased, 0, t686) {
   let t699 = min(max(min(t693 + 1, input.extent.1), 1), min(max(min(input.extent.1 + -1, t693), 0), max(min(input.extent.1, t693), 1) + -1))
   let t698 = ((bounded_input.s0.y.rebased + t689)*input.stride.1) - input.min.0
   let t697 = t693 + t694
   for (bounded_input.s0.x.x, 0, t672) {
    let bounded_input.s0.x.xi.base.s = min((bounded_input.s0.x.x*32) + t653, t665 + 2)
    bounded_input[ramp(((((select(t695, max(min(t697 + 1, input.extent.1), 1), min(max(min(input.extent.1 + -1, t697), 0), max(min(input.extent.1, t697), 1) + -1)) - t699) + bounded_input.s0.y.rebased)*(t650 + 34)) - t653) + bounded_input.s0.x.xi.base.s, 1, 32)] = input[max(min(ramp(bounded_input.s0.x.xi.base.s + -33, 1, 32), x32(t664 + -1)), x32(input.min.0)) + x32(t698)]
   }
   let t703 = min(max(min(t693 + 1, input.extent.1), 1), min(max(min(input.extent.1 + -1, t693), 0), max(min(input.extent.1, t693), 1) + -1))
   let t702 = ((bounded_input.s0.y.rebased + t689)*input.stride.1) - input.min.0
   let t700 = t652 - t672
   let t701 = t693 + t694
   for (bounded_input.s0.x.x.rebased, 0, t700) {
    let bounded_input.s0.x.xi.base.s = ((bounded_input.s0.x.x.rebased + t672)*32) + t653
    bounded_input[ramp(((((select(t695, max(min(t701 + 1, input.extent.1), 1), min(max(min(input.extent.1 + -1, t701), 0), max(min(input.extent.1, t701), 1) + -1)) - t703) + bounded_input.s0.y.rebased)*(t650 + 34)) - t653) + bounded_input.s0.x.xi.base.s, 1, 32)] = input[ramp((bounded_input.s0.x.xi.base.s + t702) + -33, 1, 32)]
   }
   let t706 = min(max(min(t693 + 1, input.extent.1), 1), min(max(min(input.extent.1 + -1, t693), 0), max(min(input.extent.1, t693), 1) + -1))
   let t705 = ((bounded_input.s0.y.rebased + t689)*input.stride.1) - input.min.0
   let t704 = t693 + t694
   for (bounded_input.s0.x.x.rebased, 0, t692) {
    let bounded_input.s0.x.xi.base.s = min(((bounded_input.s0.x.x.rebased + t652)*32) + t653, t665 + 2)
    bounded_input[ramp(((((select(t695, max(min(t704 + 1, input.extent.1), 1), min(max(min(input.extent.1 + -1, t704), 0), max(min(input.extent.1, t704), 1) + -1)) - t706) + bounded_input.s0.y.rebased)*(t650 + 34)) - t653) + bounded_input.s0.x.xi.base.s, 1, 32)] = input[max(min(ramp(bounded_input.s0.x.xi.base.s + -33, 1, 32), x32(t664 + -1)), x32(input.min.0)) + x32(t705)]
   }
  }
 }
 allocate max_y[uint8 * (t670 + 32) * 17] in Stack
 produce max_y {
  consume bounded_input {
   let t709 = output.min.1 + t684
   let t707 = min(max(min(t709 + 1, input.extent.1), 1), min(max(min(input.extent.1 + -1, t709), 0), max(min(input.extent.1, t709), 1) + -1))
   let t708 = (output.s0.y.yi.yi*17) + t709
   for (max_y.s0.y.rebased, 0, 17) {
    let t711 = (t670 + 32)*max_y.s0.y.rebased
    let t710 = max_y.s0.y.rebased + t708
    for (max_y.s0.x.x, 0, t671) {
     let max_y.s0.x.xi.base.s = (max_y.s0.x.x*32) + t653
     let t559 = max_y.s0.x.xi.base.s - t653
     max_y[ramp(t559 + t711, 1, 32)] = max(bounded_input[ramp(((((max(min(input.extent.1, t710), 1) - t707)*(t650 + 34)) - t650) + t559) + -34, 1, 32)], max(bounded_input[ramp(((max(min(input.extent.1 + -1, t710), 0) - t707)*(t650 + 34)) + t559, 1, 32)], bounded_input[ramp(((((max(min(t710 + 2, input.extent.1), 1) - t707)*(t650 + 34)) - t650) + t559) + -34, 1, 32)]))
    }
   }
  }
 }
 consume max_y {
  consume bounded_input {
   let t717 = output.min.1 + t684
   let t718 = max(min(t717 + 1, input.extent.1), 1)
   let t715 = min(min(max(min(t679 + -34, t678), 0), max(min(t678, t680), 1) + -1), t718)
   let t713 = min(min(max(min(input.extent.1 + -1, t717), 0), max(min(input.extent.1, t717), 1) + -1), t718)
   let t712 = output.s0.y.yi.yi*17
   for (output.s0.y.yi.yii.yii, 0, 9) {
    let output.s0.y.min_3.s = min(output.s0.y.yi.yii.yii*2, 15) + t712
    allocate min_y[uint8 * (t670 + 32) * 2] in Stack
    produce min_y {
     let t719 = output.s0.y.min_3.s + t717
     for (min_y.s0.y.rebased, 0, 2) {
      let t721 = (t670 + 32)*min_y.s0.y.rebased
      let t720 = min_y.s0.y.rebased + t719
      for (min_y.s0.x.x, 0, t671) {
       let min_y.s0.x.xi.base.s = (min_y.s0.x.x*32) + t653
       let t564 = min_y.s0.x.xi.base.s - t653
       min_y[ramp(t564 + t721, 1, 32)] = min(bounded_input[ramp(((((max(min(input.extent.1, t720), 1) - t713)*(t650 + 34)) - t650) + t564) + -34, 1, 32)], min(bounded_input[ramp(((max(min(input.extent.1 + -1, t720), 0) - t713)*(t650 + 34)) + t564, 1, 32)], bounded_input[ramp(((((max(min(t720 + 2, input.extent.1), 1) - t713)*(t650 + 34)) - t650) + t564) + -34, 1, 32)]))
      }
     }
    }
    consume min_y {
     let t725 = min(output.s0.y.yi.yii.yii*2, 15)
     let t722 = t712 + t725
     for (output.s0.y.yi.yii.yiii, 0, 2) {
      let output.s0.y.yi = output.s0.y.yi.yii.yiii + t722
      let t735 = output.s0.y.yi + t673
      let t736 = t670 + 32
      let t737 = output.s0.y.yi + t717
      let t738 = t650 + 34
      let t739 = input.extent.1 + -1
      let t731 = (max(min(t735 + 2, input.extent.1), 1) - bounded_input.y.min_realized)*t738
      let t729 = (max(min(t737, t739), 0) - t715)*t738
      let t733 = (max(min(t735, t739), 0) - bounded_input.y.min_realized)*t738
      let t732 = (max(min(input.extent.1, t735), 1) - bounded_input.y.min_realized)*t738
      let t727 = output.s0.y.yi.yii.yiii*t736
      let t730 = ((max(min(t737 + 2, input.extent.1), 1) - t715)*t738) - t650
      let t728 = ((max(min(input.extent.1, t737), 1) - t715)*t738) - t650
      let t726 = ((output.s0.y.yi.yii.yiii + t725)*t736) - t666
      let t734 = (output.stride.1*t735) + t660
      for (output.s0.x.x, 0, t668) {
       allocate minmax_x[uint8 * 32] in Stack
       produce minmax_x {
        let t565 = (output.s0.x.x*32) + t726
        minmax_x[ramp(0, 1, 32)] = min(max_y[ramp(t565 + 32, 1, 32)], min(max_y[ramp(t565 + 33, 1, 32)], max_y[ramp(t565 + 34, 1, 32)]))
       }
       consume minmax_x {
        let t566 = minmax_x[ramp(0, 1, 32)]
        let t567 = (output.s0.x.x*32) - t666
        let t569 = let t760 = (t567 + t727) in max(min_y[ramp(t760 + 32, 1, 32)], max(min_y[ramp(t760 + 33, 1, 32)], min_y[ramp(t760 + 34, 1, 32)]))
        let t575 = bounded_input[ramp((t567 + t728) + -2, 1, 32)]
        let t576 = bounded_input[ramp((t567 + t729) + 32, 1, 32)]
        let t577 = max(min(bounded_input[ramp((t567 + t730) + -2, 1, 32)], max(t575, t576)), min(t575, t576))
        let t581 = bounded_input[ramp(((t732 - t650) + t567) + -1, 1, 32)]
        let t583 = bounded_input[ramp((t567 + t733) + 33, 1, 32)]
        let t584 = max(min(bounded_input[ramp(((t731 - t650) + t567) + -1, 1, 32)], max(t581, t583)), min(t581, t583))
        let t585 = bounded_input[ramp((t732 - t650) + t567, 1, 32)]
        let t586 = bounded_input[ramp((t567 + t733) + 34, 1, 32)]
        output[ramp((output.s0.x.x*32) + t734, 1, 32)] = max(min(max(t566, t569), max(min(max(t577, t584), max(min(bounded_input[ramp((t731 - t650) + t567, 1, 32)], max(t585, t586)), min(t585, t586))), min(t577, t584))), min(t566, t569))
       }
       free minmax_x
      }
      let t749 = output.s0.y.yi + t673
      let t750 = t681 + 32
      let t751 = t650 + 34
      let t752 = input.extent.1 + -1
      let t753 = output.s0.y.yi + t717
      let t754 = t669 - t650
      let t744 = ((max(min(t753 + 2, input.extent.1), 1) - t715)*t751) + t754
      let t745 = ((max(min(t749 + 2, input.extent.1), 1) - bounded_input.y.min_realized)*t751) + t669
      let t743 = ((max(min(t752, t753), 0) - t715)*t751) + t669
      let t742 = ((max(min(input.extent.1, t753), 1) - t715)*t751) + t754
      let t747 = ((max(min(t749, t752), 0) - bounded_input.y.min_realized)*t751) + t669
      let t746 = ((max(min(input.extent.1, t749), 1) - bounded_input.y.min_realized)*t751) + t669
      let t741 = (output.s0.y.yi.yii.yiii*t750) + t669
      let t740 = ((output.s0.y.yi.yii.yiii + t725)*t750) + t669
      let t748 = (output.stride.1*t749) + t663
      for (output.s0.x.x, 0, t661) {
       allocate minmax_x[uint8 * 32] in Stack
       produce minmax_x {
        minmax_x[ramp(0, 1, 32)] = min(max_y[ramp(t740 + -32, 1, 32)], min(max_y[ramp(t740 + -31, 1, 32)], max_y[ramp(t740 + -30, 1, 32)]))
       }
       consume minmax_x {
        let t589 = minmax_x[ramp(0, 1, 32)]
        let t592 = max(min_y[ramp(t741 + -32, 1, 32)], max(min_y[ramp(t741 + -31, 1, 32)], min_y[ramp(t741 + -30, 1, 32)]))
        let t598 = bounded_input[ramp(t742 + -66, 1, 32)]
        let t599 = bounded_input[ramp(t743 + -32, 1, 32)]
        let t600 = max(min(bounded_input[ramp(t744 + -66, 1, 32)], max(t598, t599)), min(t598, t599))
        let t604 = bounded_input[ramp((t746 - t650) + -65, 1, 32)]
        let t606 = bounded_input[ramp(t747 + -31, 1, 32)]
        let t607 = max(min(bounded_input[ramp((t745 - t650) + -65, 1, 32)], max(t604, t606)), min(t604, t606))
        let t608 = bounded_input[ramp((t746 - t650) + -64, 1, 32)]
        let t609 = bounded_input[ramp(t747 + -30, 1, 32)]
        output[ramp(t748 + -32, 1, 32)] = max(min(max(t589, t592), max(min(max(t600, t607), max(min(bounded_input[ramp((t745 - t650) + -64, 1, 32)], max(t608, t609)), min(t608, t609))), min(t600, t607))), min(t589, t592))
       }
       free minmax_x
      }
     }
    }
    free min_y
   }
  }
 }
 free max_y
}
free bounded_input
}


external_plus_metadata func median3x3 (input, output) {
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(input.stride.0 == 1, 0)
assert(output.stride.0 == 1, 0)
produce output {
 let t664 = input.extent.0 + input.min.0
 let t665 = output.extent.0 + output.min.0
 let t666 = min(output.extent.0, 32)
 let t667 = output.min.1*output.stride.1
 let t668 = max(output.extent.0/32, 0)
 let t669 = max(output.extent.0, 32)
 let t670 = ((t669 + 1)/32)*32
 let t671 = (t669 + 33)/32
 let t672 = min(max(((input.min.0 - t666) - output.min.0)/32, -2) + 2, t671)
 let t652 = max((min(((min(min(t664 + 30, t665) + 1, t664) - t666) - output.min.0) + 31, t669) + 2)/32, t672)
 let t648 = (output.extent.1 + 33)/34
 let t650 = max(max(output.extent.0 + 1, t666 + t670) + -2, output.extent.0) - t666
 let t661 = ((output.extent.0 + 31)/32) - t668
 let t663 = output.extent.0 - t667
 let t660 = 0 - t667
 let t653 = output.min.0 + t666
 let parallel_closure = (void *)make_struct(input, output, input.extent.1, input.min.0, input.min.1, input.stride.1, output.extent.1, output.min.1, output.stride.1, t650, t652, t653, t660, t661, t663, t664, t665, t666, t668, t669, t670, t671, t672)
 let closure_result = halide_do_par_for((void *)::median3x3_par_for_output_s0_y_y, 0, t648, (uint8_t *)(parallel_closure))
 assert(closure_result == 0, closure_result)
}
}


