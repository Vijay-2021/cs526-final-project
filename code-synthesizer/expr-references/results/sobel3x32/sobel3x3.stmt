module name=sobel3x3, target=x86-64-noos-avx-avx2-avx512-avx512_skylake-f16c-fma-no_asserts-no_bounds_query-sse41
external func sobel3x3_par_for_output_s0_y_y (__user_context, output.s0.y.y, closure_arg) {
let closure_prototype = (void *)make_struct((void *)reinterpret((uint64)0), (void *)reinterpret((uint64)0), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
let input = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 0)
let output = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 1)
let input.extent.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 2)
let input.min.0 = load_typed_struct_member((void *)closure_arg, closure_prototype, 3)
let input.min.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 4)
let input.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 5)
let output.extent.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 6)
let output.min.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 7)
let output.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 8)
let t319 = load_typed_struct_member((void *)closure_arg, closure_prototype, 9)
let t321 = load_typed_struct_member((void *)closure_arg, closure_prototype, 10)
let t329 = load_typed_struct_member((void *)closure_arg, closure_prototype, 11)
let t332 = load_typed_struct_member((void *)closure_arg, closure_prototype, 12)
let t335 = load_typed_struct_member((void *)closure_arg, closure_prototype, 13)
let t336 = load_typed_struct_member((void *)closure_arg, closure_prototype, 14)
let t338 = load_typed_struct_member((void *)closure_arg, closure_prototype, 15)
let t339 = load_typed_struct_member((void *)closure_arg, closure_prototype, 16)
let t340 = load_typed_struct_member((void *)closure_arg, closure_prototype, 17)
let t341 = load_typed_struct_member((void *)closure_arg, closure_prototype, 18)
let t342 = load_typed_struct_member((void *)closure_arg, closure_prototype, 19)
let t344 = load_typed_struct_member((void *)closure_arg, closure_prototype, 20)
let t345 = load_typed_struct_member((void *)closure_arg, closure_prototype, 21)
let t346 = load_typed_struct_member((void *)closure_arg, closure_prototype, 22)
let t347 = load_typed_struct_member((void *)closure_arg, closure_prototype, 23)
let t348 = load_typed_struct_member((void *)closure_arg, closure_prototype, 24)
let t349 = load_typed_struct_member((void *)closure_arg, closure_prototype, 25)
let output.s0.y.yi.base.s = min(output.s0.y.y*36, output.extent.1 + -36)
allocate repeat_edge[uint8 * (t347 + 32) * 16] in Stack
allocate input_16[uint16 * (t319 + 32) * 16] in Stack
produce repeat_edge {
 let t350 = (output.min.1 - input.min.1) + output.s0.y.yi.base.s
 let t351 = output.min.1 + output.s0.y.yi.base.s
 for (repeat_edge.s0._1.rebased, 0, 2) {
  let t353 = ((((repeat_edge.s0._1.rebased + t351) + 15) % 16)*(t347 + 32)) - t321
  let t352 = ((max(min(repeat_edge.s0._1.rebased + t350, input.extent.1), 1) + -1)*input.stride.1) - input.min.0
  for (repeat_edge.s0._0._0, 0, t348) {
   let repeat_edge.s0._0._0i.base.s = min((repeat_edge.s0._0._0*32) + t321, t340 + 34)
   repeat_edge[ramp(repeat_edge.s0._0._0i.base.s + t353, 1, 32)] = input[max(min(ramp(repeat_edge.s0._0._0i.base.s + -65, 1, 32), x32(t339 + -1)), x32(input.min.0)) + x32(t352)]
  }
 }
}
produce input_16 {
 consume repeat_edge {
  let t358 = output.min.1 + output.s0.y.yi.base.s
  let t359 = t358 % 16
  let t360 = t319 + 32
  let t361 = t347 + 32
  let t362 = (t358 + 15) % 16
  let t354 = (t361*t362) - t321
  let t356 = (t360*t362) - t321
  let t355 = (t359*t361) - t321
  let t357 = (t359*t360) - t321
  for (input_16.s0.x.x, 0, t348) {
   let input_16.s0.x.xi.base.s = (input_16.s0.x.x*32) + t321
   allocate bounded_input[uint8 * 64] in Stack
   produce bounded_input {
    bounded_input[ramp(0, 1, 32)] = repeat_edge[ramp(input_16.s0.x.xi.base.s + t354, 1, 32)]
    bounded_input[ramp(32, 1, 32)] = repeat_edge[ramp(input_16.s0.x.xi.base.s + t355, 1, 32)]
   }
   consume bounded_input {
    input_16[ramp(input_16.s0.x.xi.base.s + t356, 1, 32)] = uint16x32(bounded_input[ramp(0, 1, 32)])
    input_16[ramp(input_16.s0.x.xi.base.s + t357, 1, 32)] = uint16x32(bounded_input[ramp(32, 1, 32)])
    free bounded_input
   }
  }
 }
}
let t370 = min(output.s0.y.y*36, output.extent.1 + -36)
let t365 = (input.min.1 - output.min.1) - t370
let t369 = (output.min.1 - t342) + t370
let t366 = output.min.1 + t370
let t363 = output.min.1 + output.s0.y.yi.base.s
for (output.s0.y.yi.yi.$n, 0, 4) {
 produce repeat_edge {
  let repeat_edge.s0._1.prologue = let t438 = ((output.s0.y.yi.yi.$n*9) + t363) in min(max(t438 + 1, input.min.1), t438 + 10)
  let repeat_edge.s0._1.epilogue = let t439 = ((output.s0.y.yi.yi.$n*9) + t363) in min(max(max(t439 + 1, input.min.1), input.extent.1 + input.min.1), t439 + 10)
  let t373 = output.s0.y.yi.yi.$n*9
  let t371 = max(min(t365 - t373, 10), 1)
  let t372 = t363 + t373
  for (repeat_edge.s0._1.rebased, 0, t371 + -1) {
   let t375 = ((((repeat_edge.s0._1.rebased + t372) + 1) % 16)*(t347 + 32)) - t321
   let t374 = ((max(min(((t372 - input.min.1) + repeat_edge.s0._1.rebased) + 2, input.extent.1), 1) + -1)*input.stride.1) - input.min.0
   for (repeat_edge.s0._0._0, 0, t348) {
    let repeat_edge.s0._0._0i.base.s = min((repeat_edge.s0._0._0*32) + t321, t340 + 34)
    repeat_edge[ramp(repeat_edge.s0._0._0i.base.s + t375, 1, 32)] = input[max(min(ramp(repeat_edge.s0._0._0i.base.s + -65, 1, 32), x32(t339 + -1)), x32(input.min.0)) + x32(t374)]
   }
  }
  let t380 = (output.s0.y.yi.yi.$n*9) + t366
  let t381 = t380 + 1
  let t382 = t380 + 10
  let t376 = min(max(t342, t381), t382) - min(max(input.min.1, t381), t382)
  let t379 = t348 - t329
  let t377 = repeat_edge.s0._1.prologue - input.min.1
  for (repeat_edge.s0._1.rebased, 0, t376) {
   let t384 = (((repeat_edge.s0._1.prologue + repeat_edge.s0._1.rebased) % 16)*(t347 + 32)) - t321
   let t383 = ((repeat_edge.s0._1.rebased + t377)*input.stride.1) - input.min.0
   for (repeat_edge.s0._0._0, 0, t349) {
    let repeat_edge.s0._0._0i.base.s = min((repeat_edge.s0._0._0*32) + t321, t340 + 34)
    repeat_edge[ramp(repeat_edge.s0._0._0i.base.s + t384, 1, 32)] = input[max(min(ramp(repeat_edge.s0._0._0i.base.s + -65, 1, 32), x32(t339 + -1)), x32(input.min.0)) + x32(t383)]
   }
   let t387 = (((repeat_edge.s0._1.prologue + repeat_edge.s0._1.rebased) % 16)*(t347 + 32)) - t321
   let t386 = ((repeat_edge.s0._1.rebased + t377)*input.stride.1) - input.min.0
   let t385 = t329 - t349
   for (repeat_edge.s0._0._0.rebased, 0, t385) {
    let repeat_edge.s0._0._0i.base.s = ((repeat_edge.s0._0._0.rebased + t349)*32) + t321
    repeat_edge[ramp(repeat_edge.s0._0._0i.base.s + t387, 1, 32)] = input[ramp((repeat_edge.s0._0._0i.base.s + t386) + -65, 1, 32)]
   }
   let t389 = (((repeat_edge.s0._1.prologue + repeat_edge.s0._1.rebased) % 16)*(t347 + 32)) - t321
   let t388 = ((repeat_edge.s0._1.rebased + t377)*input.stride.1) - input.min.0
   for (repeat_edge.s0._0._0.rebased, 0, t379) {
    let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0.rebased + t329)*32) + t321, t340 + 34)
    repeat_edge[ramp(repeat_edge.s0._0._0i.base.s + t389, 1, 32)] = input[max(min(ramp(repeat_edge.s0._0._0i.base.s + -65, 1, 32), x32(t339 + -1)), x32(input.min.0)) + x32(t388)]
   }
  }
  let t390 = max(min((output.s0.y.yi.yi.$n*9) + t369, -1), -10)
  let t391 = repeat_edge.s0._1.epilogue - input.min.1
  for (repeat_edge.s0._1.rebased, 0, t390 + 10) {
   let t392 = (max(min(repeat_edge.s0._1.rebased + t391, input.extent.1 + -1), 0)*input.stride.1) - input.min.0
   let t393 = (((repeat_edge.s0._1.epilogue + repeat_edge.s0._1.rebased) % 16)*(t347 + 32)) - t321
   for (repeat_edge.s0._0._0, 0, t348) {
    let repeat_edge.s0._0._0i.base.s = min((repeat_edge.s0._0._0*32) + t321, t340 + 34)
    repeat_edge[ramp(repeat_edge.s0._0._0i.base.s + t393, 1, 32)] = input[max(min(ramp(repeat_edge.s0._0._0i.base.s + -65, 1, 32), x32(t339 + -1)), x32(input.min.0)) + x32(t392)]
   }
  }
 }
 produce input_16 {
  consume repeat_edge {
   let t412 = (output.s0.y.yi.yi.$n*9) + t363
   let t413 = (t412 + 1) % 16
   let t414 = t319 + 32
   let t415 = t347 + 32
   let t416 = (t412 + 2) % 16
   let t417 = (t412 + 3) % 16
   let t418 = (t412 + 4) % 16
   let t419 = (t412 + 5) % 16
   let t420 = (t412 + 6) % 16
   let t421 = (t412 + 7) % 16
   let t422 = (t412 + 8) % 16
   let t423 = (t412 + 9) % 16
   let t402 = (t415*t423) - t321
   let t411 = (t414*t423) - t321
   let t401 = (t415*t422) - t321
   let t410 = (t414*t422) - t321
   let t400 = (t415*t421) - t321
   let t409 = (t414*t421) - t321
   let t399 = (t415*t420) - t321
   let t408 = (t414*t420) - t321
   let t398 = (t415*t419) - t321
   let t407 = (t414*t419) - t321
   let t397 = (t415*t418) - t321
   let t406 = (t414*t418) - t321
   let t396 = (t415*t417) - t321
   let t405 = (t414*t417) - t321
   let t395 = (t415*t416) - t321
   let t404 = (t414*t416) - t321
   let t394 = (t413*t415) - t321
   let t403 = (t413*t414) - t321
   for (input_16.s0.x.x, 0, t348) {
    let input_16.s0.x.xi.base.s = (input_16.s0.x.x*32) + t321
    allocate bounded_input[uint8 * 288] in Stack
    produce bounded_input {
     bounded_input[ramp(0, 1, 32)] = repeat_edge[ramp(input_16.s0.x.xi.base.s + t394, 1, 32)]
     bounded_input[ramp(32, 1, 32)] = repeat_edge[ramp(input_16.s0.x.xi.base.s + t395, 1, 32)]
     bounded_input[ramp(64, 1, 32)] = repeat_edge[ramp(input_16.s0.x.xi.base.s + t396, 1, 32)]
     bounded_input[ramp(96, 1, 32)] = repeat_edge[ramp(input_16.s0.x.xi.base.s + t397, 1, 32)]
     bounded_input[ramp(128, 1, 32)] = repeat_edge[ramp(input_16.s0.x.xi.base.s + t398, 1, 32)]
     bounded_input[ramp(160, 1, 32)] = repeat_edge[ramp(input_16.s0.x.xi.base.s + t399, 1, 32)]
     bounded_input[ramp(192, 1, 32)] = repeat_edge[ramp(input_16.s0.x.xi.base.s + t400, 1, 32)]
     bounded_input[ramp(224, 1, 32)] = repeat_edge[ramp(input_16.s0.x.xi.base.s + t401, 1, 32)]
     bounded_input[ramp(256, 1, 32)] = repeat_edge[ramp(input_16.s0.x.xi.base.s + t402, 1, 32)]
    }
    consume bounded_input {
     input_16[ramp(input_16.s0.x.xi.base.s + t403, 1, 32)] = uint16x32(bounded_input[ramp(0, 1, 32)])
     input_16[ramp(input_16.s0.x.xi.base.s + t404, 1, 32)] = uint16x32(bounded_input[ramp(32, 1, 32)])
     input_16[ramp(input_16.s0.x.xi.base.s + t405, 1, 32)] = uint16x32(bounded_input[ramp(64, 1, 32)])
     input_16[ramp(input_16.s0.x.xi.base.s + t406, 1, 32)] = uint16x32(bounded_input[ramp(96, 1, 32)])
     input_16[ramp(input_16.s0.x.xi.base.s + t407, 1, 32)] = uint16x32(bounded_input[ramp(128, 1, 32)])
     input_16[ramp(input_16.s0.x.xi.base.s + t408, 1, 32)] = uint16x32(bounded_input[ramp(160, 1, 32)])
     input_16[ramp(input_16.s0.x.xi.base.s + t409, 1, 32)] = uint16x32(bounded_input[ramp(192, 1, 32)])
     input_16[ramp(input_16.s0.x.xi.base.s + t410, 1, 32)] = uint16x32(bounded_input[ramp(224, 1, 32)])
     input_16[ramp(input_16.s0.x.xi.base.s + t411, 1, 32)] = uint16x32(bounded_input[ramp(256, 1, 32)])
     free bounded_input
    }
   }
  }
 }
 consume input_16 {
  let t424 = (output.s0.y.yi.yi.$n*9) + t363
  for (output.s0.y.yi.yii, 0, 9) {
   allocate sobel_y[uint16 * (t346 + 128) * 1] in Stack
   produce sobel_y {
    let t425 = output.s0.y.yi.yii + t424
    for (sobel_y.s0.x.x, 0, t332) {
     let sobel_y.s0.x.xi.base.s = (sobel_y.s0.x.x*128) + t321
     allocate sobel_y_avg[uint16 * 144] in Stack
     produce sobel_y_avg {
      let t302 = sobel_y.s0.x.xi.base.s - t321
      sobel_y_avg[ramp(0, 1, 16)] = (uint16x16)shift_left(input_16[ramp(((t425 % 16)*(t319 + 32)) + t302, 1, 16)], x16((uint16)1)) + (input_16[ramp((((t425 + 1) % 16)*(t319 + 32)) + t302, 1, 16)] + input_16[ramp((((t425 + 15) % 16)*(t319 + 32)) + t302, 1, 16)])
      sobel_y_avg[ramp(16, 1, 16)] = (uint16x16)shift_left(input_16[ramp((((t425 % 16)*(t319 + 32)) + t302) + 16, 1, 16)], x16((uint16)1)) + (input_16[ramp(((((t425 + 1) % 16)*(t319 + 32)) + t302) + 16, 1, 16)] + input_16[ramp(((((t425 + 15) % 16)*(t319 + 32)) + t302) + 16, 1, 16)])
      sobel_y_avg[ramp(32, 1, 16)] = (uint16x16)shift_left(input_16[ramp((((t425 % 16)*(t319 + 32)) + t302) + 32, 1, 16)], x16((uint16)1)) + (input_16[ramp(((((t425 + 1) % 16)*(t319 + 32)) + t302) + 32, 1, 16)] + input_16[ramp(((((t425 + 15) % 16)*(t319 + 32)) + t302) + 32, 1, 16)])
      sobel_y_avg[ramp(48, 1, 16)] = (uint16x16)shift_left(input_16[ramp((((t425 % 16)*(t319 + 32)) + t302) + 48, 1, 16)], x16((uint16)1)) + (input_16[ramp(((((t425 + 1) % 16)*(t319 + 32)) + t302) + 48, 1, 16)] + input_16[ramp(((((t425 + 15) % 16)*(t319 + 32)) + t302) + 48, 1, 16)])
      sobel_y_avg[ramp(64, 1, 16)] = (uint16x16)shift_left(input_16[ramp((((t425 % 16)*(t319 + 32)) + t302) + 64, 1, 16)], x16((uint16)1)) + (input_16[ramp(((((t425 + 1) % 16)*(t319 + 32)) + t302) + 64, 1, 16)] + input_16[ramp(((((t425 + 15) % 16)*(t319 + 32)) + t302) + 64, 1, 16)])
      sobel_y_avg[ramp(80, 1, 16)] = (uint16x16)shift_left(input_16[ramp((((t425 % 16)*(t319 + 32)) + t302) + 80, 1, 16)], x16((uint16)1)) + (input_16[ramp(((((t425 + 1) % 16)*(t319 + 32)) + t302) + 80, 1, 16)] + input_16[ramp(((((t425 + 15) % 16)*(t319 + 32)) + t302) + 80, 1, 16)])
      sobel_y_avg[ramp(96, 1, 16)] = (uint16x16)shift_left(input_16[ramp((((t425 % 16)*(t319 + 32)) + t302) + 96, 1, 16)], x16((uint16)1)) + (input_16[ramp(((((t425 + 1) % 16)*(t319 + 32)) + t302) + 96, 1, 16)] + input_16[ramp(((((t425 + 15) % 16)*(t319 + 32)) + t302) + 96, 1, 16)])
      sobel_y_avg[ramp(112, 1, 16)] = (uint16x16)shift_left(input_16[ramp((((t425 % 16)*(t319 + 32)) + t302) + 112, 1, 16)], x16((uint16)1)) + (input_16[ramp(((((t425 + 1) % 16)*(t319 + 32)) + t302) + 112, 1, 16)] + input_16[ramp(((((t425 + 15) % 16)*(t319 + 32)) + t302) + 112, 1, 16)])
      sobel_y_avg[ramp(128, 1, 16)] = (uint16x16)shift_left(input_16[ramp((((t425 % 16)*(t319 + 32)) + t302) + 128, 1, 16)], x16((uint16)1)) + (input_16[ramp(((((t425 + 1) % 16)*(t319 + 32)) + t302) + 128, 1, 16)] + input_16[ramp(((((t425 + 15) % 16)*(t319 + 32)) + t302) + 128, 1, 16)])
     }
     consume sobel_y_avg {
      sobel_y[ramp(sobel_y.s0.x.xi.base.s - t321, 1, 16)] = (uint16x16)absd(sobel_y_avg[ramp(0, 1, 16)], sobel_y_avg[ramp(2, 1, 16)])
      sobel_y[ramp((sobel_y.s0.x.xi.base.s - t321) + 16, 1, 16)] = (uint16x16)absd(sobel_y_avg[ramp(16, 1, 16)], sobel_y_avg[ramp(18, 1, 16)])
      sobel_y[ramp((sobel_y.s0.x.xi.base.s - t321) + 32, 1, 16)] = (uint16x16)absd(sobel_y_avg[ramp(32, 1, 16)], sobel_y_avg[ramp(34, 1, 16)])
      sobel_y[ramp((sobel_y.s0.x.xi.base.s - t321) + 48, 1, 16)] = (uint16x16)absd(sobel_y_avg[ramp(48, 1, 16)], sobel_y_avg[ramp(50, 1, 16)])
      sobel_y[ramp((sobel_y.s0.x.xi.base.s - t321) + 64, 1, 16)] = (uint16x16)absd(sobel_y_avg[ramp(64, 1, 16)], sobel_y_avg[ramp(66, 1, 16)])
      sobel_y[ramp((sobel_y.s0.x.xi.base.s - t321) + 80, 1, 16)] = (uint16x16)absd(sobel_y_avg[ramp(80, 1, 16)], sobel_y_avg[ramp(82, 1, 16)])
      sobel_y[ramp((sobel_y.s0.x.xi.base.s - t321) + 96, 1, 16)] = (uint16x16)absd(sobel_y_avg[ramp(96, 1, 16)], sobel_y_avg[ramp(98, 1, 16)])
      sobel_y[ramp((sobel_y.s0.x.xi.base.s - t321) + 112, 1, 16)] = (uint16x16)absd(sobel_y_avg[ramp(112, 1, 16)], sobel_y_avg[ramp(114, 1, 16)])
      free sobel_y_avg
     }
    }
   }
   consume sobel_y {
    let t430 = output.s0.y.yi.yii + t424
    let t431 = t319 + 32
    let t426 = (((t430 + 15) % 16)*t431) - t341
    let t428 = (((t430 + 1) % 16)*t431) - t341
    let t427 = ((t430 % 16)*t431) - t341
    let t429 = (output.stride.1*t430) + t335
    for (output.s0.x.x, 0, t344) {
     allocate sobel_x_avg[uint16 * 192] in Stack
     produce sobel_x_avg {
      let t239 = (output.s0.x.x*64) + t426
      sobel_x_avg[ramp(0, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t239 + 65, 1, 16)], x16((uint16)1)) + (input_16[ramp(t239 + 66, 1, 16)] + input_16[ramp(t239 + 64, 1, 16)])
      let t240 = (output.s0.x.x*64) + t426
      sobel_x_avg[ramp(16, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t240 + 81, 1, 16)], x16((uint16)1)) + (input_16[ramp(t240 + 82, 1, 16)] + input_16[ramp(t240 + 80, 1, 16)])
      let t241 = (output.s0.x.x*64) + t426
      sobel_x_avg[ramp(32, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t241 + 97, 1, 16)], x16((uint16)1)) + (input_16[ramp(t241 + 98, 1, 16)] + input_16[ramp(t241 + 96, 1, 16)])
      let t242 = (output.s0.x.x*64) + t426
      sobel_x_avg[ramp(48, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t242 + 113, 1, 16)], x16((uint16)1)) + (input_16[ramp(t242 + 114, 1, 16)] + input_16[ramp(t242 + 112, 1, 16)])
      let t243 = (output.s0.x.x*64) + t427
      sobel_x_avg[ramp(64, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t243 + 65, 1, 16)], x16((uint16)1)) + (input_16[ramp(t243 + 66, 1, 16)] + input_16[ramp(t243 + 64, 1, 16)])
      let t244 = (output.s0.x.x*64) + t427
      sobel_x_avg[ramp(80, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t244 + 81, 1, 16)], x16((uint16)1)) + (input_16[ramp(t244 + 82, 1, 16)] + input_16[ramp(t244 + 80, 1, 16)])
      let t245 = (output.s0.x.x*64) + t427
      sobel_x_avg[ramp(96, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t245 + 97, 1, 16)], x16((uint16)1)) + (input_16[ramp(t245 + 98, 1, 16)] + input_16[ramp(t245 + 96, 1, 16)])
      let t246 = (output.s0.x.x*64) + t427
      sobel_x_avg[ramp(112, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t246 + 113, 1, 16)], x16((uint16)1)) + (input_16[ramp(t246 + 114, 1, 16)] + input_16[ramp(t246 + 112, 1, 16)])
      let t306 = (output.s0.x.x*64) + t428
      sobel_x_avg[ramp(128, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t306 + 65, 1, 16)], x16((uint16)1)) + (input_16[ramp(t306 + 66, 1, 16)] + input_16[ramp(t306 + 64, 1, 16)])
      sobel_x_avg[ramp(144, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t306 + 81, 1, 16)], x16((uint16)1)) + (input_16[ramp(t306 + 82, 1, 16)] + input_16[ramp(t306 + 80, 1, 16)])
      sobel_x_avg[ramp(160, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t306 + 97, 1, 16)], x16((uint16)1)) + (input_16[ramp(t306 + 98, 1, 16)] + input_16[ramp(t306 + 96, 1, 16)])
      sobel_x_avg[ramp(176, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t306 + 113, 1, 16)], x16((uint16)1)) + (input_16[ramp(t306 + 114, 1, 16)] + input_16[ramp(t306 + 112, 1, 16)])
     }
     allocate sobel_x[uint16 * 64] in Stack
     produce sobel_x {
      consume sobel_x_avg {
       sobel_x[ramp(0, 1, 16)] = (uint16x16)absd(sobel_x_avg[ramp(0, 1, 16)], sobel_x_avg[ramp(128, 1, 16)])
       sobel_x[ramp(16, 1, 16)] = (uint16x16)absd(sobel_x_avg[ramp(16, 1, 16)], sobel_x_avg[ramp(144, 1, 16)])
       sobel_x[ramp(32, 1, 16)] = (uint16x16)absd(sobel_x_avg[ramp(32, 1, 16)], sobel_x_avg[ramp(160, 1, 16)])
       sobel_x[ramp(48, 1, 16)] = (uint16x16)absd(sobel_x_avg[ramp(48, 1, 16)], sobel_x_avg[ramp(176, 1, 16)])
       free sobel_x_avg
      }
     }
     consume sobel_x {
      output[ramp((output.s0.x.x*64) + t429, 1, 32)] = uint8x32(min(sobel_x[ramp(0, 1, 32)] + sobel_y[ramp(((output.s0.x.x*64) - t341) + 64, 1, 32)], x32((uint16)255)))
      output[ramp(((output.s0.x.x*64) + t429) + 32, 1, 32)] = uint8x32(min(sobel_x[ramp(32, 1, 32)] + sobel_y[ramp(((output.s0.x.x*64) - t341) + 96, 1, 32)], x32((uint16)255)))
      free sobel_x
     }
    }
    let t436 = output.s0.y.yi.yii + t424
    let t437 = t319 + 32
    let t432 = (((t436 + 15) % 16)*t437) + t345
    let t434 = (((t436 + 1) % 16)*t437) + t345
    let t433 = ((t436 % 16)*t437) + t345
    let t435 = (output.stride.1*t436) + t338
    for (output.s0.x.x, 0, t336) {
     allocate sobel_x_avg[uint16 * 192] in Stack
     produce sobel_x_avg {
      sobel_x_avg[ramp(0, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t432 + -63, 1, 16)], x16((uint16)1)) + (input_16[ramp(t432 + -62, 1, 16)] + input_16[ramp(t432 + -64, 1, 16)])
      sobel_x_avg[ramp(16, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t432 + -47, 1, 16)], x16((uint16)1)) + (input_16[ramp(t432 + -46, 1, 16)] + input_16[ramp(t432 + -48, 1, 16)])
      sobel_x_avg[ramp(32, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t432 + -31, 1, 16)], x16((uint16)1)) + (input_16[ramp(t432 + -30, 1, 16)] + input_16[ramp(t432 + -32, 1, 16)])
      sobel_x_avg[ramp(48, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t432 + -15, 1, 16)], x16((uint16)1)) + (input_16[ramp(t432 + -14, 1, 16)] + input_16[ramp(t432 + -16, 1, 16)])
      sobel_x_avg[ramp(64, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t433 + -63, 1, 16)], x16((uint16)1)) + (input_16[ramp(t433 + -62, 1, 16)] + input_16[ramp(t433 + -64, 1, 16)])
      sobel_x_avg[ramp(80, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t433 + -47, 1, 16)], x16((uint16)1)) + (input_16[ramp(t433 + -46, 1, 16)] + input_16[ramp(t433 + -48, 1, 16)])
      sobel_x_avg[ramp(96, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t433 + -31, 1, 16)], x16((uint16)1)) + (input_16[ramp(t433 + -30, 1, 16)] + input_16[ramp(t433 + -32, 1, 16)])
      sobel_x_avg[ramp(112, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t433 + -15, 1, 16)], x16((uint16)1)) + (input_16[ramp(t433 + -14, 1, 16)] + input_16[ramp(t433 + -16, 1, 16)])
      sobel_x_avg[ramp(128, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t434 + -63, 1, 16)], x16((uint16)1)) + (input_16[ramp(t434 + -62, 1, 16)] + input_16[ramp(t434 + -64, 1, 16)])
      sobel_x_avg[ramp(144, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t434 + -47, 1, 16)], x16((uint16)1)) + (input_16[ramp(t434 + -46, 1, 16)] + input_16[ramp(t434 + -48, 1, 16)])
      sobel_x_avg[ramp(160, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t434 + -31, 1, 16)], x16((uint16)1)) + (input_16[ramp(t434 + -30, 1, 16)] + input_16[ramp(t434 + -32, 1, 16)])
      sobel_x_avg[ramp(176, 1, 16)] = (uint16x16)shift_left(input_16[ramp(t434 + -15, 1, 16)], x16((uint16)1)) + (input_16[ramp(t434 + -14, 1, 16)] + input_16[ramp(t434 + -16, 1, 16)])
     }
     allocate sobel_x[uint16 * 64] in Stack
     produce sobel_x {
      consume sobel_x_avg {
       sobel_x[ramp(0, 1, 16)] = (uint16x16)absd(sobel_x_avg[ramp(0, 1, 16)], sobel_x_avg[ramp(128, 1, 16)])
       sobel_x[ramp(16, 1, 16)] = (uint16x16)absd(sobel_x_avg[ramp(16, 1, 16)], sobel_x_avg[ramp(144, 1, 16)])
       sobel_x[ramp(32, 1, 16)] = (uint16x16)absd(sobel_x_avg[ramp(32, 1, 16)], sobel_x_avg[ramp(160, 1, 16)])
       sobel_x[ramp(48, 1, 16)] = (uint16x16)absd(sobel_x_avg[ramp(48, 1, 16)], sobel_x_avg[ramp(176, 1, 16)])
       free sobel_x_avg
      }
     }
     consume sobel_x {
      output[ramp(t435 + -64, 1, 32)] = uint8x32(min(sobel_x[ramp(0, 1, 32)] + sobel_y[ramp(t345 + -64, 1, 32)], x32((uint16)255)))
      output[ramp(t435 + -32, 1, 32)] = uint8x32(min(sobel_x[ramp(32, 1, 32)] + sobel_y[ramp(t345 + -32, 1, 32)], x32((uint16)255)))
      free sobel_x
     }
    }
    free sobel_y
   }
  }
 }
}
free repeat_edge
free input_16
}


external_plus_metadata func sobel3x3 (input, output) {
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(input.stride.0 == 1, 0)
assert(output.stride.0 == 1, 0)
produce output {
 let t339 = input.extent.0 + input.min.0
 let t340 = output.extent.0 + output.min.0
 let t341 = min(output.extent.0, 64)
 let t342 = max(input.extent.1, 0) + input.min.1
 let t343 = output.min.1*output.stride.1
 let t344 = max(output.extent.0/64, 0)
 let t345 = max(output.extent.0, 64)
 let t346 = ((t345 + -1)/128)*128
 let t347 = ((t345 + 1)/32)*32
 let t348 = (t345 + 33)/32
 let t349 = min(max(((input.min.0 - t341) - output.min.0)/32, -3) + 3, t348)
 let t329 = max((min(((min(min(t339 + 30, t340) + 1, t339) - t341) - output.min.0) + 63, t345) + 2)/32, t349)
 let t319 = max(t346 + 112, t347)
 let t332 = (t345 + 127)/128
 let t317 = (output.extent.1 + 35)/36
 let t336 = ((output.extent.0 + 63)/64) - t344
 let t338 = output.extent.0 - t343
 let t335 = 0 - t343
 let t321 = output.min.0 + t341
 let parallel_closure = (void *)make_struct(input, output, input.extent.1, input.min.0, input.min.1, input.stride.1, output.extent.1, output.min.1, output.stride.1, t319, t321, t329, t332, t335, t336, t338, t339, t340, t341, t342, t344, t345, t346, t347, t348, t349)
 let closure_result = halide_do_par_for((void *)::sobel3x3_par_for_output_s0_y_y, 0, t317, (uint8_t *)(parallel_closure))
 assert(closure_result == 0, closure_result)
}
}


