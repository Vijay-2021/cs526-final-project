module name=sobel3x3, target=x86-64-linux-avx-avx2-avx512-avx512_sapphirerapids-avx512_skylake-f16c-fma-sse41
external_plus_metadata func sobel3x3 (input, output) {
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
let input.extent.0.required.s = let t289 = (output.extent.0 + output.min.0) in (let t290 = (input.extent.0 + input.min.0) in (let t291 = (min(output.extent.0, 32) + output.min.0) in (max(max(max(min(t289, t290 + -1), min(t289, t290 + 1) + -2), min(t289, t290) + -1), input.min.0) - max(min(min(min(t291, t290 + 32), min(t291, t290 + 30) + 2), min(t291, t290 + 31) + 1) + -33, input.min.0))))
let input.min.0.required = let t292 = (min(output.extent.0, 32) + output.min.0) in (let t293 = (input.extent.0 + input.min.0) in max(min(min(min(t292, t293 + 32), min(t292, t293 + 30) + 2), min(t292, t293 + 31) + 1) + -33, input.min.0))
let input.extent.1.required.s = let t294 = (output.extent.1 + output.min.1) in (let t295 = (input.extent.1 + input.min.1) in (max(max(max(min(t294, t295 + -1), min(t294, t295 + 1) + -2), min(t294, t295) + -1), input.min.1) - max(min(t295, output.min.1) + -1, input.min.1)))
let input.min.1.required = max(min(input.extent.1 + input.min.1, output.min.1) + -1, input.min.1)
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)input.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)input.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 8, 2, (halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required.s + 1, 1, 0, input.min.1.required, input.extent.1.required.s + 1, input.extent.0.required.s + 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer)) {
 let t296 = max(output.extent.0, 32) in (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)output.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)output.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 8, 2, (halide_dimension_t *)make_struct((min(output.extent.0, 32) + output.min.0) + -32, t296, 1, 0, output.min.1, output.extent.1, t296, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || (uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer))) {
 assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
 assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
 assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
 assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
 assert((input.min.0 <= input.min.0.required) && (((input.extent.0.required.s + input.min.0.required) + 1) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, input.extent.0.required.s + input.min.0.required, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && (((input.extent.1.required.s + input.min.1.required) + 1) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, input.extent.1.required.s + input.min.1.required, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert(32 <= output.extent.0, let t297 = (output.extent.0 + output.min.0) in halide_error_access_out_of_bounds("Output buffer output", 0, (min(output.extent.0, 32) + output.min.0) + -32, t297 + -1, output.min.0, t297 + -1))
 assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert(uint64(output.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", uint64(output.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1)), (uint64)2147483647))
 assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(!output.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer output"))
 assert(input != (void *)reinterpret((uint64)0), halide_error_host_is_null("Input buffer input"))
 assert(output != (void *)reinterpret((uint64)0), halide_error_host_is_null("Output buffer output"))
 produce output {
  let output.s0.y.prologue = min(max(input.min.1 + 1, output.min.1), output.extent.1 + output.min.1)
  let output.s0.y.epilogue = min(max(max(input.min.1 + 1, output.min.1), (input.extent.1 + input.min.1) + -1), output.extent.1 + output.min.1)
  let t240 = (output.extent.0 + 31)/32
  let t239 = output.s0.y.prologue - output.min.1
  let t242 = output.min.1 - input.min.1
  let t243 = 0 - (output.min.1*output.stride.1)
  let t241 = input.extent.0 + input.min.0
  for (output.s0.y.rebased, 0, t239) {
   let t248 = output.s0.y.rebased + t242
   let t245 = min(t248 + 2, input.extent.1)
   let t246 = min(input.extent.1 + -1, t248)
   let t244 = min(input.extent.1, t248)
   let t247 = ((output.min.1 + output.s0.y.rebased)*output.stride.1) + t243
   for (output.s0.x.x, 0, t240) {
    let output.s0.x.v0.base.s = min(output.s0.x.x*32, output.extent.0 + -32)
    let t163 = max(min(ramp(output.min.0 + output.s0.x.v0.base.s, 1, 32), x32(t241 + -1)), x32(input.min.0))
    let t166 = max(min(ramp((output.min.0 + output.s0.x.v0.base.s) + -1, 1, 32), x32(t241 + -1)), x32(input.min.0))
    let t167.s = input[t166 + x32(((max(t244, 1) + -1)*input.stride.1) - input.min.0)]
    let t168 = max(min(ramp((output.min.0 + output.s0.x.v0.base.s) + 1, 1, 32), x32(t241 + -1)), x32(input.min.0))
    let t169.s = input[t168 + x32(((max(t244, 1) + -1)*input.stride.1) - input.min.0)]
    let t171.s = input[t166 + x32(((max(t245, 1) + -1)*input.stride.1) - input.min.0)]
    let t172.s = input[t168 + x32(((max(t245, 1) + -1)*input.stride.1) - input.min.0)]
    let t232 = x32((max(t246, 0)*input.stride.1) - input.min.0)
    output[ramp(output.s0.x.v0.base.s + t247, 1, 32)] = uint8x32(min((uint16x32)absd(((uint16x32)widening_shift_left(input[t163 + x32(((max(t244, 1) + -1)*input.stride.1) - input.min.0)], x32((uint8)1)) + uint16x32(t167.s)) + uint16x32(t169.s), ((uint16x32)widening_shift_left(input[t163 + x32(((max(t245, 1) + -1)*input.stride.1) - input.min.0)], x32((uint8)1)) + uint16x32(t171.s)) + uint16x32(t172.s)) + (uint16x32)absd(((uint16x32)widening_shift_left(input[t166 + t232], x32((uint8)1)) + uint16x32(t167.s)) + uint16x32(t171.s), ((uint16x32)widening_shift_left(input[t168 + t232], x32((uint8)1)) + uint16x32(t169.s)) + uint16x32(t172.s)), x32((uint16)255)))
   }
  }
  let t257 = input.extent.0 + input.min.0
  let t258 = (output.extent.0 + 31)/32
  let t259 = min(max((input.min.0 - output.min.0)/32, -1) + 1, t258)
  let t260 = t257 - output.min.0
  let t251 = max((min(min(min(output.extent.0 + -32, t260), min(output.extent.0 + 1, t260) + -33), output.extent.0 + -1)/32) + 1, t259)
  let t253 = output.s0.y.prologue - input.min.1
  let t249 = output.s0.y.epilogue - output.s0.y.prologue
  let t254 = 0 - (output.min.1*output.stride.1)
  for (output.s0.y.rebased, 0, t249) {
   let t265 = output.s0.y.rebased + t253
   let t262 = ((t265 + 1)*input.stride.1) - input.min.0
   let t261 = ((t265 + -1)*input.stride.1) - input.min.0
   let t264 = ((output.s0.y.prologue + output.s0.y.rebased)*output.stride.1) + t254
   for (output.s0.x.x, 0, t259) {
    let output.s0.x.v0.base.s = min(output.s0.x.x*32, output.extent.0 + -32)
    let t177 = max(min(ramp(output.min.0 + output.s0.x.v0.base.s, 1, 32), x32(t257 + -1)), x32(input.min.0))
    let t180 = max(min(ramp((output.min.0 + output.s0.x.v0.base.s) + -1, 1, 32), x32(t257 + -1)), x32(input.min.0))
    let t181.s = input[t180 + x32(t261)]
    let t182 = max(min(ramp((output.min.0 + output.s0.x.v0.base.s) + 1, 1, 32), x32(t257 + -1)), x32(input.min.0))
    let t183.s = input[t182 + x32(t261)]
    let t185.s = input[t180 + x32(t262)]
    let t186.s = input[t182 + x32(t262)]
    let t235 = x32((input.stride.1*t265) - input.min.0)
    output[ramp(output.s0.x.v0.base.s + t264, 1, 32)] = uint8x32(min((uint16x32)absd(((uint16x32)widening_shift_left(input[t177 + x32(((t265 + -1)*input.stride.1) - input.min.0)], x32((uint8)1)) + uint16x32(t181.s)) + uint16x32(t183.s), ((uint16x32)widening_shift_left(input[t177 + x32(((t265 + 1)*input.stride.1) - input.min.0)], x32((uint8)1)) + uint16x32(t185.s)) + uint16x32(t186.s)) + (uint16x32)absd(((uint16x32)widening_shift_left(input[t180 + t235], x32((uint8)1)) + uint16x32(t181.s)) + uint16x32(t185.s), ((uint16x32)widening_shift_left(input[t182 + t235], x32((uint8)1)) + uint16x32(t183.s)) + uint16x32(t186.s)), x32((uint16)255)))
   }
   let t271 = output.s0.y.rebased + t253
   let t272 = output.min.0 - input.min.0
   let t266 = t251 - t259
   let t268 = ((t271 + 1)*input.stride.1) + t272
   let t267 = ((t271 + -1)*input.stride.1) + t272
   let t269 = (input.stride.1*t271) + t272
   let t270 = ((output.s0.y.prologue + output.s0.y.rebased)*output.stride.1) + t254
   for (output.s0.x.x.rebased, 0, t266) {
    let t190 = ((output.s0.x.x.rebased + t259)*32) + t267
    let t191.s = input[ramp(t190 + -1, 1, 32)]
    let t192.s = input[ramp(t190 + 1, 1, 32)]
    let t193 = ((output.s0.x.x.rebased + t259)*32) + t268
    let t194.s = input[ramp(t193 + -1, 1, 32)]
    let t195.s = input[ramp(t193 + 1, 1, 32)]
    let t196 = ((output.s0.x.x.rebased + t259)*32) + t269
    output[ramp(((output.s0.x.x.rebased + t259)*32) + t270, 1, 32)] = uint8x32(min((uint16x32)absd(((uint16x32)widening_shift_left(input[ramp(t190, 1, 32)], x32((uint8)1)) + uint16x32(t191.s)) + uint16x32(t192.s), ((uint16x32)widening_shift_left(input[ramp(t193, 1, 32)], x32((uint8)1)) + uint16x32(t194.s)) + uint16x32(t195.s)) + (uint16x32)absd(((uint16x32)widening_shift_left(input[ramp(t196 + -1, 1, 32)], x32((uint8)1)) + uint16x32(t191.s)) + uint16x32(t194.s), ((uint16x32)widening_shift_left(input[ramp(t196 + 1, 1, 32)], x32((uint8)1)) + uint16x32(t192.s)) + uint16x32(t195.s)), x32((uint16)255)))
   }
   let t278 = output.s0.y.rebased + t253
   let t275 = ((t278 + 1)*input.stride.1) - input.min.0
   let t274 = ((t278 + -1)*input.stride.1) - input.min.0
   let t273 = t258 - t251
   let t277 = ((output.s0.y.prologue + output.s0.y.rebased)*output.stride.1) + t254
   for (output.s0.x.x.rebased, 0, t273) {
    let output.s0.x.v0.base.s = min((output.s0.x.x.rebased + t251)*32, output.extent.0 + -32)
    let t199 = max(min(ramp(output.min.0 + output.s0.x.v0.base.s, 1, 32), x32(t257 + -1)), x32(input.min.0))
    let t202 = max(min(ramp((output.min.0 + output.s0.x.v0.base.s) + -1, 1, 32), x32(t257 + -1)), x32(input.min.0))
    let t203.s = input[t202 + x32(t274)]
    let t204 = max(min(ramp((output.min.0 + output.s0.x.v0.base.s) + 1, 1, 32), x32(t257 + -1)), x32(input.min.0))
    let t205.s = input[t204 + x32(t274)]
    let t207.s = input[t202 + x32(t275)]
    let t208.s = input[t204 + x32(t275)]
    let t237 = x32((input.stride.1*t278) - input.min.0)
    output[ramp(output.s0.x.v0.base.s + t277, 1, 32)] = uint8x32(min((uint16x32)absd(((uint16x32)widening_shift_left(input[t199 + x32(((t278 + -1)*input.stride.1) - input.min.0)], x32((uint8)1)) + uint16x32(t203.s)) + uint16x32(t205.s), ((uint16x32)widening_shift_left(input[t199 + x32(((t278 + 1)*input.stride.1) - input.min.0)], x32((uint8)1)) + uint16x32(t207.s)) + uint16x32(t208.s)) + (uint16x32)absd(((uint16x32)widening_shift_left(input[t202 + t237], x32((uint8)1)) + uint16x32(t203.s)) + uint16x32(t207.s), ((uint16x32)widening_shift_left(input[t204 + t237], x32((uint8)1)) + uint16x32(t205.s)) + uint16x32(t208.s)), x32((uint16)255)))
   }
  }
  let t280 = (output.extent.0 + 31)/32
  let t279 = (output.extent.1 + output.min.1) - output.s0.y.epilogue
  let t282 = output.s0.y.epilogue - input.min.1
  let t283 = 0 - (output.min.1*output.stride.1)
  let t281 = input.extent.0 + input.min.0
  for (output.s0.y.rebased, 0, t279) {
   let t288 = output.s0.y.rebased + t282
   let t285 = min(t288 + 2, input.extent.1)
   let t286 = min(input.extent.1 + -1, t288)
   let t284 = min(input.extent.1, t288)
   let t287 = ((output.s0.y.epilogue + output.s0.y.rebased)*output.stride.1) + t283
   for (output.s0.x.x, 0, t280) {
    let output.s0.x.v0.base.s = min(output.s0.x.x*32, output.extent.0 + -32)
    let t212 = max(min(ramp(output.min.0 + output.s0.x.v0.base.s, 1, 32), x32(t281 + -1)), x32(input.min.0))
    let t215 = max(min(ramp((output.min.0 + output.s0.x.v0.base.s) + -1, 1, 32), x32(t281 + -1)), x32(input.min.0))
    let t216.s = input[t215 + x32(((max(t284, 1) + -1)*input.stride.1) - input.min.0)]
    let t217 = max(min(ramp((output.min.0 + output.s0.x.v0.base.s) + 1, 1, 32), x32(t281 + -1)), x32(input.min.0))
    let t218.s = input[t217 + x32(((max(t284, 1) + -1)*input.stride.1) - input.min.0)]
    let t220.s = input[t215 + x32(((max(t285, 1) + -1)*input.stride.1) - input.min.0)]
    let t221.s = input[t217 + x32(((max(t285, 1) + -1)*input.stride.1) - input.min.0)]
    let t238 = x32((max(t286, 0)*input.stride.1) - input.min.0)
    output[ramp(output.s0.x.v0.base.s + t287, 1, 32)] = uint8x32(min((uint16x32)absd(((uint16x32)widening_shift_left(input[t212 + x32(((max(t284, 1) + -1)*input.stride.1) - input.min.0)], x32((uint8)1)) + uint16x32(t216.s)) + uint16x32(t218.s), ((uint16x32)widening_shift_left(input[t212 + x32(((max(t285, 1) + -1)*input.stride.1) - input.min.0)], x32((uint8)1)) + uint16x32(t220.s)) + uint16x32(t221.s)) + (uint16x32)absd(((uint16x32)widening_shift_left(input[t215 + t238], x32((uint8)1)) + uint16x32(t216.s)) + uint16x32(t220.s), ((uint16x32)widening_shift_left(input[t217 + t238], x32((uint8)1)) + uint16x32(t218.s)) + uint16x32(t221.s)), x32((uint16)255)))
   }
  }
 }
}
}


