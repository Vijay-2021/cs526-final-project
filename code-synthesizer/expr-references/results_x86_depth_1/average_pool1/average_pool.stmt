module name=average_pool, target=x86-64-noos-avx-avx2-avx512-avx512_skylake-f16c-fma-no_asserts-no_bounds_query-sse41
external func average_pool_par_for_output_s0_c_c_c (__user_context, output.s0.c.c.c, closure_arg) {
let closure_prototype = (void *)make_struct((void *)reinterpret((uint64)0), (void *)reinterpret((uint64)0), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint8)0, (uint8)0)
let input = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 0)
let output = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 1)
let filter_height = load_typed_struct_member((void *)closure_arg, closure_prototype, 2)
let filter_width = load_typed_struct_member((void *)closure_arg, closure_prototype, 3)
let input.min.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 4)
let input.min.2 = load_typed_struct_member((void *)closure_arg, closure_prototype, 5)
let input.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 6)
let input.stride.2 = load_typed_struct_member((void *)closure_arg, closure_prototype, 7)
let output.extent.0 = load_typed_struct_member((void *)closure_arg, closure_prototype, 8)
let output.extent.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 9)
let output.extent.2 = load_typed_struct_member((void *)closure_arg, closure_prototype, 10)
let output.min.0 = load_typed_struct_member((void *)closure_arg, closure_prototype, 11)
let output.min.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 12)
let output.min.2 = load_typed_struct_member((void *)closure_arg, closure_prototype, 13)
let output.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 14)
let output.stride.2 = load_typed_struct_member((void *)closure_arg, closure_prototype, 15)
let stride_x = load_typed_struct_member((void *)closure_arg, closure_prototype, 16)
let stride_y = load_typed_struct_member((void *)closure_arg, closure_prototype, 17)
let t582 = load_typed_struct_member((void *)closure_arg, closure_prototype, 18)
let t583 = load_typed_struct_member((void *)closure_arg, closure_prototype, 19)
let t584 = load_typed_struct_member((void *)closure_arg, closure_prototype, 20)
let t586 = load_typed_struct_member((void *)closure_arg, closure_prototype, 21)
let t587 = load_typed_struct_member((void *)closure_arg, closure_prototype, 22)
let t592 = load_typed_struct_member((void *)closure_arg, closure_prototype, 23)
let t606 = load_typed_struct_member((void *)closure_arg, closure_prototype, 24)
let t607 = load_typed_struct_member((void *)closure_arg, closure_prototype, 25)
let t608 = load_typed_struct_member((void *)closure_arg, closure_prototype, 26)
let t609 = load_typed_struct_member((void *)closure_arg, closure_prototype, 27)
let t610 = load_typed_struct_member((void *)closure_arg, closure_prototype, 28)
let t611 = load_typed_struct_member((void *)closure_arg, closure_prototype, 29)
let output_max = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 30)
let output_min = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 31)
let output.s0.c.ci.base.s = min((output.s0.c.c.c % t582)*512, output.extent.0 + -512)
let output.s0.x.xi.base.s = min((output.s0.c.c.c/t582)*4, output.extent.1 + -4)
let input_bounded.x.min_realized = let t652 = ((output.s0.x.xi.base.s + t606)*stride_x) in min(max(t652, input.min.1), max(input.min.1 - ((output.s0.x.xi.base.s + t607)*stride_x), 0) + t652)
let input_bounded.x.extent_realized = let t653 = ((output.s0.x.xi.base.s + t606)*stride_x) in (let t654 = ((output.s0.x.xi.base.s + t607)*stride_x) in ((min(t586 - t653, filter_width) + t654) - min(max(t653, input.min.1), max(input.min.1 - t654, 0) + t653)))
allocate input_bounded[uint8 * 512 * input_bounded.x.extent_realized * t584 * 1]
let t615 = output.s0.c.ci.base.s + t611
let t613 = output.min.1 + output.s0.x.xi.base.s
let t614 = output.min.0 + output.s0.c.ci.base.s
for (output.s0.y.y, 0, t587) {
 let output.s0.y.yi.base.s = min(output.s0.y.y*9, output.extent.2 + -9)
 let t619 = (output.s0.y.yi.base.s + t608)*stride_y
 let t620 = (output.s0.y.yi.base.s + t609)*stride_y
 let t617 = max(input.min.2 - t620, 0) + t619
 let t616 = min(t592 - t619, filter_height) + t620
 let t618 = output.min.2 + output.s0.y.yi.base.s
 for (output.s0.x.xi, 0, 4) {
  let input_bounded.s0.x.max_2.s = min(((output.s0.x.xi + t613)*stride_x) + filter_width, t586)
  let input_bounded.s0.x.min_2 = max((output.s0.x.xi + t613)*stride_x, input.min.1)
  produce input_bounded {
   let t623 = t617 - t583
   let t621 = t616 - t617
   let t624 = input_bounded.s0.x.min_2 - input_bounded.x.min_realized
   let t622 = input_bounded.s0.x.max_2.s - input_bounded.s0.x.min_2
   for (input_bounded.s0.y.rebased, 0, t621) {
    let t626 = (((input_bounded.s0.y.rebased + t623)*input_bounded.x.extent_realized)*512) - t614
    let t625 = (max(min(t592 + -1, input_bounded.s0.y.rebased + t617), input.min.2)*input.stride.2) + t610
    for (input_bounded.s0.x.rebased, 0, t622) {
     let t627 = (max(min(t586 + -1, input_bounded.s0.x.min_2 + input_bounded.s0.x.rebased), input.min.1)*input.stride.1) + t625
     let t628 = ((input_bounded.s0.x.rebased + t624)*512) + t626
     for (input_bounded.s0.c.c, 0, 32) {
      let input_bounded.s0.c.ci.base = (input_bounded.s0.c.c*16) + t614
      input_bounded[ramp(input_bounded.s0.c.ci.base + t628, 1, 16)] = input[ramp(input_bounded.s0.c.ci.base + t627, 1, 16)]
     }
    }
   }
  }
  consume input_bounded {
   let t634 = output.s0.x.xi + t613
   let t635 = stride_x*t634
   let t630 = min(t586 - t635, filter_width)
   let t629 = min(input.min.1 - t635, filter_width)
   let t631 = t635 - input_bounded.x.min_realized
   let t633 = (output.stride.1*t634) + t615
   for (output.s0.y.yi, 0, 9) {
    let t644 = output.s0.y.yi + t618
    let t645 = max(t629, 0)
    let t646 = stride_y*t644
    let t638 = max(t629, t630)
    let t637 = min(t592 - t646, filter_height)
    let t636 = min(input.min.2 - t646, filter_height)
    let t642 = (min(filter_width + t635, t586) - max(input.min.1, t635))*(min(filter_height + t646, t592) - max(input.min.2, t646))
    let t640 = t646 - t583
    let t641 = t631 + t645
    let t643 = (output.stride.2*t644) + t633
    for (output.s0.c.ci.ci, 0, 32) {
     allocate sum[uint16 * 16] in Stack
     produce sum {
      sum[ramp(0, 1, 16)] = x16((uint16)0)
      let sum.s1.r12$y.new_max.s = max(t636, t637)
      let t650 = max(t636, 0)
      let t648 = max(t638, 0) - t645
      let t647 = max(sum.s1.r12$y.new_max.s, 0) - t650
      let t649 = t640 + t650
      for (sum.s1.r12$y.rebased, 0, t647) {
       let t651 = (((sum.s1.r12$y.rebased + t649)*input_bounded.x.extent_realized)*32) + output.s0.c.ci.ci
       for (sum.s1.r12$x.rebased, 0, t648) {
        sum[ramp(0, 1, 16)] = sum[ramp(0, 1, 16)] + uint16x16(input_bounded[ramp((((sum.s1.r12$x.rebased + t641)*32) + t651)*16, 1, 16) aligned(16, 0)])
       }
      }
     }
     consume sum {
      output[ramp((output.s0.c.ci.ci*16) + t643, 1, 16)] = max(min(uint8x16(min((uint16x16)rounding_mul_shift_right(sum[ramp(0, 1, 16)], x16(uint16(max(min((t642 + 131072)/(t642*2), 65535), 0))), x16((uint16)16)), x16((uint16)255))), x16(output_max)), x16(output_min))
     }
     free sum
    }
   }
  }
 }
}
free input_bounded
}


external_plus_metadata func average_pool (input, stride_x, stride_y, filter_width, filter_height, output_min, output_max, output) {
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let input.min.2 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 2)
let input.extent.2 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 2)
let input.stride.2 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 2)
let input.min.3 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 3)
let input.stride.3 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 3)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
let output.min.2 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 2)
let output.extent.2 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 2)
let output.stride.2 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 2)
let output.min.3 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 3)
let output.extent.3 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 3)
let output.stride.3 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 3)
assert(input.stride.0 == 1, 0)
assert(output.stride.0 == 1, 0)
let output.s0.c.c.c.loop_extent = ((output.extent.0 + 511)/512)*((output.extent.1 + 3)/4)
produce output {
 let t592 = input.extent.2 + input.min.2
 let t593 = output.extent.2 + 8
 let t594 = stride_y < 0
 let t595 = min(output.extent.2, 9)
 let t596 = select(t594, t595, t593)
 let t597 = select(t594, t593, t595)
 let t598 = t595 + -9
 let t599 = output.extent.2 + -1
 let t600 = select(t594, t598, t599)
 let t601 = select(t594, t599, t598)
 let t602 = ((output.min.2 + t597) + -9)*stride_y
 let t603 = ((output.min.2 + t596) + -9)*stride_y
 let t604 = (output.min.2 + t601)*stride_y
 let t605 = (output.min.2 + t600)*stride_y
 let t584 = max(min(t592 - t602, filter_height) + t603, min(t592 - t604, filter_height) + t605) - min(max(input.min.2 - t603, 0) + t602, max(input.min.2 - t605, 0) + t604)
 let t583 = min(max(input.min.2 - (((output.min.2 + t596) + -9)*stride_y), 0) + (((output.min.2 + t597) + -9)*stride_y), max(input.min.2 - ((output.min.2 + t600)*stride_y), 0) + ((output.min.2 + t601)*stride_y))
 let t585 = stride_x < 0
 let t587 = t593/9
 let t582 = (output.extent.0 + 511)/512
 let t591 = (((output.min.0 - (output.min.3*output.stride.3)) - (output.min.2*output.stride.2)) - (output.min.1*output.stride.1)) - output.min.0
 let t590 = ((input.min.1*input.stride.1) + ((input.min.3*input.stride.3) + (input.min.2*input.stride.2))) + input.min.0
 let t586 = input.extent.1 + input.min.1
 for (output.s0.b.rebased, 0, output.extent.3) {
  let t612 = output.min.3 + output.s0.b.rebased
  let t610 = (input.stride.3*t612) - t590
  let t608 = select(t594, 8, 0) + output.min.2
  let t609 = select(t594, 0, 8) + output.min.2
  let t606 = select(t585, 3, 0) + output.min.1
  let t607 = select(t585, 0, 3) + output.min.1
  let t611 = (output.stride.3*t612) + t591
  let parallel_closure = (void *)make_struct(input, output, filter_height, filter_width, input.min.1, input.min.2, input.stride.1, input.stride.2, output.extent.0, output.extent.1, output.extent.2, output.min.0, output.min.1, output.min.2, output.stride.1, output.stride.2, stride_x, stride_y, t582, t583, t584, t586, t587, t592, t606, t607, t608, t609, t610, t611, (uint8)output_max, (uint8)output_min)
  let closure_result = halide_do_par_for((void *)::average_pool_par_for_output_s0_c_c_c, 0, output.s0.c.c.c.loop_extent, (uint8_t *)(parallel_closure))
  assert(closure_result == 0, closure_result)
 }
}
}


