module name=mul, target=x86-64-noos-avx-avx2-avx512-avx512_skylake-f16c-fma-no_asserts-no_bounds_query-sse41
external func mul_par_for_output_s0_x_x_x (__user_context, output.s0.x.x.x, closure_arg) {
let closure_prototype = (void *)make_struct((void *)reinterpret((uint64)0), (void *)reinterpret((uint64)0), (void *)reinterpret((uint64)0), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint32)0, (uint8)0, (uint8)0, (uint8)0, (uint8)0, (uint8)0)
let input1 = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 0)
let input2 = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 1)
let output = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 2)
let input1.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 3)
let input2.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 4)
let output.extent.0 = load_typed_struct_member((void *)closure_arg, closure_prototype, 5)
let output.extent.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 6)
let output.min.0 = load_typed_struct_member((void *)closure_arg, closure_prototype, 7)
let output.min.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 8)
let output.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 9)
let output_multiplier = load_typed_struct_member((void *)closure_arg, closure_prototype, 10)
let t10 = load_typed_struct_member((void *)closure_arg, closure_prototype, 11)
let t6 = load_typed_struct_member((void *)closure_arg, closure_prototype, 12)
let t7 = load_typed_struct_member((void *)closure_arg, closure_prototype, 13)
let t8 = load_typed_struct_member((void *)closure_arg, closure_prototype, 14)
let t9 = (uint32)load_typed_struct_member((void *)closure_arg, closure_prototype, 15)
let input1_zero = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 16)
let input2_zero = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 17)
let output_max = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 18)
let output_min = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 19)
let output_zero = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 20)
let output.s0.x.xi.base.s = min((output.s0.x.x.x % t6)*960, output.extent.0 + -960)
let output.s0.y.yi.base.s = min((output.s0.x.x.x/t6)*68, output.extent.1 + -68)
let t12 = output.min.1 + output.s0.y.yi.base.s
let t11 = output.min.0 + output.s0.x.xi.base.s
for (output.s0.y.yi, 0, 68) {
 let t13 = output.s0.y.yi + t12
 for (output.s0.x.xi.xi, 0, 30) {
  let t14 = output.s0.x.xi.xi*4
  let t17 = (output.stride.1*t13) - t10
  let t16 = (input2.stride.1*t13) - t8
  let t15 = (input1.stride.1*t13) - t7
  for (output.s0.x.xi.xii.xii, 0, 4) {
   let t4 = ((output.s0.x.xi.xii.xii + t14)*8) + t11
   output[ramp(t17 + t4, 1, 8)] = max(min(uint8x8(max(min((int16x8)saturating_add(int16x8(max(min((int32x8)rounding_shift_right((int32x8)rounding_mul_shift_right((int32x8)widening_mul((int16x8)shift_left(int16x8(input1[ramp(t15 + t4, 1, 8)]), x8((uint16)6)) + x8(int16(input1_zero)*(int16)-64), (int16x8)shift_left(int16x8(input2[ramp(t16 + t4, 1, 8)]), x8((uint16)6)) + x8(int16(input2_zero)*(int16)-64)), x8(output_multiplier), x8((uint32)31)), x8(t9)), x8(32767)), x8(-32768))), x8(int16(output_zero))), x8((int16)255)), x8((int16)0))), x8(output_max)), x8(output_min))
  }
 }
}
}


external_plus_metadata func mul (input1, input1_zero, input2, input2_zero, output_zero, output_multiplier, output_shift, output_min, output_max, output) {
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input2.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input2"))
assert((uint64)reinterpret((halide_buffer_t *)input1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input1"))
let input1 = (void *)_halide_buffer_get_host((halide_buffer_t *)input1.buffer)
let input1.min.0 = _halide_buffer_get_min((halide_buffer_t *)input1.buffer, 0)
let input1.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input1.buffer, 0)
let input1.min.1 = _halide_buffer_get_min((halide_buffer_t *)input1.buffer, 1)
let input1.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input1.buffer, 1)
let input2 = (void *)_halide_buffer_get_host((halide_buffer_t *)input2.buffer)
let input2.min.0 = _halide_buffer_get_min((halide_buffer_t *)input2.buffer, 0)
let input2.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input2.buffer, 0)
let input2.min.1 = _halide_buffer_get_min((halide_buffer_t *)input2.buffer, 1)
let input2.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input2.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(input1.stride.0 == 1, 0)
assert(input2.stride.0 == 1, 0)
assert(output.stride.0 == 1, 0)
let output.s0.x.x.x.loop_extent = ((output.extent.0 + 959)/960)*((output.extent.1 + 67)/68)
produce output {
 let t9 = min((uint32)output_shift, (uint32)15)
 let t6 = (output.extent.0 + 959)/960
 let t10 = (output.min.1*output.stride.1) + output.min.0
 let t8 = (input2.min.1*input2.stride.1) + input2.min.0
 let t7 = (input1.min.1*input1.stride.1) + input1.min.0
 let parallel_closure = (void *)make_struct(input1, input2, output, input1.stride.1, input2.stride.1, output.extent.0, output.extent.1, output.min.0, output.min.1, output.stride.1, output_multiplier, t10, t6, t7, t8, t9, (uint8)input1_zero, (uint8)input2_zero, (uint8)output_max, (uint8)output_min, (uint8)output_zero)
 let closure_result = halide_do_par_for((void *)::mul_par_for_output_s0_x_x_x, 0, output.s0.x.x.x.loop_extent, (uint8_t *)(parallel_closure))
 assert(closure_result == 0, closure_result)
}
}


