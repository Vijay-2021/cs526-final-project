module name=l2norm, target=x86-64-noos-avx-avx2-avx512-avx512_skylake-f16c-fma-no_asserts-no_bounds_query-sse41
external func l2norm_par_for_output_s0_y_y (__user_context, output.s0.y.y, closure_arg) {
let closure_prototype = (void *)make_struct((void *)reinterpret((uint64)0), (void *)reinterpret((uint64)0), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint8)0)
let input = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 0)
let output = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 1)
let input.extent.0 = load_typed_struct_member((void *)closure_arg, closure_prototype, 2)
let input.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 3)
let output.extent.0 = load_typed_struct_member((void *)closure_arg, closure_prototype, 4)
let output.extent.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 5)
let output.min.0 = load_typed_struct_member((void *)closure_arg, closure_prototype, 6)
let output.min.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 7)
let output.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 8)
let t175 = load_typed_struct_member((void *)closure_arg, closure_prototype, 9)
let t176 = load_typed_struct_member((void *)closure_arg, closure_prototype, 10)
let t177 = load_typed_struct_member((void *)closure_arg, closure_prototype, 11)
let t178 = load_typed_struct_member((void *)closure_arg, closure_prototype, 12)
let input_zero = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 13)
let output.s0.y.yi.base.s = min(output.s0.y.y*34, output.extent.1 + -34)
allocate sum_input_sq[int32 * 48]
produce sum_input_sq {
 sum_input_sq[ramp(0, 1, 8)] = x8(0)
 sum_input_sq[ramp(8, 1, 8)] = x8(0)
 sum_input_sq[ramp(16, 1, 8)] = x8(0)
 sum_input_sq[ramp(24, 1, 8)] = x8(0)
 sum_input_sq[ramp(32, 1, 8)] = x8(0)
 let t180 = output.min.1 + output.s0.y.yi.base.s
 for (sum_input_sq.s1.r8$x.rebased, 0, input.extent.0) {
  let t181 = sum_input_sq.s1.r8$x.rebased + t175
  for (sum_input_sq.s1.y.yi.yi, 0, 2) {
   let t189 = input[ramp((((sum_input_sq.s1.y.yi.yi*8) + t180)*input.stride.1) + t181, input.stride.1, 8)]
   let t192 = (int16x8)widening_sub(t189, x8(input_zero))
   sum_input_sq[ramp(sum_input_sq.s1.y.yi.yi*8, 1, 8) aligned(8, 0)] = sum_input_sq[ramp(sum_input_sq.s1.y.yi.yi*8, 1, 8) aligned(8, 0)] + (int32x8)widening_mul(t192, t192)
  }
  let t182 = sum_input_sq.s1.r8$x.rebased + t175
  for (sum_input_sq.s1.y.yi.yi, 0, 2) {
   let t190 = input[ramp(((((sum_input_sq.s1.y.yi.yi*8) + t180) + 16)*input.stride.1) + t182, input.stride.1, 8)]
   let t193 = (int16x8)widening_sub(t190, x8(input_zero))
   sum_input_sq[ramp((sum_input_sq.s1.y.yi.yi*8) + 16, 1, 8) aligned(8, 0)] = sum_input_sq[ramp((sum_input_sq.s1.y.yi.yi*8) + 16, 1, 8) aligned(8, 0)] + (int32x8)widening_mul(t193, t193)
  }
  let t183 = sum_input_sq.s1.r8$x.rebased + t175
  for (sum_input_sq.s1.y.yi.yi, 0, 2) {
   let t145 = ramp(sum_input_sq.s1.y.yi.yi*8, 1, 8) <= x8(1)
   let t191 = input[ramp(((((sum_input_sq.s1.y.yi.yi*8) + t180) + 32)*input.stride.1) + t183, input.stride.1, 8)] if t145
   let t194 = (int16x8)widening_sub(t191, x8(input_zero))
   predicate (ramp(sum_input_sq.s1.y.yi.yi*8, 1, 8) <= x8(1))
    sum_input_sq[ramp((sum_input_sq.s1.y.yi.yi*8) + 32, 1, 8) aligned(8, 0)] = (sum_input_sq[ramp((sum_input_sq.s1.y.yi.yi*8) + 32, 1, 8) aligned(8, 0)] if t145) + (int32x8)widening_mul(t194, t194)
  }
 }
}
allocate inv_sqrt[int32 * 48]
produce inv_sqrt {
 consume sum_input_sq {
  for (inv_sqrt.s0.y.yi.yi, 0, 2) {
   let t147 = sum_input_sq[ramp(inv_sqrt.s0.y.yi.yi*8, 1, 8) aligned(8, 0)]
   let t148 = int16x8((int32x8)count_leading_zeros(t147))
   let t149 = (int16x8)bitwise_and(int16x8((int32x8)shift_left(t147, int32x8((t148 + x8((int16)-16))))), x8((int16)32767))
   let t150 = (int16x8)rounding_mul_shift_right(t149, t149, x8((uint16)15))
   let t152 = (int32x8)shift_left(x8(1), (int32x8)shift_right(x8(0) - (int32x8)saturating_add((int32x8)widening_shift_left(x8((int16)31) - t148, x8((uint16)14)), int32x8((((int16x8)rounding_mul_shift_right(x8((int16)-9421), t150, x8((uint16)15)) + ((int16x8)rounding_mul_shift_right(x8((int16)2555), (int16x8)rounding_mul_shift_right(t150, t149, x8((uint16)15)), x8((uint16)15)) + (int16x8)rounding_mul_shift_right(x8((int16)23249), t149, x8((uint16)15)))) + x8((int16)5)))), x8((uint32)15)) + x8(15))
   let t153 = int16x8(((x8(0) - (int32x8)saturating_add((int32x8)widening_shift_left(x8((int16)31) - t148, x8((uint16)14)), int32x8((((int16x8)rounding_mul_shift_right(x8((int16)-9421), t150, x8((uint16)15)) + ((int16x8)rounding_mul_shift_right(x8((int16)2555), (int16x8)rounding_mul_shift_right(t150, t149, x8((uint16)15)), x8((uint16)15)) + (int16x8)rounding_mul_shift_right(x8((int16)23249), t149, x8((uint16)15)))) + x8((int16)5))))) % x8(32768)))
   let t154 = (int16x8)rounding_mul_shift_right(t153, t153, x8((uint16)15))
   inv_sqrt[ramp(inv_sqrt.s0.y.yi.yi*8, 1, 8) aligned(8, 0)] = (int32x8)saturating_add(t152, (int32x8)rounding_mul_shift_right(t152, (int32x8)widening_shift_left((int16x8)rounding_mul_shift_right(x8((int16)7363), t154, x8((uint16)15)) + ((int16x8)rounding_mul_shift_right(x8((int16)22812), t153, x8((uint16)15)) + (int16x8)rounding_mul_shift_right(x8((int16)2592), (int16x8)rounding_mul_shift_right(t154, t153, x8((uint16)15)), x8((uint16)15))), x8((uint16)16)), x8((uint32)31)))
  }
  for (inv_sqrt.s0.y.yi.yi, 0, 2) {
   let t155 = sum_input_sq[ramp((inv_sqrt.s0.y.yi.yi*8) + 16, 1, 8) aligned(8, 0)]
   let t156 = int16x8((int32x8)count_leading_zeros(t155))
   let t157 = (int16x8)bitwise_and(int16x8((int32x8)shift_left(t155, int32x8((t156 + x8((int16)-16))))), x8((int16)32767))
   let t158 = (int16x8)rounding_mul_shift_right(t157, t157, x8((uint16)15))
   let t160 = (int32x8)shift_left(x8(1), (int32x8)shift_right(x8(0) - (int32x8)saturating_add((int32x8)widening_shift_left(x8((int16)31) - t156, x8((uint16)14)), int32x8((((int16x8)rounding_mul_shift_right(x8((int16)-9421), t158, x8((uint16)15)) + ((int16x8)rounding_mul_shift_right(x8((int16)2555), (int16x8)rounding_mul_shift_right(t158, t157, x8((uint16)15)), x8((uint16)15)) + (int16x8)rounding_mul_shift_right(x8((int16)23249), t157, x8((uint16)15)))) + x8((int16)5)))), x8((uint32)15)) + x8(15))
   let t161 = int16x8(((x8(0) - (int32x8)saturating_add((int32x8)widening_shift_left(x8((int16)31) - t156, x8((uint16)14)), int32x8((((int16x8)rounding_mul_shift_right(x8((int16)-9421), t158, x8((uint16)15)) + ((int16x8)rounding_mul_shift_right(x8((int16)2555), (int16x8)rounding_mul_shift_right(t158, t157, x8((uint16)15)), x8((uint16)15)) + (int16x8)rounding_mul_shift_right(x8((int16)23249), t157, x8((uint16)15)))) + x8((int16)5))))) % x8(32768)))
   let t162 = (int16x8)rounding_mul_shift_right(t161, t161, x8((uint16)15))
   inv_sqrt[ramp((inv_sqrt.s0.y.yi.yi*8) + 16, 1, 8) aligned(8, 0)] = (int32x8)saturating_add(t160, (int32x8)rounding_mul_shift_right(t160, (int32x8)widening_shift_left((int16x8)rounding_mul_shift_right(x8((int16)7363), t162, x8((uint16)15)) + ((int16x8)rounding_mul_shift_right(x8((int16)22812), t161, x8((uint16)15)) + (int16x8)rounding_mul_shift_right(x8((int16)2592), (int16x8)rounding_mul_shift_right(t162, t161, x8((uint16)15)), x8((uint16)15))), x8((uint16)16)), x8((uint32)31)))
  }
  for (inv_sqrt.s0.y.yi.yi, 0, 2) {
   let t163 = sum_input_sq[ramp((inv_sqrt.s0.y.yi.yi*8) + 32, 1, 8) aligned(8, 0)]
   let t164 = int16x8((int32x8)count_leading_zeros(t163))
   let t165 = (int16x8)bitwise_and(int16x8((int32x8)shift_left(t163, int32x8((t164 + x8((int16)-16))))), x8((int16)32767))
   let t166 = (int16x8)rounding_mul_shift_right(t165, t165, x8((uint16)15))
   let t168 = (int32x8)shift_left(x8(1), (int32x8)shift_right(x8(0) - (int32x8)saturating_add((int32x8)widening_shift_left(x8((int16)31) - t164, x8((uint16)14)), int32x8((((int16x8)rounding_mul_shift_right(x8((int16)-9421), t166, x8((uint16)15)) + ((int16x8)rounding_mul_shift_right(x8((int16)2555), (int16x8)rounding_mul_shift_right(t166, t165, x8((uint16)15)), x8((uint16)15)) + (int16x8)rounding_mul_shift_right(x8((int16)23249), t165, x8((uint16)15)))) + x8((int16)5)))), x8((uint32)15)) + x8(15))
   let t169 = int16x8(((x8(0) - (int32x8)saturating_add((int32x8)widening_shift_left(x8((int16)31) - t164, x8((uint16)14)), int32x8((((int16x8)rounding_mul_shift_right(x8((int16)-9421), t166, x8((uint16)15)) + ((int16x8)rounding_mul_shift_right(x8((int16)2555), (int16x8)rounding_mul_shift_right(t166, t165, x8((uint16)15)), x8((uint16)15)) + (int16x8)rounding_mul_shift_right(x8((int16)23249), t165, x8((uint16)15)))) + x8((int16)5))))) % x8(32768)))
   let t170 = (int16x8)rounding_mul_shift_right(t169, t169, x8((uint16)15))
   inv_sqrt[ramp((inv_sqrt.s0.y.yi.yi*8) + 32, 1, 8) aligned(8, 0)] = (int32x8)saturating_add(t168, (int32x8)rounding_mul_shift_right(t168, (int32x8)widening_shift_left((int16x8)rounding_mul_shift_right(x8((int16)7363), t170, x8((uint16)15)) + ((int16x8)rounding_mul_shift_right(x8((int16)22812), t169, x8((uint16)15)) + (int16x8)rounding_mul_shift_right(x8((int16)2592), (int16x8)rounding_mul_shift_right(t170, t169, x8((uint16)15)), x8((uint16)15))), x8((uint16)16)), x8((uint32)31)))
  }
  free sum_input_sq
 }
}
consume inv_sqrt {
 let t184 = output.min.1 + output.s0.y.yi.base.s
 for (output.s0.y.yi, 0, 34) {
  let t185 = output.s0.y.yi + t184
  for (output.s0.x.x, 0, t176) {
   let output.s0.x.xi.base.s = min(output.s0.x.x*32, output.extent.0 + -32)
   let t188 = (output.stride.1*t185) - t178
   let t187 = (input.stride.1*t185) - t177
   let t186 = output.min.0 + output.s0.x.xi.base.s
   for (output.s0.x.xi.xi, 0, 4) {
    let t172 = (output.s0.x.xi.xi*8) + t186
    output[ramp(t172 + t188, 1, 8)] = uint8x8(max(min((int16x8)saturating_add(int16x8(max(min((int32x8)rounding_shift_right(int32x8((int16x8)widening_sub(input[ramp(t172 + t187, 1, 8)], x8(input_zero)))*x8(inv_sqrt[output.s0.y.yi]), x8((uint32)8)), x8(32767)), x8(-32768))), x8((int16)128)), x8((int16)255)), x8((int16)0)))
   }
  }
 }
}
free inv_sqrt
}


external_plus_metadata func l2norm (input, input_zero, output) {
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(input.stride.0 == 1, 0)
assert(output.stride.0 == 1, 0)
produce output {
 let t179 = input.min.1*input.stride.1
 let t174 = (output.extent.1 + 33)/34
 let t176 = (output.extent.0 + 31)/32
 let t175 = 0 - t179
 let t178 = (output.min.1*output.stride.1) + output.min.0
 let t177 = input.min.0 + t179
 let parallel_closure = (void *)make_struct(input, output, input.extent.0, input.stride.1, output.extent.0, output.extent.1, output.min.0, output.min.1, output.stride.1, t175, t176, t177, t178, (uint8)input_zero)
 let closure_result = halide_do_par_for((void *)::l2norm_par_for_output_s0_y_y, 0, t174, (uint8_t *)(parallel_closure))
 assert(closure_result == 0, closure_result)
}
}


