module name=fully_connected, target=x86-64-noos-avx-avx2-avx512-avx512_skylake-f16c-fma-no_asserts-no_bounds_query-sse41
external func fully_connected_par_for_output_s0_c_c_c (__user_context, output.s0.c.c.c, closure_arg) {
let closure_prototype = (void *)make_struct((void *)reinterpret((uint64)0), (void *)reinterpret((uint64)0), (void *)reinterpret((uint64)0), (void *)reinterpret((uint64)0), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint8)0, (uint8)0, (uint8)0, (uint8)0, (uint8)0)
let bias = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 0)
let filter = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 1)
let input = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 2)
let output = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 3)
let bias.min.0 = load_typed_struct_member((void *)closure_arg, closure_prototype, 4)
let filter.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 5)
let input.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 6)
let output.extent.0 = load_typed_struct_member((void *)closure_arg, closure_prototype, 7)
let output.extent.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 8)
let output.min.0 = load_typed_struct_member((void *)closure_arg, closure_prototype, 9)
let output.min.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 10)
let output.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 11)
let output_multiplier = load_typed_struct_member((void *)closure_arg, closure_prototype, 12)
let output_shift = load_typed_struct_member((void *)closure_arg, closure_prototype, 13)
let t72 = load_typed_struct_member((void *)closure_arg, closure_prototype, 14)
let t73 = load_typed_struct_member((void *)closure_arg, closure_prototype, 15)
let t74 = load_typed_struct_member((void *)closure_arg, closure_prototype, 16)
let t75 = load_typed_struct_member((void *)closure_arg, closure_prototype, 17)
let t76 = load_typed_struct_member((void *)closure_arg, closure_prototype, 18)
let filter_zero = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 19)
let input_zero = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 20)
let output_max = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 21)
let output_min = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 22)
let output_zero = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 23)
let output.s0.c.ci.base.s = min((output.s0.c.c.c % t72)*480, output.extent.0 + -480)
let output.s0.b.bi.base.s = min((output.s0.c.c.c/t72)*9, output.extent.1 + -9)
let t97 = output.min.1 + output.s0.b.bi.base.s
let t98 = t97 + 1
let t99 = t97 + 2
let t100 = t97 + 3
let t101 = t97 + 4
let t102 = t97 + 5
let t103 = t97 + 6
let t104 = t97 + 7
let t105 = t97 + 8
let t87 = (input.stride.1*t105) - t75
let t86 = (input.stride.1*t104) - t75
let t85 = (input.stride.1*t103) - t75
let t84 = (input.stride.1*t102) - t75
let t83 = (input.stride.1*t101) - t75
let t82 = (input.stride.1*t100) - t75
let t81 = (input.stride.1*t99) - t75
let t80 = (input.stride.1*t98) - t75
let t79 = (input.stride.1*t97) - t75
let t96 = ((output.stride.1*t105) + t76) + output.s0.c.ci.base.s
let t95 = ((output.stride.1*t104) + t76) + output.s0.c.ci.base.s
let t94 = ((output.stride.1*t103) + t76) + output.s0.c.ci.base.s
let t93 = ((output.stride.1*t102) + t76) + output.s0.c.ci.base.s
let t92 = ((output.stride.1*t101) + t76) + output.s0.c.ci.base.s
let t91 = ((output.stride.1*t100) + t76) + output.s0.c.ci.base.s
let t90 = ((output.stride.1*t99) + t76) + output.s0.c.ci.base.s
let t89 = ((output.stride.1*t98) + t76) + output.s0.c.ci.base.s
let t88 = ((output.stride.1*t97) + t76) + output.s0.c.ci.base.s
let t78 = output.s0.c.ci.base.s + t74
let t77 = output.min.0 + output.s0.c.ci.base.s
for (output.s0.c.ci.ci, 0, 15) {
 allocate multiplied[int32 * 288] in Stack
 produce multiplied {
  let t106 = (output.s0.c.ci.ci*32) + t77
  for (multiplied.s0.b.rebased, 0, 9) {
   let t107 = multiplied.s0.b.rebased*4
   for (multiplied.s0.c.c, 0, 4) {
    let multiplied.s0.c.ci.base = (multiplied.s0.c.c*8) + t106
    multiplied[ramp((multiplied.s0.c.c + t107)*8, 1, 8) aligned(8, 0)] = bias[ramp(multiplied.s0.c.ci.base - bias.min.0, 1, 8)]
   }
  }
  let t108 = (output.s0.c.ci.ci*32) + t78
  for (multiplied.s1.r9$x, 0, t73) {
   let t109 = multiplied.s1.r9$x + t79
   for (multiplied.s1.c.ci.ci, 0, 4) {
    multiplied[ramp(multiplied.s1.c.ci.ci*8, 1, 8) aligned(8, 0)] = multiplied[ramp(multiplied.s1.c.ci.ci*8, 1, 8) aligned(8, 0)] + (int32x8)widening_mul((int16x8)widening_sub(filter[ramp((((multiplied.s1.c.ci.ci*8) + t108)*filter.stride.1) + multiplied.s1.r9$x, filter.stride.1, 8)], x8(filter_zero)), x8(int16(input[t109]) - int16(input_zero)))
   }
   let t110 = multiplied.s1.r9$x + t80
   for (multiplied.s1.c.ci.ci, 0, 4) {
    multiplied[ramp((multiplied.s1.c.ci.ci*8) + 32, 1, 8) aligned(8, 0)] = multiplied[ramp((multiplied.s1.c.ci.ci*8) + 32, 1, 8) aligned(8, 0)] + (int32x8)widening_mul((int16x8)widening_sub(filter[ramp((((multiplied.s1.c.ci.ci*8) + t108)*filter.stride.1) + multiplied.s1.r9$x, filter.stride.1, 8)], x8(filter_zero)), x8(int16(input[t110]) - int16(input_zero)))
   }
   let t111 = multiplied.s1.r9$x + t81
   for (multiplied.s1.c.ci.ci, 0, 4) {
    multiplied[ramp((multiplied.s1.c.ci.ci*8) + 64, 1, 8) aligned(8, 0)] = multiplied[ramp((multiplied.s1.c.ci.ci*8) + 64, 1, 8) aligned(8, 0)] + (int32x8)widening_mul((int16x8)widening_sub(filter[ramp((((multiplied.s1.c.ci.ci*8) + t108)*filter.stride.1) + multiplied.s1.r9$x, filter.stride.1, 8)], x8(filter_zero)), x8(int16(input[t111]) - int16(input_zero)))
   }
   let t112 = multiplied.s1.r9$x + t82
   for (multiplied.s1.c.ci.ci, 0, 4) {
    multiplied[ramp((multiplied.s1.c.ci.ci*8) + 96, 1, 8) aligned(8, 0)] = multiplied[ramp((multiplied.s1.c.ci.ci*8) + 96, 1, 8) aligned(8, 0)] + (int32x8)widening_mul((int16x8)widening_sub(filter[ramp((((multiplied.s1.c.ci.ci*8) + t108)*filter.stride.1) + multiplied.s1.r9$x, filter.stride.1, 8)], x8(filter_zero)), x8(int16(input[t112]) - int16(input_zero)))
   }
   let t113 = multiplied.s1.r9$x + t83
   for (multiplied.s1.c.ci.ci, 0, 4) {
    multiplied[ramp((multiplied.s1.c.ci.ci*8) + 128, 1, 8) aligned(8, 0)] = multiplied[ramp((multiplied.s1.c.ci.ci*8) + 128, 1, 8) aligned(8, 0)] + (int32x8)widening_mul((int16x8)widening_sub(filter[ramp((((multiplied.s1.c.ci.ci*8) + t108)*filter.stride.1) + multiplied.s1.r9$x, filter.stride.1, 8)], x8(filter_zero)), x8(int16(input[t113]) - int16(input_zero)))
   }
   let t114 = multiplied.s1.r9$x + t84
   for (multiplied.s1.c.ci.ci, 0, 4) {
    multiplied[ramp((multiplied.s1.c.ci.ci*8) + 160, 1, 8) aligned(8, 0)] = multiplied[ramp((multiplied.s1.c.ci.ci*8) + 160, 1, 8) aligned(8, 0)] + (int32x8)widening_mul((int16x8)widening_sub(filter[ramp((((multiplied.s1.c.ci.ci*8) + t108)*filter.stride.1) + multiplied.s1.r9$x, filter.stride.1, 8)], x8(filter_zero)), x8(int16(input[t114]) - int16(input_zero)))
   }
   let t115 = multiplied.s1.r9$x + t85
   for (multiplied.s1.c.ci.ci, 0, 4) {
    multiplied[ramp((multiplied.s1.c.ci.ci*8) + 192, 1, 8) aligned(8, 0)] = multiplied[ramp((multiplied.s1.c.ci.ci*8) + 192, 1, 8) aligned(8, 0)] + (int32x8)widening_mul((int16x8)widening_sub(filter[ramp((((multiplied.s1.c.ci.ci*8) + t108)*filter.stride.1) + multiplied.s1.r9$x, filter.stride.1, 8)], x8(filter_zero)), x8(int16(input[t115]) - int16(input_zero)))
   }
   let t116 = multiplied.s1.r9$x + t86
   for (multiplied.s1.c.ci.ci, 0, 4) {
    multiplied[ramp((multiplied.s1.c.ci.ci*8) + 224, 1, 8) aligned(8, 0)] = multiplied[ramp((multiplied.s1.c.ci.ci*8) + 224, 1, 8) aligned(8, 0)] + (int32x8)widening_mul((int16x8)widening_sub(filter[ramp((((multiplied.s1.c.ci.ci*8) + t108)*filter.stride.1) + multiplied.s1.r9$x, filter.stride.1, 8)], x8(filter_zero)), x8(int16(input[t116]) - int16(input_zero)))
   }
   let t117 = multiplied.s1.r9$x + t87
   for (multiplied.s1.c.ci.ci, 0, 4) {
    multiplied[ramp((multiplied.s1.c.ci.ci*8) + 256, 1, 8) aligned(8, 0)] = multiplied[ramp((multiplied.s1.c.ci.ci*8) + 256, 1, 8) aligned(8, 0)] + (int32x8)widening_mul((int16x8)widening_sub(filter[ramp((((multiplied.s1.c.ci.ci*8) + t108)*filter.stride.1) + multiplied.s1.r9$x, filter.stride.1, 8)], x8(filter_zero)), x8(int16(input[t117]) - int16(input_zero)))
   }
  }
 }
 consume multiplied {
  let t118 = output.s0.c.ci.ci*4
  for (output.s0.c.ci.cii.cii, 0, 4) {
   output[ramp(((output.s0.c.ci.cii.cii + t118)*8) + t88, 1, 8)] = max(min(uint8x8(max(min((int16x8)saturating_add(int16x8(max(min((int32x8)rounding_shift_right((int32x8)rounding_mul_shift_right(multiplied[ramp(output.s0.c.ci.cii.cii*8, 1, 8) aligned(8, 0)], x8(output_multiplier), x8((uint32)31)), x8(output_shift)), x8(32767)), x8(-32768))), x8(int16(output_zero))), x8((int16)255)), x8((int16)0))), x8(output_max)), x8(output_min))
  }
  let t119 = output.s0.c.ci.ci*4
  for (output.s0.c.ci.cii.cii, 0, 4) {
   output[ramp(((output.s0.c.ci.cii.cii + t119)*8) + t89, 1, 8)] = max(min(uint8x8(max(min((int16x8)saturating_add(int16x8(max(min((int32x8)rounding_shift_right((int32x8)rounding_mul_shift_right(multiplied[ramp((output.s0.c.ci.cii.cii*8) + 32, 1, 8) aligned(8, 0)], x8(output_multiplier), x8((uint32)31)), x8(output_shift)), x8(32767)), x8(-32768))), x8(int16(output_zero))), x8((int16)255)), x8((int16)0))), x8(output_max)), x8(output_min))
  }
  let t120 = output.s0.c.ci.ci*4
  for (output.s0.c.ci.cii.cii, 0, 4) {
   output[ramp(((output.s0.c.ci.cii.cii + t120)*8) + t90, 1, 8)] = max(min(uint8x8(max(min((int16x8)saturating_add(int16x8(max(min((int32x8)rounding_shift_right((int32x8)rounding_mul_shift_right(multiplied[ramp((output.s0.c.ci.cii.cii*8) + 64, 1, 8) aligned(8, 0)], x8(output_multiplier), x8((uint32)31)), x8(output_shift)), x8(32767)), x8(-32768))), x8(int16(output_zero))), x8((int16)255)), x8((int16)0))), x8(output_max)), x8(output_min))
  }
  let t121 = output.s0.c.ci.ci*4
  for (output.s0.c.ci.cii.cii, 0, 4) {
   output[ramp(((output.s0.c.ci.cii.cii + t121)*8) + t91, 1, 8)] = max(min(uint8x8(max(min((int16x8)saturating_add(int16x8(max(min((int32x8)rounding_shift_right((int32x8)rounding_mul_shift_right(multiplied[ramp((output.s0.c.ci.cii.cii*8) + 96, 1, 8) aligned(8, 0)], x8(output_multiplier), x8((uint32)31)), x8(output_shift)), x8(32767)), x8(-32768))), x8(int16(output_zero))), x8((int16)255)), x8((int16)0))), x8(output_max)), x8(output_min))
  }
  let t122 = output.s0.c.ci.ci*4
  for (output.s0.c.ci.cii.cii, 0, 4) {
   output[ramp(((output.s0.c.ci.cii.cii + t122)*8) + t92, 1, 8)] = max(min(uint8x8(max(min((int16x8)saturating_add(int16x8(max(min((int32x8)rounding_shift_right((int32x8)rounding_mul_shift_right(multiplied[ramp((output.s0.c.ci.cii.cii*8) + 128, 1, 8) aligned(8, 0)], x8(output_multiplier), x8((uint32)31)), x8(output_shift)), x8(32767)), x8(-32768))), x8(int16(output_zero))), x8((int16)255)), x8((int16)0))), x8(output_max)), x8(output_min))
  }
  let t123 = output.s0.c.ci.ci*4
  for (output.s0.c.ci.cii.cii, 0, 4) {
   output[ramp(((output.s0.c.ci.cii.cii + t123)*8) + t93, 1, 8)] = max(min(uint8x8(max(min((int16x8)saturating_add(int16x8(max(min((int32x8)rounding_shift_right((int32x8)rounding_mul_shift_right(multiplied[ramp((output.s0.c.ci.cii.cii*8) + 160, 1, 8) aligned(8, 0)], x8(output_multiplier), x8((uint32)31)), x8(output_shift)), x8(32767)), x8(-32768))), x8(int16(output_zero))), x8((int16)255)), x8((int16)0))), x8(output_max)), x8(output_min))
  }
  let t124 = output.s0.c.ci.ci*4
  for (output.s0.c.ci.cii.cii, 0, 4) {
   output[ramp(((output.s0.c.ci.cii.cii + t124)*8) + t94, 1, 8)] = max(min(uint8x8(max(min((int16x8)saturating_add(int16x8(max(min((int32x8)rounding_shift_right((int32x8)rounding_mul_shift_right(multiplied[ramp((output.s0.c.ci.cii.cii*8) + 192, 1, 8) aligned(8, 0)], x8(output_multiplier), x8((uint32)31)), x8(output_shift)), x8(32767)), x8(-32768))), x8(int16(output_zero))), x8((int16)255)), x8((int16)0))), x8(output_max)), x8(output_min))
  }
  let t125 = output.s0.c.ci.ci*4
  for (output.s0.c.ci.cii.cii, 0, 4) {
   output[ramp(((output.s0.c.ci.cii.cii + t125)*8) + t95, 1, 8)] = max(min(uint8x8(max(min((int16x8)saturating_add(int16x8(max(min((int32x8)rounding_shift_right((int32x8)rounding_mul_shift_right(multiplied[ramp((output.s0.c.ci.cii.cii*8) + 224, 1, 8) aligned(8, 0)], x8(output_multiplier), x8((uint32)31)), x8(output_shift)), x8(32767)), x8(-32768))), x8(int16(output_zero))), x8((int16)255)), x8((int16)0))), x8(output_max)), x8(output_min))
  }
  let t126 = output.s0.c.ci.ci*4
  for (output.s0.c.ci.cii.cii, 0, 4) {
   output[ramp(((output.s0.c.ci.cii.cii + t126)*8) + t96, 1, 8)] = max(min(uint8x8(max(min((int16x8)saturating_add(int16x8(max(min((int32x8)rounding_shift_right((int32x8)rounding_mul_shift_right(multiplied[ramp((output.s0.c.ci.cii.cii*8) + 256, 1, 8) aligned(8, 0)], x8(output_multiplier), x8((uint32)31)), x8(output_shift)), x8(32767)), x8(-32768))), x8(int16(output_zero))), x8((int16)255)), x8((int16)0))), x8(output_max)), x8(output_min))
  }
  free multiplied
 }
}
}


external_plus_metadata func fully_connected (input, input_zero, filter, filter_zero, bias, output_zero, output_multiplier, output_shift, output_min, output_max, output) {
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
assert((uint64)reinterpret((halide_buffer_t *)filter.buffer) != (uint64)0, halide_error_buffer_argument_is_null("filter"))
assert((uint64)reinterpret((halide_buffer_t *)bias.buffer) != (uint64)0, halide_error_buffer_argument_is_null("bias"))
let bias = (void *)_halide_buffer_get_host((halide_buffer_t *)bias.buffer)
let bias.min.0 = _halide_buffer_get_min((halide_buffer_t *)bias.buffer, 0)
let bias.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)bias.buffer, 0)
let filter = (void *)_halide_buffer_get_host((halide_buffer_t *)filter.buffer)
let filter.min.0 = _halide_buffer_get_min((halide_buffer_t *)filter.buffer, 0)
let filter.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)filter.buffer, 0)
let filter.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)filter.buffer, 0)
let filter.min.1 = _halide_buffer_get_min((halide_buffer_t *)filter.buffer, 1)
let filter.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)filter.buffer, 1)
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(bias.stride.0 == 1, 0)
assert(filter.stride.0 == 1, 0)
assert(filter.min.0 == 0, 0)
assert(input.stride.0 == 1, 0)
assert(output.stride.0 == 1, 0)
let output.s0.c.c.c.loop_extent = ((output.extent.0 + 479)/480)*((output.extent.1 + 8)/9)
produce output {
 let t72 = (output.extent.0 + 479)/480
 let t73 = (filter.extent.0/64)*64
 let t74 = output.min.0 - filter.min.1
 let t76 = 0 - (output.min.1*output.stride.1)
 let t75 = (input.min.1*input.stride.1) + input.min.0
 let parallel_closure = (void *)make_struct(bias, filter, input, output, bias.min.0, filter.stride.1, input.stride.1, output.extent.0, output.extent.1, output.min.0, output.min.1, output.stride.1, output_multiplier, output_shift, t72, t73, t74, t75, t76, (uint8)filter_zero, (uint8)input_zero, (uint8)output_max, (uint8)output_min, (uint8)output_zero)
 let closure_result = halide_do_par_for((void *)::fully_connected_par_for_output_s0_c_c_c, 0, output.s0.c.c.c.loop_extent, (uint8_t *)(parallel_closure))
 assert(closure_result == 0, closure_result)
}
}


