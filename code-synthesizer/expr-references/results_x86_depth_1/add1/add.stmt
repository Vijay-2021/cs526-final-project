module name=add, target=x86-64-noos-avx-avx2-avx512-avx512_skylake-f16c-fma-no_asserts-no_bounds_query-sse41
external func add_par_for_output_s0_x_x_x (__user_context, output.s0.x.x.x, closure_arg) {
let closure_prototype = (void *)make_struct((void *)reinterpret((uint64)0), (void *)reinterpret((uint64)0), (void *)reinterpret((uint64)0), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (int16)0, (int16)0, (uint8)0, (uint8)0, (uint8)0, (uint8)0, (uint8)0)
let input1 = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 0)
let input2 = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 1)
let output = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 2)
let input1.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 3)
let input2.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 4)
let output.extent.0 = load_typed_struct_member((void *)closure_arg, closure_prototype, 5)
let output.extent.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 6)
let output.min.0 = load_typed_struct_member((void *)closure_arg, closure_prototype, 7)
let output.min.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 8)
let output.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 9)
let t6 = load_typed_struct_member((void *)closure_arg, closure_prototype, 10)
let t7 = load_typed_struct_member((void *)closure_arg, closure_prototype, 11)
let t8 = load_typed_struct_member((void *)closure_arg, closure_prototype, 12)
let t9 = load_typed_struct_member((void *)closure_arg, closure_prototype, 13)
let input1_multiplier = (int16)load_typed_struct_member((void *)closure_arg, closure_prototype, 14)
let input2_multiplier = (int16)load_typed_struct_member((void *)closure_arg, closure_prototype, 15)
let input1_zero = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 16)
let input2_zero = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 17)
let output_max = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 18)
let output_min = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 19)
let output_zero = (uint8)load_typed_struct_member((void *)closure_arg, closure_prototype, 20)
let output.s0.x.xi.base.s = min((output.s0.x.x.x % t6)*960, output.extent.0 + -960)
let output.s0.y.yi.base.s = min((output.s0.x.x.x/t6)*34, output.extent.1 + -34)
let t11 = output.min.1 + output.s0.y.yi.base.s
let t10 = output.min.0 + output.s0.x.xi.base.s
for (output.s0.y.yi, 0, 34) {
 let t12 = output.s0.y.yi + t11
 for (output.s0.x.xi.xi, 0, 30) {
  let t13 = output.s0.x.xi.xi*2
  let t16 = (output.stride.1*t12) - t9
  let t15 = (input2.stride.1*t12) - t8
  let t14 = (input1.stride.1*t12) - t7
  for (output.s0.x.xi.xii.xii, 0, 2) {
   let t4 = ((output.s0.x.xi.xii.xii + t13)*16) + t10
   output[ramp(t16 + t4, 1, 16)] = max(min(uint8x16(max(min((int16x16)saturating_add(int16x16(max(min((int32x16)rounding_shift_right((int32x16)widening_mul((int16x16)shift_left(int16x16(input1[ramp(t14 + t4, 1, 16)]), x16((uint16)6)) + x16(int16(input1_zero)*(int16)-64), x16(input1_multiplier)) + (int32x16)widening_mul((int16x16)shift_left(int16x16(input2[ramp(t15 + t4, 1, 16)]), x16((uint16)6)) + x16(int16(input2_zero)*(int16)-64), x16(input2_multiplier)), x16((uint32)16)), x16(32767)), x16(-32768))), x16(int16(output_zero))), x16((int16)255)), x16((int16)0))), x16(output_max)), x16(output_min))
  }
 }
}
}


external_plus_metadata func add (input1, input1_zero, input1_multiplier, input2, input2_zero, input2_multiplier, output_zero, output_min, output_max, output) {
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input2.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input2"))
assert((uint64)reinterpret((halide_buffer_t *)input1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input1"))
let input1 = (void *)_halide_buffer_get_host((halide_buffer_t *)input1.buffer)
let input1.min.0 = _halide_buffer_get_min((halide_buffer_t *)input1.buffer, 0)
let input1.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input1.buffer, 0)
let input1.min.1 = _halide_buffer_get_min((halide_buffer_t *)input1.buffer, 1)
let input1.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input1.buffer, 1)
let input2 = (void *)_halide_buffer_get_host((halide_buffer_t *)input2.buffer)
let input2.min.0 = _halide_buffer_get_min((halide_buffer_t *)input2.buffer, 0)
let input2.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input2.buffer, 0)
let input2.min.1 = _halide_buffer_get_min((halide_buffer_t *)input2.buffer, 1)
let input2.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input2.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(input1.stride.0 == 1, 0)
assert(input2.stride.0 == 1, 0)
assert(output.stride.0 == 1, 0)
let output.s0.x.x.x.loop_extent = ((output.extent.0 + 959)/960)*((output.extent.1 + 33)/34)
produce output {
 let t6 = (output.extent.0 + 959)/960
 let t9 = (output.min.1*output.stride.1) + output.min.0
 let t8 = (input2.min.1*input2.stride.1) + input2.min.0
 let t7 = (input1.min.1*input1.stride.1) + input1.min.0
 let parallel_closure = (void *)make_struct(input1, input2, output, input1.stride.1, input2.stride.1, output.extent.0, output.extent.1, output.min.0, output.min.1, output.stride.1, t6, t7, t8, t9, (int16)input1_multiplier, (int16)input2_multiplier, (uint8)input1_zero, (uint8)input2_zero, (uint8)output_max, (uint8)output_min, (uint8)output_zero)
 let closure_result = halide_do_par_for((void *)::add_par_for_output_s0_x_x_x, 0, output.s0.x.x.x.loop_extent, (uint8_t *)(parallel_closure))
 assert(closure_result == 0, closure_result)
}
}


