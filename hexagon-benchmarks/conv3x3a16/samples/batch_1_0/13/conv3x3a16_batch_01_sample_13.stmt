module name=conv3x3a16_batch_01_sample_13, target=x86-64-linux-avx-avx2-avx512-avx512_skylake-disable_llvm_loop_unroll-disable_llvm_loop_vectorize-f16c-fma-sse41
external_plus_metadata func conv3x3a16_batch_01_sample_13 (input, mask, output) {
assert((reinterpret(uint64, output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output"))
assert((reinterpret(uint64, mask.buffer) != (uint64)0), halide_error_buffer_argument_is_null("mask"))
assert((reinterpret(uint64, input.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input"))
let input = _halide_buffer_get_host(input.buffer)
let input.type = _halide_buffer_get_type(input.buffer)
let input.dimensions = _halide_buffer_get_dimensions(input.buffer)
let input.min.0 = _halide_buffer_get_min(input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent(input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride(input.buffer, 0)
let input.min.1 = _halide_buffer_get_min(input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent(input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride(input.buffer, 1)
let mask = _halide_buffer_get_host(mask.buffer)
let mask.type = _halide_buffer_get_type(mask.buffer)
let mask.dimensions = _halide_buffer_get_dimensions(mask.buffer)
let mask.min.0 = _halide_buffer_get_min(mask.buffer, 0)
let mask.extent.0 = _halide_buffer_get_extent(mask.buffer, 0)
let mask.stride.0 = _halide_buffer_get_stride(mask.buffer, 0)
let mask.min.1 = _halide_buffer_get_min(mask.buffer, 1)
let mask.extent.1 = _halide_buffer_get_extent(mask.buffer, 1)
let mask.stride.1 = _halide_buffer_get_stride(mask.buffer, 1)
let output = _halide_buffer_get_host(output.buffer)
let output.type = _halide_buffer_get_type(output.buffer)
let output.dimensions = _halide_buffer_get_dimensions(output.buffer)
let output.min.0 = _halide_buffer_get_min(output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent(output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride(output.buffer, 0)
let output.min.1 = _halide_buffer_get_min(output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent(output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride(output.buffer, 1)
let input.extent.0.required.s = (max(min(((input.extent.0 + input.min.0) + -1), output.extent.0), input.min.0) - max((min(min(((input.extent.0 + input.min.0) + 62), output.extent.0), 62) + -63), input.min.0))
let input.min.0.required = max((min(min(((input.extent.0 + input.min.0) + 62), output.extent.0), 62) + -63), input.min.0)
let input.extent.1.required.s = (max(min(((input.extent.1 + input.min.1) + -1), output.extent.1), input.min.1) - max((min((input.extent.1 + input.min.1), 0) + -1), input.min.1))
let input.min.1.required = max((min((input.extent.1 + input.min.1), 0) + -1), input.min.1)
assert((!_halide_buffer_is_bounds_query(input.buffer) || ((0 <= input.min.0.required) && (input.min.0.required <= 0))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, input.extent.0.required.s, input.min.0.required, (input.extent.0.required.s + input.min.0.required)))
assert((!_halide_buffer_is_bounds_query(input.buffer) || ((0 <= input.min.1.required) && (input.min.1.required <= 0))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, input.extent.1.required.s, input.min.1.required, (input.extent.1.required.s + input.min.1.required)))
assert((!_halide_buffer_is_bounds_query(output.buffer) || (64 <= output.extent.0)), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, 0, 63, (output.extent.0 + -64), (output.extent.0 + -1)))
assert((!_halide_buffer_is_bounds_query(output.buffer) || (32 <= output.extent.1)), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, 0, 31, (output.extent.1 + -32), (output.extent.1 + -1)))
if (_halide_buffer_is_bounds_query(input.buffer)) {
  _halide_buffer_init(input.buffer, _halide_buffer_get_shape(input.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 2, make_struct((halide_dimension_t *), 0, (input.extent.0.required.s + 1), 1, 0, 0, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1), 0), (uint64)0)
}
if (_halide_buffer_is_bounds_query(mask.buffer)) {
  _halide_buffer_init(mask.buffer, _halide_buffer_get_shape(mask.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 8, 2, make_struct((halide_dimension_t *), 0, 3, 1, 0, 0, 3, 3, 0), (uint64)0)
}
if (_halide_buffer_is_bounds_query(output.buffer)) {
  _halide_buffer_init(output.buffer, _halide_buffer_get_shape(output.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 2, make_struct((halide_dimension_t *), 0, max(output.extent.0, 64), 1, 0, 0, max(output.extent.1, 32), max(output.extent.0, 64), 0), (uint64)0)
}
if (!(_halide_buffer_is_bounds_query(output.buffer) || (_halide_buffer_is_bounds_query(input.buffer) || _halide_buffer_is_bounds_query(mask.buffer)))) {
  assert((input.type == (uint32)67585), halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
  assert((input.dimensions == 2), halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
  assert((mask.type == (uint32)67584), halide_error_bad_type("Input buffer mask", mask.type, (uint32)67584))
  assert((mask.dimensions == 2), halide_error_bad_dimensions("Input buffer mask", mask.dimensions, 2))
  assert((output.type == (uint32)67585), halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
  assert((output.dimensions == 2), halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
  assert(((input.min.0 <= input.min.0.required) && (((input.extent.0.required.s + input.min.0.required) + 1) <= (input.extent.0 + input.min.0))), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.extent.0.required.s + input.min.0.required), input.min.0, ((input.extent.0 + input.min.0) + -1)))
  assert((0 <= input.extent.0), halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
  assert(((input.min.1 <= input.min.1.required) && (((input.extent.1.required.s + input.min.1.required) + 1) <= (input.extent.1 + input.min.1))), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.extent.1.required.s + input.min.1.required), input.min.1, ((input.extent.1 + input.min.1) + -1)))
  assert((0 <= input.extent.1), halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
  assert(((mask.min.0 <= 0) && (3 <= (mask.extent.0 + mask.min.0))), halide_error_access_out_of_bounds("Input buffer mask", 0, 0, 2, mask.min.0, ((mask.extent.0 + mask.min.0) + -1)))
  assert((0 <= mask.extent.0), halide_error_buffer_extents_negative("Input buffer mask", 0, mask.extent.0))
  assert(((mask.min.1 <= 0) && (3 <= (mask.extent.1 + mask.min.1))), halide_error_access_out_of_bounds("Input buffer mask", 1, 0, 2, mask.min.1, ((mask.extent.1 + mask.min.1) + -1)))
  assert((0 <= mask.extent.1), halide_error_buffer_extents_negative("Input buffer mask", 1, mask.extent.1))
  assert((((output.min.0 + 64) <= min(output.extent.0, 64)) && (0 <= output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, (min(output.extent.0, 64) + -64), (output.extent.0 + -1), output.min.0, ((output.extent.0 + output.min.0) + -1)))
  assert((0 <= output.extent.0), halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
  assert((((output.min.1 + 32) <= min(output.extent.1, 32)) && (0 <= output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, (min(output.extent.1, 32) + -32), (output.extent.1 + -1), output.min.1, ((output.extent.1 + output.min.1) + -1)))
  assert((0 <= output.extent.1), halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
  assert((input.stride.0 == 1), halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
  assert((input.min.0 == 0), halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
  assert((input.min.1 == 0), halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
  assert((mask.stride.0 == 1), halide_error_constraint_violated("mask.stride.0", mask.stride.0, "1", 1))
  assert((output.stride.0 == 1), halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
  assert((output.min.0 == 0), halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
  assert((output.min.1 == 0), halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let mask.total_extent.1 = (int64(mask.extent.1)*int64(mask.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((abs(int64(input.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("input", abs(int64(input.extent.0)), (uint64)2147483647))
  assert((abs((int64(input.extent.1)*int64(input.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("input", abs((int64(input.extent.1)*int64(input.stride.1))), (uint64)2147483647))
  assert((input.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
  assert((abs(int64(mask.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("mask", abs(int64(mask.extent.0)), (uint64)2147483647))
  assert((abs((int64(mask.extent.1)*int64(mask.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("mask", abs((int64(mask.extent.1)*int64(mask.stride.1))), (uint64)2147483647))
  assert((mask.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("mask", mask.total_extent.1, (int64)2147483647))
  assert((abs(int64(output.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("output", abs(int64(output.extent.0)), (uint64)2147483647))
  assert((abs((int64(output.extent.1)*int64(output.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("output", abs((int64(output.extent.1)*int64(output.stride.1))), (uint64)2147483647))
  assert((output.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
  assert((input != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Input buffer input"))
  assert((mask != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Input buffer mask"))
  assert((output != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer output"))
  produce output {
    let t193 = max(output.extent.0, 64)
    let t194 = min(output.extent.0, 64)
    let t191 = (0 < (output.extent.0 % 64))
    let t186 = max((128 - t194), (min((min((input.extent.0 - t194), ((min((input.extent.0 + 62), output.extent.0) - t194) + 1)) + 63), t193) + 2))
    let t180 = ((t193 + 65)/64)
    let t177 = ((output.extent.1 + 31)/32)
    let t187 = (output.extent.0/64)
    let t189 = (mask.min.1*mask.stride.1)
    let t178 = (output.extent.1 + -32)
    let t182 = (output.extent.0 + 2)
    let t192 = (output.extent.0 + -64)
    let t184 = (input.extent.0 + -1)
    parallel (output.s0.y.y, 0, t177) {
      let output.s0.y.yi.base = min((output.s0.y.y*32), t178)
      let t218 = (t186/64)
      let t219 = ((0 - t194)/64)
      let t199 = min((output.s0.y.y*32), t178)
      let t206 = (((mask.stride.1*2) - t189) - mask.min.0)
      let t207 = ((mask.stride.1 - t189) - mask.min.0)
      let t211 = ((2 - t189) - mask.min.0)
      let t213 = ((1 - t189) - mask.min.0)
      let t212 = ((0 - t189) - mask.min.0)
      let t202 = (t219 + 2)
      let t203 = ((t218 - t219) + -2)
      for (output.s0.y.yi.yi, 0, 2) {
        allocate repeat_edge[uint8 * (t193 + 2) * 18] in Stack
        produce repeat_edge {
          let repeat_edge.s0._1.prologue.s = min(max(((output.s0.y.yi.yi*16) + output.s0.y.yi.base), 1), (((output.s0.y.yi.yi*16) + output.s0.y.yi.base) + 18))
          let repeat_edge.s0._1.epilogue = max(min((((output.s0.y.yi.yi*16) + output.s0.y.yi.base) + 17), input.extent.1), (min(max(((output.s0.y.yi.yi*16) + output.s0.y.yi.base), 1), (((output.s0.y.yi.yi*16) + output.s0.y.yi.base) + 18)) + -1))
          let t225 = (output.s0.y.yi.yi*16)
          let t226 = (t199 + t225)
          let t221 = ((min(max(t226, 1), (t226 + 18)) - t199) - t225)
          let t223 = ((1 - output.s0.y.yi.base) - t225)
          let t220 = ((output.s0.y.yi.base + t225) + -1)
          let t224 = (t193 + 2)
          let t222 = (input.extent.1 + -1)
          for (repeat_edge.s0._1, t220, t221) {
            let t227 = (max(min(repeat_edge.s0._1, t222), 0)*input.stride.1)
            let t228 = (((repeat_edge.s0._1 + t223)*t224) - t194)
            for (repeat_edge.s0._0._0, 0, t180) {
              let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0*64) + t194), t182)
              repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t228), 1, 64)] = input[(max(min(ramp((repeat_edge.s0._0._0i.base.s + -65), 1, 64), x64(t184)), x64(0)) + x64(t227))]
            }
          }
          let t234 = (output.s0.y.yi.yi*16)
          let t235 = (t199 + t234)
          let t231 = ((1 - output.s0.y.yi.base) - t234)
          let t233 = (t180 - t218)
          let t230 = (max((min((t235 + 17), input.extent.1) - min(max(t235, 1), (t235 + 18))), -1) + 1)
          let t232 = (t193 + 2)
          let t229 = (repeat_edge.s0._1.prologue.s + -1)
          for (repeat_edge.s0._1, t229, t230) {
            let t236 = (input.stride.1*repeat_edge.s0._1)
            let t237 = (((repeat_edge.s0._1 + t231)*t232) - t194)
            for (repeat_edge.s0._0._0, 0, t202) {
              let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0*64) + t194), t182)
              repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t237), 1, 64)] = input[(max(min(ramp((repeat_edge.s0._0._0i.base.s + -65), 1, 64), x64(t184)), x64(0)) + x64(t236))]
            }
            let t239 = (((repeat_edge.s0._1 + t231)*t232) - t194)
            let t238 = ((input.stride.1*repeat_edge.s0._1) + -65)
            for (repeat_edge.s0._0._0, t202, t203) {
              let repeat_edge.s0._0._0i.base.s = ((repeat_edge.s0._0._0*64) + t194)
              repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t239), 1, 64)] = input[ramp((repeat_edge.s0._0._0i.base.s + t238), 1, 64)]
            }
            let t240 = (input.stride.1*repeat_edge.s0._1)
            let t241 = (((repeat_edge.s0._1 + t231)*t232) - t194)
            for (repeat_edge.s0._0._0, t218, t233) {
              let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0*64) + t194), t182)
              repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t241), 1, 64)] = input[(max(min(ramp((repeat_edge.s0._0._0i.base.s + -65), 1, 64), x64(t184)), x64(0)) + x64(t240))]
            }
          }
          let t246 = (output.s0.y.yi.yi*16)
          let t247 = (t199 + t246)
          let t244 = ((1 - output.s0.y.yi.base) - t246)
          let t242 = ((t247 - max(min((t247 + 17), input.extent.1), (min(max(t247, 1), (t247 + 18)) + -1))) + 17)
          let t245 = (t193 + 2)
          let t243 = (input.extent.1 + -1)
          for (repeat_edge.s0._1, repeat_edge.s0._1.epilogue, t242) {
            let t248 = (max(min(repeat_edge.s0._1, t243), 0)*input.stride.1)
            let t249 = (((repeat_edge.s0._1 + t244)*t245) - t194)
            for (repeat_edge.s0._0._0, 0, t180) {
              let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0*64) + t194), t182)
              repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t249), 1, 64)] = input[(max(min(ramp((repeat_edge.s0._0._0i.base.s + -65), 1, 64), x64(t184)), x64(0)) + x64(t248))]
            }
          }
        }
        consume repeat_edge {
          let t258 = ((output.s0.y.yi.yi*16) + output.s0.y.yi.base)
          for (output.s0.y.yi.yii, 0, 16) {
            let t271 = ((output.s0.y.yi.yii + t258)*output.stride.1)
            let t263 = (((output.s0.y.yi.yii + 1)*(t193 + 2)) - t194)
            for (output.s0.x.x, 0, t187) {
              output[ramp(((output.s0.x.x*64) + t271), 1, 64)] = uint8x64(max(min((((int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t263) - t193) + 63), 1, 64)])*x64(int16(mask[t213]))) + ((int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t263) - t193) + 62), 1, 64)])*x64(int16(mask[t212]))) + ((int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t263) - t193) + 64), 1, 64)])*x64(int16(mask[t211]))) + ((int16x64(repeat_edge[ramp((((output.s0.x.x*64) + t263) + 64), 1, 64)])*x64(int16(mask[t207]))) + ((int16x64(repeat_edge[ramp((((output.s0.x.x*64) + t263) + 65), 1, 64)])*x64(int16(mask[(t207 + 1)]))) + ((int16x64(repeat_edge[ramp((((output.s0.x.x*64) + t263) + 66), 1, 64)])*x64(int16(mask[(t207 + 2)]))) + ((int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t263) + t193) + 66), 1, 64)])*x64(int16(mask[t206]))) + ((int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t263) + t193) + 68), 1, 64)])*x64(int16(mask[(t206 + 2)]))) + (int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t263) + t193) + 67), 1, 64)])*x64(int16(mask[(t206 + 1)])))))))))))/x64((int16)16)), x64((int16)255)), x64((int16)0)))
            }
            if (t191) {
              output[ramp((((output.s0.y.yi.yii + t258)*output.stride.1) + t192), 1, 64)] = (let t172 = ((output.s0.y.yi.yii + 1)*(t193 + 2)) in uint8x64(max(min((((int16x64(repeat_edge[ramp((t172 + -65), 1, 64)])*x64(int16(mask[t213]))) + ((int16x64(repeat_edge[ramp((t172 + -66), 1, 64)])*x64(int16(mask[t212]))) + ((int16x64(repeat_edge[ramp((t172 + -64), 1, 64)])*x64(int16(mask[t211]))) + ((int16x64(repeat_edge[ramp(((t172 + t193) + -64), 1, 64)])*x64(int16(mask[t207]))) + ((int16x64(repeat_edge[ramp(((t172 + t193) + -63), 1, 64)])*x64(int16(mask[(t207 + 1)]))) + ((int16x64(repeat_edge[ramp(((t172 + t193) + -62), 1, 64)])*x64(int16(mask[(t207 + 2)]))) + ((int16x64(repeat_edge[ramp((((t193*2) + t172) + -62), 1, 64)])*x64(int16(mask[t206]))) + ((int16x64(repeat_edge[ramp((((t193*2) + t172) + -60), 1, 64)])*x64(int16(mask[(t206 + 2)]))) + (int16x64(repeat_edge[ramp((((t193*2) + t172) + -61), 1, 64)])*x64(int16(mask[(t206 + 1)])))))))))))/x64((int16)16)), x64((int16)255)), x64((int16)0))))
            }
          }
        }
        free repeat_edge
      }
    }
  }
}
}


