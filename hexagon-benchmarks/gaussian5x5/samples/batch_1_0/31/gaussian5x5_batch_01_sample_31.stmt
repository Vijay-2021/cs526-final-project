module name=gaussian5x5_batch_01_sample_31, target=x86-64-linux-avx-avx2-avx512-avx512_skylake-disable_llvm_loop_unroll-disable_llvm_loop_vectorize-f16c-fma-sse41
external_plus_metadata func gaussian5x5_batch_01_sample_31 (input, output) {
assert((reinterpret(uint64, output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output"))
assert((reinterpret(uint64, input.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input"))
let input = _halide_buffer_get_host(input.buffer)
let input.type = _halide_buffer_get_type(input.buffer)
let input.dimensions = _halide_buffer_get_dimensions(input.buffer)
let input.min.0 = _halide_buffer_get_min(input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent(input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride(input.buffer, 0)
let input.min.1 = _halide_buffer_get_min(input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent(input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride(input.buffer, 1)
let output = _halide_buffer_get_host(output.buffer)
let output.type = _halide_buffer_get_type(output.buffer)
let output.dimensions = _halide_buffer_get_dimensions(output.buffer)
let output.min.0 = _halide_buffer_get_min(output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent(output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride(output.buffer, 0)
let output.min.1 = _halide_buffer_get_min(output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent(output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride(output.buffer, 1)
let input.extent.0.required = (max(min((output.extent.0 + 2), (input.extent.0 + input.min.0)), (input.min.0 + 1)) - max((min(min(((input.extent.0 + input.min.0) + 61), output.extent.0), 60) + -62), input.min.0))
let input.min.0.required = max((min(min(((input.extent.0 + input.min.0) + 61), output.extent.0), 60) + -62), input.min.0)
let input.extent.1.required = (max(min((output.extent.1 + 2), (input.extent.1 + input.min.1)), (input.min.1 + 1)) - max((min((input.extent.1 + input.min.1), -1) + -1), input.min.1))
let input.min.1.required = max((min((input.extent.1 + input.min.1), -1) + -1), input.min.1)
assert((!_halide_buffer_is_bounds_query(input.buffer) || ((0 <= input.min.0.required) && (input.min.0.required <= 0))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (input.extent.0.required + -1), input.min.0.required, ((input.extent.0.required + input.min.0.required) + -1)))
assert((!_halide_buffer_is_bounds_query(input.buffer) || ((0 <= input.min.1.required) && (input.min.1.required <= 0))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (input.extent.1.required + -1), input.min.1.required, ((input.extent.1.required + input.min.1.required) + -1)))
assert((!_halide_buffer_is_bounds_query(output.buffer) || (256 <= output.extent.0)), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, 0, 255, (output.extent.0 + -256), (output.extent.0 + -1)))
assert((!_halide_buffer_is_bounds_query(output.buffer) || (32 <= output.extent.1)), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, 0, 31, (output.extent.1 + -32), (output.extent.1 + -1)))
if (_halide_buffer_is_bounds_query(input.buffer)) {
  _halide_buffer_init(input.buffer, _halide_buffer_get_shape(input.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 2, make_struct((halide_dimension_t *), 0, input.extent.0.required, 1, 0, 0, input.extent.1.required, input.extent.0.required, 0), (uint64)0)
}
if (_halide_buffer_is_bounds_query(output.buffer)) {
  _halide_buffer_init(output.buffer, _halide_buffer_get_shape(output.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 2, make_struct((halide_dimension_t *), 0, max(output.extent.0, 256), 1, 0, 0, max(output.extent.1, 32), max(output.extent.0, 256), 0), (uint64)0)
}
if (!(_halide_buffer_is_bounds_query(input.buffer) || _halide_buffer_is_bounds_query(output.buffer))) {
  assert((input.type == (uint32)67585), halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
  assert((input.dimensions == 2), halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
  assert((output.type == (uint32)67585), halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
  assert((output.dimensions == 2), halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
  assert(((input.min.0 <= input.min.0.required) && ((input.extent.0.required + input.min.0.required) <= (input.extent.0 + input.min.0))), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, ((input.extent.0.required + input.min.0.required) + -1), input.min.0, ((input.extent.0 + input.min.0) + -1)))
  assert((0 <= input.extent.0), halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
  assert(((input.min.1 <= input.min.1.required) && ((input.extent.1.required + input.min.1.required) <= (input.extent.1 + input.min.1))), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, ((input.extent.1.required + input.min.1.required) + -1), input.min.1, ((input.extent.1 + input.min.1) + -1)))
  assert((0 <= input.extent.1), halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
  assert((((output.min.0 + 256) <= min(output.extent.0, 256)) && (0 <= output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, (min(output.extent.0, 256) + -256), (output.extent.0 + -1), output.min.0, ((output.extent.0 + output.min.0) + -1)))
  assert((0 <= output.extent.0), halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
  assert((((output.min.1 + 32) <= min(output.extent.1, 32)) && (0 <= output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, (min(output.extent.1, 32) + -32), (output.extent.1 + -1), output.min.1, ((output.extent.1 + output.min.1) + -1)))
  assert((0 <= output.extent.1), halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
  assert((input.stride.0 == 1), halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
  assert((input.min.0 == 0), halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
  assert((input.min.1 == 0), halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
  assert((output.stride.0 == 1), halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
  assert((output.min.0 == 0), halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
  assert((output.min.1 == 0), halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((abs(int64(input.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("input", abs(int64(input.extent.0)), (uint64)2147483647))
  assert((abs((int64(input.extent.1)*int64(input.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("input", abs((int64(input.extent.1)*int64(input.stride.1))), (uint64)2147483647))
  assert((input.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
  assert((abs(int64(output.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("output", abs(int64(output.extent.0)), (uint64)2147483647))
  assert((abs((int64(output.extent.1)*int64(output.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("output", abs((int64(output.extent.1)*int64(output.stride.1))), (uint64)2147483647))
  assert((output.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
  assert((input != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Input buffer input"))
  assert((output != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer output"))
  produce output {
    let t629 = (output.extent.0 + 196)
    let t630 = min(output.extent.0, 256)
    let t631 = (321 - t630)
    let t632 = ((output.extent.0 + 255)/256)
    let t633 = max(output.extent.0, 256)
    let t634 = (256 < output.extent.0)
    let t635 = (t630 + -258)
    let t636 = min(select(t634, 2, t635), t635)
    let t637 = (output.extent.0 + -258)
    let t638 = (max(select(t634, (min((t632*256), (output.extent.0 + 256)) + -254), t637), t637) + ((((output.extent.0 - t636) + 1)/32)*32))
    let t626 = (max((t638 + 30), output.extent.0) + 1)
    let t618 = (max(min(((((t633 + 3)/64)*64) + t630), t629), (t638 + 226)) + -195)
    let t625 = max((min(min((min((input.extent.0 - t630), ((min((input.extent.0 + 61), output.extent.0) - t630) + 2)) + 254), t633), (t633 + 63)) + 4), t631)
    let t619 = ((t633 + 67)/64)
    let t615 = ((output.extent.1 + 31)/32)
    let t616 = (output.extent.1 + -32)
    let t623 = (input.extent.0 + -1)
    parallel (output.s0.y.y, 0, t615) {
      let output.s0.y.yi.base = min((output.s0.y.y*32), t616)
      allocate repeat_edge[uint8 * ((t618 - t636) + 1) * 8] in Stack
      let t694 = (t618 - t636)
      let t695 = (t625/64)
      let t696 = (t631/64)
      let t697 = min((output.s0.y.y*32), t616)
      let t648 = ((t626 - t636) + 1)
      for (output.s0.y.yi, 0, 32) {
        let repeat_edge.s0._1.min_2 = ((select((0 < output.s0.y.yi), 2, -2) + output.s0.y.yi.base) + output.s0.y.yi)
        produce repeat_edge {
          let repeat_edge.s0._1.prologue = min(max(repeat_edge.s0._1.min_2, 0), ((output.s0.y.yi + output.s0.y.yi.base) + 3))
          let repeat_edge.s0._1.epilogue = min(max(input.extent.1, repeat_edge.s0._1.min_2), ((output.s0.y.yi + output.s0.y.yi.base) + 3))
          let t702 = (0 < output.s0.y.yi)
          let t698 = min(select(t702, 1, 5), (0 - min(((select(t702, 2, -2) + t697) + output.s0.y.yi), 0)))
          let t700 = (-258 - t636)
          let t701 = (t694 + 1)
          let t699 = (input.extent.1 + -1)
          for (repeat_edge.s0._1, repeat_edge.s0._1.min_2, t698) {
            let t703 = (max(min(repeat_edge.s0._1, t699), 0)*input.stride.1)
            let t704 = (((repeat_edge.s0._1 % 8)*t701) + t700)
            for (repeat_edge.s0._0._0, 0, t619) {
              let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0*64) + t630), t629)
              repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t704), 1, 64)] = input[(max(min(ramp((repeat_edge.s0._0._0i.base.s + -258), 1, 64), x64(t623)), x64(0)) + x64(t703))]
            }
          }
          let t710 = (0 < output.s0.y.yi)
          let t711 = (select(t710, 2, -2) + t697)
          let t712 = (output.s0.y.yi + t711)
          let t713 = ((select(t710, 1, 5) + t711) + output.s0.y.yi)
          let t705 = (min(max(input.extent.1, t712), t713) - min(max(t712, 0), t713))
          let t709 = (t619 - t695)
          let t706 = (-258 - t636)
          let t707 = (t694 + 1)
          for (repeat_edge.s0._1, repeat_edge.s0._1.prologue, t705) {
            let t714 = (input.stride.1*repeat_edge.s0._1)
            let t715 = (((repeat_edge.s0._1 % 8)*t707) + t706)
            for (repeat_edge.s0._0._0, 0, t696) {
              let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0*64) + t630), t629)
              repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t715), 1, 64)] = input[(max(min(ramp((repeat_edge.s0._0._0i.base.s + -258), 1, 64), x64(t623)), x64(0)) + x64(t714))]
            }
            let t716 = (t695 - t696)
            let t718 = (((repeat_edge.s0._1 % 8)*t707) + t706)
            let t717 = ((input.stride.1*repeat_edge.s0._1) + -258)
            for (repeat_edge.s0._0._0, t696, t716) {
              let repeat_edge.s0._0._0i.base.s = ((repeat_edge.s0._0._0*64) + t630)
              repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t718), 1, 64)] = input[ramp((repeat_edge.s0._0._0i.base.s + t717), 1, 64)]
            }
            let t719 = (input.stride.1*repeat_edge.s0._1)
            let t720 = (((repeat_edge.s0._1 % 8)*t707) + t706)
            for (repeat_edge.s0._0._0, t695, t709) {
              let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0*64) + t630), t629)
              repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t720), 1, 64)] = input[(max(min(ramp((repeat_edge.s0._0._0i.base.s + -258), 1, 64), x64(t623)), x64(0)) + x64(t719))]
            }
          }
          let t725 = (0 < output.s0.y.yi)
          let t726 = select(t725, 2, -2)
          let t721 = max(((select(t725, 1, 5) + (min(((output.s0.y.yi*-1) - t726), (t697 - input.extent.1)) + output.s0.y.yi)) + t726), 0)
          let t723 = (-258 - t636)
          let t724 = (t694 + 1)
          let t722 = (input.extent.1 + -1)
          for (repeat_edge.s0._1, repeat_edge.s0._1.epilogue, t721) {
            let t727 = (max(min(repeat_edge.s0._1, t722), 0)*input.stride.1)
            let t728 = (((repeat_edge.s0._1 % 8)*t724) + t723)
            for (repeat_edge.s0._0._0, 0, t619) {
              let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0*64) + t630), t629)
              repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t728), 1, 64)] = input[(max(min(ramp((repeat_edge.s0._0._0i.base.s + -258), 1, 64), x64(t623)), x64(0)) + x64(t727))]
            }
          }
        }
        allocate rows[int16 * t648 * 1] in Stack
        consume repeat_edge {
          let t778 = (output.s0.y.yi + output.s0.y.yi.base)
          let t779 = (output.stride.1*t778)
          let t780 = (t694 + 1)
          let t732 = ((((t778 + 7) % 8)*t780) - t636)
          let t733 = ((((t778 + 6) % 8)*t780) - t636)
          let t734 = ((((t778 + 2) % 8)*t780) - t636)
          let t730 = ((((t778 + 1) % 8)*t780) - t636)
          let t731 = (((t778 % 8)*t780) - t636)
          for (output.s0.x.x, 0, t632) {
            let output.s0.x.xi.base = min((output.s0.x.x*256), (output.extent.0 + -256))
            let rows.s0.x.min_3 = select((0 < output.s0.x.x), (min((output.s0.x.x*256), output.extent.0) + 2), (output.s0.x.xi.base + -2))
            produce rows {
              let t781 = (((output.s0.x.xi.base - rows.s0.x.min_3) + 289)/32)
              let t787 = (rows.s0.x.min_3 - t636)
              let t786 = (rows.s0.x.min_3 + t734)
              let t785 = (rows.s0.x.min_3 + t733)
              let t784 = (rows.s0.x.min_3 + t732)
              let t783 = (rows.s0.x.min_3 + t731)
              let t782 = (rows.s0.x.min_3 + t730)
              for (rows.s0.x.x, 0, t781) {
                rows[ramp(((rows.s0.x.x*32) + t787), 1, 32)] = ((((int16x32(repeat_edge[ramp(((rows.s0.x.x*32) + t784), 1, 32)])*x32((int16)4)) + ((int16x32(repeat_edge[ramp(((rows.s0.x.x*32) + t782), 1, 32)])*x32((int16)4)) + (int16x32(repeat_edge[ramp(((rows.s0.x.x*32) + t783), 1, 32)])*x32((int16)6)))) + int16x32(repeat_edge[ramp(((rows.s0.x.x*32) + t785), 1, 32)])) + int16x32(repeat_edge[ramp(((rows.s0.x.x*32) + t786), 1, 32)]))
              }
            }
            allocate cols[int16 * 256] in Stack
            produce cols {
              consume rows {
                cols[ramp(0, 1, 32)] = ((rows[ramp(((output.s0.x.xi.base - t636) + -1), 1, 32)]*x32((int16)4)) + (rows[ramp(((output.s0.x.xi.base - t636) + -2), 1, 32)] + ((rows[ramp((output.s0.x.xi.base - t636), 1, 32)]*x32((int16)6)) + (rows[ramp(((output.s0.x.xi.base - t636) + 2), 1, 32)] + (rows[ramp(((output.s0.x.xi.base - t636) + 1), 1, 32)]*x32((int16)4))))))
                cols[ramp(32, 1, 32)] = ((rows[ramp(((output.s0.x.xi.base - t636) + 31), 1, 32)]*x32((int16)4)) + (rows[ramp(((output.s0.x.xi.base - t636) + 30), 1, 32)] + ((rows[ramp(((output.s0.x.xi.base - t636) + 32), 1, 32)]*x32((int16)6)) + (rows[ramp(((output.s0.x.xi.base - t636) + 34), 1, 32)] + (rows[ramp(((output.s0.x.xi.base - t636) + 33), 1, 32)]*x32((int16)4))))))
                cols[ramp(64, 1, 32)] = ((rows[ramp(((output.s0.x.xi.base - t636) + 63), 1, 32)]*x32((int16)4)) + (rows[ramp(((output.s0.x.xi.base - t636) + 62), 1, 32)] + ((rows[ramp(((output.s0.x.xi.base - t636) + 64), 1, 32)]*x32((int16)6)) + (rows[ramp(((output.s0.x.xi.base - t636) + 66), 1, 32)] + (rows[ramp(((output.s0.x.xi.base - t636) + 65), 1, 32)]*x32((int16)4))))))
                cols[ramp(96, 1, 32)] = ((rows[ramp(((output.s0.x.xi.base - t636) + 95), 1, 32)]*x32((int16)4)) + (rows[ramp(((output.s0.x.xi.base - t636) + 94), 1, 32)] + ((rows[ramp(((output.s0.x.xi.base - t636) + 96), 1, 32)]*x32((int16)6)) + (rows[ramp(((output.s0.x.xi.base - t636) + 98), 1, 32)] + (rows[ramp(((output.s0.x.xi.base - t636) + 97), 1, 32)]*x32((int16)4))))))
                cols[ramp(128, 1, 32)] = ((rows[ramp(((output.s0.x.xi.base - t636) + 127), 1, 32)]*x32((int16)4)) + (rows[ramp(((output.s0.x.xi.base - t636) + 126), 1, 32)] + ((rows[ramp(((output.s0.x.xi.base - t636) + 128), 1, 32)]*x32((int16)6)) + (rows[ramp(((output.s0.x.xi.base - t636) + 130), 1, 32)] + (rows[ramp(((output.s0.x.xi.base - t636) + 129), 1, 32)]*x32((int16)4))))))
                cols[ramp(160, 1, 32)] = ((rows[ramp(((output.s0.x.xi.base - t636) + 159), 1, 32)]*x32((int16)4)) + (rows[ramp(((output.s0.x.xi.base - t636) + 158), 1, 32)] + ((rows[ramp(((output.s0.x.xi.base - t636) + 160), 1, 32)]*x32((int16)6)) + (rows[ramp(((output.s0.x.xi.base - t636) + 162), 1, 32)] + (rows[ramp(((output.s0.x.xi.base - t636) + 161), 1, 32)]*x32((int16)4))))))
                cols[ramp(192, 1, 32)] = ((rows[ramp(((output.s0.x.xi.base - t636) + 191), 1, 32)]*x32((int16)4)) + (rows[ramp(((output.s0.x.xi.base - t636) + 190), 1, 32)] + ((rows[ramp(((output.s0.x.xi.base - t636) + 192), 1, 32)]*x32((int16)6)) + (rows[ramp(((output.s0.x.xi.base - t636) + 194), 1, 32)] + (rows[ramp(((output.s0.x.xi.base - t636) + 193), 1, 32)]*x32((int16)4))))))
                cols[ramp(224, 1, 32)] = ((rows[ramp(((output.s0.x.xi.base - t636) + 223), 1, 32)]*x32((int16)4)) + (rows[ramp(((output.s0.x.xi.base - t636) + 222), 1, 32)] + ((rows[ramp(((output.s0.x.xi.base - t636) + 224), 1, 32)]*x32((int16)6)) + (rows[ramp(((output.s0.x.xi.base - t636) + 226), 1, 32)] + (rows[ramp(((output.s0.x.xi.base - t636) + 225), 1, 32)]*x32((int16)4))))))
              }
            }
            consume cols {
              output[ramp((output.s0.x.xi.base + t779), 1, 64)] = uint8x64((cols[ramp(0, 1, 64)]/x64((int16)256)))
              output[ramp(((output.s0.x.xi.base + t779) + 64), 1, 64)] = uint8x64((cols[ramp(64, 1, 64)]/x64((int16)256)))
              output[ramp(((output.s0.x.xi.base + t779) + 128), 1, 64)] = uint8x64((cols[ramp(128, 1, 64)]/x64((int16)256)))
              output[ramp(((output.s0.x.xi.base + t779) + 192), 1, 64)] = uint8x64((cols[ramp(192, 1, 64)]/x64((int16)256)))
              free cols
            }
          }
        }
        free rows
      }
      free repeat_edge
    }
  }
}
}


