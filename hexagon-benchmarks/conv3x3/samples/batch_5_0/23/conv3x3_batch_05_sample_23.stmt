module name=conv3x3_batch_05_sample_23, target=x86-64-linux-avx-avx2-avx512-avx512_skylake-disable_llvm_loop_unroll-disable_llvm_loop_vectorize-f16c-fma-sse41
external_plus_metadata func conv3x3_batch_05_sample_23 (input, mask, output) {
assert((reinterpret(uint64, output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output"))
assert((reinterpret(uint64, mask.buffer) != (uint64)0), halide_error_buffer_argument_is_null("mask"))
assert((reinterpret(uint64, input.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input"))
let input = _halide_buffer_get_host(input.buffer)
let input.type = _halide_buffer_get_type(input.buffer)
let input.dimensions = _halide_buffer_get_dimensions(input.buffer)
let input.min.0 = _halide_buffer_get_min(input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent(input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride(input.buffer, 0)
let input.min.1 = _halide_buffer_get_min(input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent(input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride(input.buffer, 1)
let mask = _halide_buffer_get_host(mask.buffer)
let mask.type = _halide_buffer_get_type(mask.buffer)
let mask.dimensions = _halide_buffer_get_dimensions(mask.buffer)
let mask.min.0 = _halide_buffer_get_min(mask.buffer, 0)
let mask.extent.0 = _halide_buffer_get_extent(mask.buffer, 0)
let mask.stride.0 = _halide_buffer_get_stride(mask.buffer, 0)
let mask.min.1 = _halide_buffer_get_min(mask.buffer, 1)
let mask.extent.1 = _halide_buffer_get_extent(mask.buffer, 1)
let mask.stride.1 = _halide_buffer_get_stride(mask.buffer, 1)
let output = _halide_buffer_get_host(output.buffer)
let output.type = _halide_buffer_get_type(output.buffer)
let output.dimensions = _halide_buffer_get_dimensions(output.buffer)
let output.min.0 = _halide_buffer_get_min(output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent(output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride(output.buffer, 0)
let output.min.1 = _halide_buffer_get_min(output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent(output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride(output.buffer, 1)
let input.extent.0.required.s = (max(min(((input.extent.0 + input.min.0) + -1), output.extent.0), input.min.0) - max((min(min(((input.extent.0 + input.min.0) + 62), output.extent.0), 62) + -63), input.min.0))
let input.min.0.required = max((min(min(((input.extent.0 + input.min.0) + 62), output.extent.0), 62) + -63), input.min.0)
let input.extent.1.required.s = (max(min(((input.extent.1 + input.min.1) + -1), output.extent.1), input.min.1) - max((min((input.extent.1 + input.min.1), 0) + -1), input.min.1))
let input.min.1.required = max((min((input.extent.1 + input.min.1), 0) + -1), input.min.1)
assert((!_halide_buffer_is_bounds_query(input.buffer) || ((0 <= input.min.0.required) && (input.min.0.required <= 0))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, input.extent.0.required.s, input.min.0.required, (input.extent.0.required.s + input.min.0.required)))
assert((!_halide_buffer_is_bounds_query(input.buffer) || ((0 <= input.min.1.required) && (input.min.1.required <= 0))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, input.extent.1.required.s, input.min.1.required, (input.extent.1.required.s + input.min.1.required)))
assert((!_halide_buffer_is_bounds_query(output.buffer) || (64 <= output.extent.0)), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, 0, 63, (output.extent.0 + -64), (output.extent.0 + -1)))
assert((!_halide_buffer_is_bounds_query(output.buffer) || (32 <= output.extent.1)), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, 0, 31, (output.extent.1 + -32), (output.extent.1 + -1)))
if (_halide_buffer_is_bounds_query(input.buffer)) {
  _halide_buffer_init(input.buffer, _halide_buffer_get_shape(input.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 2, make_struct((halide_dimension_t *), 0, (input.extent.0.required.s + 1), 1, 0, 0, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1), 0), (uint64)0)
}
if (_halide_buffer_is_bounds_query(mask.buffer)) {
  _halide_buffer_init(mask.buffer, _halide_buffer_get_shape(mask.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 8, 2, make_struct((halide_dimension_t *), 0, 3, 1, 0, 0, 3, 3, 0), (uint64)0)
}
if (_halide_buffer_is_bounds_query(output.buffer)) {
  _halide_buffer_init(output.buffer, _halide_buffer_get_shape(output.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 2, make_struct((halide_dimension_t *), 0, max(output.extent.0, 64), 1, 0, 0, max(output.extent.1, 32), max(output.extent.0, 64), 0), (uint64)0)
}
if (!(_halide_buffer_is_bounds_query(output.buffer) || (_halide_buffer_is_bounds_query(input.buffer) || _halide_buffer_is_bounds_query(mask.buffer)))) {
  assert((input.type == (uint32)67585), halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
  assert((input.dimensions == 2), halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
  assert((mask.type == (uint32)67584), halide_error_bad_type("Input buffer mask", mask.type, (uint32)67584))
  assert((mask.dimensions == 2), halide_error_bad_dimensions("Input buffer mask", mask.dimensions, 2))
  assert((output.type == (uint32)67585), halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
  assert((output.dimensions == 2), halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
  assert(((input.min.0 <= input.min.0.required) && (((input.extent.0.required.s + input.min.0.required) + 1) <= (input.extent.0 + input.min.0))), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.extent.0.required.s + input.min.0.required), input.min.0, ((input.extent.0 + input.min.0) + -1)))
  assert((0 <= input.extent.0), halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
  assert(((input.min.1 <= input.min.1.required) && (((input.extent.1.required.s + input.min.1.required) + 1) <= (input.extent.1 + input.min.1))), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.extent.1.required.s + input.min.1.required), input.min.1, ((input.extent.1 + input.min.1) + -1)))
  assert((0 <= input.extent.1), halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
  assert(((mask.min.0 <= 0) && (3 <= (mask.extent.0 + mask.min.0))), halide_error_access_out_of_bounds("Input buffer mask", 0, 0, 2, mask.min.0, ((mask.extent.0 + mask.min.0) + -1)))
  assert((0 <= mask.extent.0), halide_error_buffer_extents_negative("Input buffer mask", 0, mask.extent.0))
  assert(((mask.min.1 <= 0) && (3 <= (mask.extent.1 + mask.min.1))), halide_error_access_out_of_bounds("Input buffer mask", 1, 0, 2, mask.min.1, ((mask.extent.1 + mask.min.1) + -1)))
  assert((0 <= mask.extent.1), halide_error_buffer_extents_negative("Input buffer mask", 1, mask.extent.1))
  assert((((output.min.0 + 64) <= min(output.extent.0, 64)) && (0 <= output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, (min(output.extent.0, 64) + -64), (output.extent.0 + -1), output.min.0, ((output.extent.0 + output.min.0) + -1)))
  assert((0 <= output.extent.0), halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
  assert((((output.min.1 + 32) <= min(output.extent.1, 32)) && (0 <= output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, (min(output.extent.1, 32) + -32), (output.extent.1 + -1), output.min.1, ((output.extent.1 + output.min.1) + -1)))
  assert((0 <= output.extent.1), halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
  assert((input.stride.0 == 1), halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
  assert((input.min.0 == 0), halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
  assert((input.min.1 == 0), halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
  assert((mask.stride.0 == 1), halide_error_constraint_violated("mask.stride.0", mask.stride.0, "1", 1))
  assert((output.stride.0 == 1), halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
  assert((output.min.0 == 0), halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
  assert((output.min.1 == 0), halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let mask.total_extent.1 = (int64(mask.extent.1)*int64(mask.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((abs(int64(input.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("input", abs(int64(input.extent.0)), (uint64)2147483647))
  assert((abs((int64(input.extent.1)*int64(input.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("input", abs((int64(input.extent.1)*int64(input.stride.1))), (uint64)2147483647))
  assert((input.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
  assert((abs(int64(mask.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("mask", abs(int64(mask.extent.0)), (uint64)2147483647))
  assert((abs((int64(mask.extent.1)*int64(mask.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("mask", abs((int64(mask.extent.1)*int64(mask.stride.1))), (uint64)2147483647))
  assert((mask.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("mask", mask.total_extent.1, (int64)2147483647))
  assert((abs(int64(output.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("output", abs(int64(output.extent.0)), (uint64)2147483647))
  assert((abs((int64(output.extent.1)*int64(output.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("output", abs((int64(output.extent.1)*int64(output.stride.1))), (uint64)2147483647))
  assert((output.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
  assert((input != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Input buffer input"))
  assert((mask != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Input buffer mask"))
  assert((output != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer output"))
  produce output {
    let t166 = max(output.extent.0, 64)
    let t167 = min(output.extent.0, 64)
    let t164 = (0 < (output.extent.0 % 64))
    let t159 = max((128 - t167), (min((min((input.extent.0 - t167), ((min((input.extent.0 + 62), output.extent.0) - t167) + 1)) + 63), t166) + 2))
    let t153 = ((t166 + 65)/64)
    let t150 = ((output.extent.1 + 31)/32)
    let t160 = (output.extent.0/64)
    let t162 = (mask.min.1*mask.stride.1)
    let t151 = (output.extent.1 + -32)
    let t155 = (output.extent.0 + 2)
    let t165 = (output.extent.0 + -64)
    let t157 = (input.extent.0 + -1)
    parallel (output.s0.y.y, 0, t150) {
      let output.s0.y.yi.base = min((output.s0.y.y*32), t151)
      allocate repeat_edge[uint8 * (t166 + 2) * 34]
      produce repeat_edge {
        let repeat_edge.s0._1.prologue.s = min(max(output.s0.y.yi.base, 1), (output.s0.y.yi.base + 34))
        let repeat_edge.s0._1.epilogue = max(min((output.s0.y.yi.base + 33), input.extent.1), (min(max(output.s0.y.yi.base, 1), (output.s0.y.yi.base + 34)) + -1))
        let t169 = (1 - min(min((output.s0.y.y*32), t151), 1))
        let t171 = (1 - output.s0.y.yi.base)
        let t172 = (t166 + 2)
        let t168 = (output.s0.y.yi.base + -1)
        let t170 = (input.extent.1 + -1)
        for (repeat_edge.s0._1, t168, t169) {
          let t173 = (max(min(repeat_edge.s0._1, t170), 0)*input.stride.1)
          let t174 = (((repeat_edge.s0._1 + t171)*t172) - t167)
          for (repeat_edge.s0._0._0, 0, t153) {
            let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0*64) + t167), t155)
            repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t174), 1, 64)] = input[(max(min(ramp((repeat_edge.s0._0._0i.base.s + -65), 1, 64), x64(t157)), x64(0)) + x64(t173))]
          }
        }
        let t183 = (t159/64)
        let t184 = ((0 - t167)/64)
        let t185 = min((output.s0.y.y*32), t151)
        let t176 = (max((min((t185 + 33), input.extent.1) - min(max(t185, 1), (t185 + 34))), -1) + 1)
        let t182 = (t153 - t183)
        let t178 = (1 - output.s0.y.yi.base)
        let t177 = (t184 + 2)
        let t180 = ((t183 - t184) + -2)
        let t179 = (t166 + 2)
        let t175 = (repeat_edge.s0._1.prologue.s + -1)
        for (repeat_edge.s0._1, t175, t176) {
          let t186 = (input.stride.1*repeat_edge.s0._1)
          let t187 = (((repeat_edge.s0._1 + t178)*t179) - t167)
          for (repeat_edge.s0._0._0, 0, t177) {
            let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0*64) + t167), t155)
            repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t187), 1, 64)] = input[(max(min(ramp((repeat_edge.s0._0._0i.base.s + -65), 1, 64), x64(t157)), x64(0)) + x64(t186))]
          }
          let t189 = (((repeat_edge.s0._1 + t178)*t179) - t167)
          let t188 = ((input.stride.1*repeat_edge.s0._1) + -65)
          for (repeat_edge.s0._0._0, t177, t180) {
            let repeat_edge.s0._0._0i.base.s = ((repeat_edge.s0._0._0*64) + t167)
            repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t189), 1, 64)] = input[ramp((repeat_edge.s0._0._0i.base.s + t188), 1, 64)]
          }
          let t190 = (input.stride.1*repeat_edge.s0._1)
          let t191 = (((repeat_edge.s0._1 + t178)*t179) - t167)
          for (repeat_edge.s0._0._0, t183, t182) {
            let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0*64) + t167), t155)
            repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t191), 1, 64)] = input[(max(min(ramp((repeat_edge.s0._0._0i.base.s + -65), 1, 64), x64(t157)), x64(0)) + x64(t190))]
          }
        }
        let t196 = min((output.s0.y.y*32), t151)
        let t192 = ((t196 - max(min((t196 + 33), input.extent.1), (min(max(t196, 1), (t196 + 34)) + -1))) + 33)
        let t194 = (1 - output.s0.y.yi.base)
        let t195 = (t166 + 2)
        let t193 = (input.extent.1 + -1)
        for (repeat_edge.s0._1, repeat_edge.s0._1.epilogue, t192) {
          let t197 = (max(min(repeat_edge.s0._1, t193), 0)*input.stride.1)
          let t198 = (((repeat_edge.s0._1 + t194)*t195) - t167)
          for (repeat_edge.s0._0._0, 0, t153) {
            let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0*64) + t167), t155)
            repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t198), 1, 64)] = input[(max(min(ramp((repeat_edge.s0._0._0i.base.s + -65), 1, 64), x64(t157)), x64(0)) + x64(t197))]
          }
        }
      }
      consume repeat_edge {
        let t200 = (((mask.stride.1*2) - t162) - mask.min.0)
        let t201 = ((mask.stride.1 - t162) - mask.min.0)
        let t205 = ((2 - t162) - mask.min.0)
        let t207 = ((1 - t162) - mask.min.0)
        let t206 = ((0 - t162) - mask.min.0)
        for (output.s0.y.yi, 0, 32) {
          let t220 = ((output.s0.y.yi + output.s0.y.yi.base)*output.stride.1)
          let t212 = (((output.s0.y.yi + 1)*(t166 + 2)) - t167)
          for (output.s0.x.x, 0, t160) {
            output[ramp(((output.s0.x.x*64) + t220), 1, 64)] = uint8x64(max(min((((int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t212) - t166) + 63), 1, 64)])*x64(int16(mask[t207]))) + ((int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t212) - t166) + 62), 1, 64)])*x64(int16(mask[t206]))) + ((int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t212) - t166) + 64), 1, 64)])*x64(int16(mask[t205]))) + ((int16x64(repeat_edge[ramp((((output.s0.x.x*64) + t212) + 64), 1, 64)])*x64(int16(mask[t201]))) + ((int16x64(repeat_edge[ramp((((output.s0.x.x*64) + t212) + 65), 1, 64)])*x64(int16(mask[(t201 + 1)]))) + ((int16x64(repeat_edge[ramp((((output.s0.x.x*64) + t212) + 66), 1, 64)])*x64(int16(mask[(t201 + 2)]))) + ((int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t212) + t166) + 66), 1, 64)])*x64(int16(mask[t200]))) + ((int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t212) + t166) + 68), 1, 64)])*x64(int16(mask[(t200 + 2)]))) + (int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t212) + t166) + 67), 1, 64)])*x64(int16(mask[(t200 + 1)])))))))))))/x64((int16)16)), x64((int16)255)), x64((int16)0)))
          }
          if (t164) {
            output[ramp((((output.s0.y.yi + output.s0.y.yi.base)*output.stride.1) + t165), 1, 64)] = (let t145 = ((output.s0.y.yi + 1)*(t166 + 2)) in uint8x64(max(min((((int16x64(repeat_edge[ramp((t145 + -65), 1, 64)])*x64(int16(mask[t207]))) + ((int16x64(repeat_edge[ramp((t145 + -66), 1, 64)])*x64(int16(mask[t206]))) + ((int16x64(repeat_edge[ramp((t145 + -64), 1, 64)])*x64(int16(mask[t205]))) + ((int16x64(repeat_edge[ramp(((t145 + t166) + -64), 1, 64)])*x64(int16(mask[t201]))) + ((int16x64(repeat_edge[ramp(((t145 + t166) + -63), 1, 64)])*x64(int16(mask[(t201 + 1)]))) + ((int16x64(repeat_edge[ramp(((t145 + t166) + -62), 1, 64)])*x64(int16(mask[(t201 + 2)]))) + ((int16x64(repeat_edge[ramp((((t166*2) + t145) + -62), 1, 64)])*x64(int16(mask[t200]))) + ((int16x64(repeat_edge[ramp((((t166*2) + t145) + -60), 1, 64)])*x64(int16(mask[(t200 + 2)]))) + (int16x64(repeat_edge[ramp((((t166*2) + t145) + -61), 1, 64)])*x64(int16(mask[(t200 + 1)])))))))))))/x64((int16)16)), x64((int16)255)), x64((int16)0))))
          }
        }
      }
      free repeat_edge
    }
  }
}
}


