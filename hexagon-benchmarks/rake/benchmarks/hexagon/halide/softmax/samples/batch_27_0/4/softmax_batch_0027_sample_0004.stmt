module name=softmax_batch_0027_sample_0004, target=x86-64-linux-avx-avx2-avx512-avx512_sapphirerapids-avx512_skylake-disable_llvm_loop_opt-f16c-fma-sse41
external_plus_metadata func softmax_batch_0027_sample_0004 (input, beta_multiplier, beta_shift, output_zero, output_multiplier, output_shift, output) {
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
let input.extent.0.required = max(input.extent.0 + input.min.0, output.extent.0 + output.min.0) - min((min(output.extent.0, 64) + output.min.0) + -64, input.min.0)
let input.min.0.required = min((min(output.extent.0, 64) + output.min.0) + -64, input.min.0)
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)input.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)input.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 8, 2, (halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required, 1, 0, (min(output.extent.1, 64) + output.min.1) + -64, max(output.extent.1, 64), input.extent.0.required, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)output.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)output.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 8, 2, (halide_dimension_t *)make_struct((min(output.extent.0, 64) + output.min.0) + -64, max(output.extent.0, 64), 1, 0, (min(output.extent.1, 17) + output.min.1) + -17, max(output.extent.1, 17), max(output.extent.0, 64), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || (uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer))) {
 assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
 assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
 assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
 assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
 assert((input.min.0 <= input.min.0.required) && ((input.extent.0.required + input.min.0.required) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.extent.0.required + input.min.0.required) + -1, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert(((input.min.1 + 64) <= (min(output.extent.1, 64) + output.min.1)) && ((output.extent.1 + output.min.1) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, (min(output.extent.1, 64) + output.min.1) + -64, (output.extent.1 + output.min.1) + -1, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert(64 <= output.extent.0, halide_error_access_out_of_bounds("Output buffer output", 0, (min(output.extent.0, 64) + output.min.0) + -64, (output.extent.0 + output.min.0) + -1, output.min.0, (output.extent.0 + output.min.0) + -1))
 assert(17 <= output.extent.1, halide_error_access_out_of_bounds("Output buffer output", 1, (min(output.extent.1, 17) + output.min.1) + -17, (output.extent.1 + output.min.1) + -1, output.min.1, (output.extent.1 + output.min.1) + -1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert(uint64(output.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", uint64(output.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1)), (uint64)2147483647))
 assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(!output.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer output"))
 assert(input != (void *)reinterpret((uint64)0), halide_error_host_is_null("Input buffer input"))
 assert(output != (void *)reinterpret((uint64)0), halide_error_host_is_null("Output buffer output"))
 let max_x.y.extent_realized.s = (((output.extent.1 + -1)/64)*64) - min(output.extent.1, 64)
 allocate max_x[uint8 * (max_x.y.extent_realized.s + 128)]
 produce max_x {
  let t233 = min(output.extent.1, 64)
  let t232 = (output.extent.1 + 63)/64
  parallel (max_x.s0.y.y, 0, t232) {
   max_x[ramp(((max_x.s0.y.y*64) - t233) + 64, 1, 64)] = x64((uint8)0)
  }
  let t234 = (output.extent.1 + 63)/64
  let t235 = output.extent.1/64
  let t237 = 0 - min(output.extent.1, 64)
  let t236 = 0 - (input.min.1*input.stride.1)
  parallel (max_x.s1.y.y, 0, t234) {
   if (max_x.s1.y.y < t235) {
    let t240 = max_x.s1.y.y*64
    let t239 = ((output.min.1 + t240)*input.stride.1) + t236
    for (max_x.s1.r6$x.rebased, 0, input.extent.0) {
     max_x[ramp(t240, 1, 64) aligned(64, 0)] = max(max_x[ramp(t240, 1, 64) aligned(64, 0)], input[ramp(max_x.s1.r6$x.rebased + t239, input.stride.1, 64)])
    }
   } else {
    let t244 = max_x.s1.y.y*64
    let t241 = output.extent.1 - t244
    let t242 = t237 + t244
    let t243 = output.min.1 + t244
    for (max_x.s1.r6$x.rebased, 0, input.extent.0) {
     let t245 = min(t241, 64)
     let t246 = max_x.s1.r6$x.rebased + t236
     for (max_x.s1.y.yi, 0, t245) {
      let t184 = max_x.s1.y.yi + t242
      max_x[t184 + 64] = max(max_x[t184 + 64], input[((max_x.s1.y.yi + t243)*input.stride.1) + t246])
     }
    }
   }
  }
 }
 allocate inv_sum_exp_row[int16 * max(output.extent.1, 64)]
 produce inv_sum_exp_row {
  consume max_x {
   let t249 = min(output.extent.1, 64)
   let t247 = (output.extent.1 + 63)/64
   let t248 = 0 - (input.min.1*input.stride.1)
   let t250 = (int16)15 - int16((uint16)beta_shift)
   parallel (inv_sum_exp_row.s0.y.y, 0, t247) {
    let inv_sum_exp_row.s0.y.yi.base.s = min(inv_sum_exp_row.s0.y.y*64, output.extent.1 + -64)
    allocate sum_exp_row[int32 * 64]
    produce sum_exp_row {
     sum_exp_row[ramp(0, 1, 16)] = x16(0)
     sum_exp_row[ramp(16, 1, 16)] = x16(0)
     sum_exp_row[ramp(32, 1, 16)] = x16(0)
     sum_exp_row[ramp(48, 1, 16)] = x16(0)
     let t254 = inv_sum_exp_row.s0.y.yi.base.s + output.min.1
     let t252 = inv_sum_exp_row.s0.y.yi.base.s - t249
     let t253 = ((t254 + 32)*input.stride.1) + t248
     let t251 = (input.stride.1*t254) + t248
     for (sum_exp_row.s1.r6$x.rebased, 0, input.extent.0) {
      let t185 = (int16x32)rounding_mul_shift_right((int16x32)shift_left(int16x32(input[ramp(sum_exp_row.s1.r6$x.rebased + t251, input.stride.1, 32)]), x32((uint16)6)) - (int16x32)shift_left(int16x32(max_x[ramp(t252 + 64, 1, 32)]), x32((uint16)6)), x32((int16)beta_multiplier), x32((uint16)15))
      let t186 = (int16x32)shift_right(t185, x32((uint16)beta_shift))
      let t187 = int16x32(max(min((int32x32)widening_shift_left(x32((int16)1), t186 + x32((int16)15)), x32(32767)), x32(-32768)))
      let t188 = (int16x32)shift_left(t185 - (int16x32)shift_left(t186, x32((uint16)beta_shift)), x32(t250))
      let t189 = (int16x32)rounding_mul_shift_right(t188, t188, x32((uint16)15))
      sum_exp_row[ramp(0, 1, 32)] = sum_exp_row[ramp(0, 1, 32)] + int32x32((int16x32)saturating_add(t187, (int16x32)rounding_mul_shift_right(t187, (int16x32)rounding_mul_shift_right(x32((int16)7363), t189, x32((uint16)15)) + ((int16x32)rounding_mul_shift_right(x32((int16)22812), t188, x32((uint16)15)) + (int16x32)rounding_mul_shift_right(x32((int16)2592), (int16x32)rounding_mul_shift_right(t189, t188, x32((uint16)15)), x32((uint16)15))), x32((uint16)15))))
      let t190 = (int16x32)rounding_mul_shift_right((int16x32)shift_left(int16x32(input[ramp(sum_exp_row.s1.r6$x.rebased + t253, input.stride.1, 32)]), x32((uint16)6)) - (int16x32)shift_left(int16x32(max_x[ramp(t252 + 96, 1, 32)]), x32((uint16)6)), x32((int16)beta_multiplier), x32((uint16)15))
      let t191 = (int16x32)shift_right(t190, x32((uint16)beta_shift))
      let t192 = int16x32(max(min((int32x32)widening_shift_left(x32((int16)1), t191 + x32((int16)15)), x32(32767)), x32(-32768)))
      let t193 = (int16x32)shift_left(t190 - (int16x32)shift_left(t191, x32((uint16)beta_shift)), x32(t250))
      let t194 = (int16x32)rounding_mul_shift_right(t193, t193, x32((uint16)15))
      sum_exp_row[ramp(32, 1, 32)] = sum_exp_row[ramp(32, 1, 32)] + int32x32((int16x32)saturating_add(t192, (int16x32)rounding_mul_shift_right(t192, (int16x32)rounding_mul_shift_right(x32((int16)7363), t194, x32((uint16)15)) + ((int16x32)rounding_mul_shift_right(x32((int16)22812), t193, x32((uint16)15)) + (int16x32)rounding_mul_shift_right(x32((int16)2592), (int16x32)rounding_mul_shift_right(t194, t193, x32((uint16)15)), x32((uint16)15))), x32((uint16)15))))
     }
    }
    consume sum_exp_row {
     let t195 = sum_exp_row[ramp(0, 1, 32)]
     let t196 = int16x32((int32x32)count_leading_zeros(t195))
     let t197 = (int16x32)bitwise_and(int16x32((int32x32)shift_left(t195, int32x32((t196 + x32((int16)-16))))), x32((int16)32767))
     let t198 = (int16x32)rounding_mul_shift_right(t197, t197, x32((uint16)15))
     let t199 = (int32x32)saturating_add((int32x32)widening_shift_left(x32((int16)31) - t196, x32((uint16)15)), (int32x32)widening_shift_left(((int16x32)rounding_mul_shift_right(x32((int16)-9421), t198, x32((uint16)15)) + ((int16x32)rounding_mul_shift_right(x32((int16)23249), t197, x32((uint16)15)) + (int16x32)rounding_mul_shift_right(x32((int16)2555), (int16x32)rounding_mul_shift_right(t198, t197, x32((uint16)15)), x32((uint16)15)))) + x32((int16)5), x32((uint16)1)))
     let t200 = int16x32(max(min((int32x32)widening_shift_left(x32((int16)1), int16x32((int32x32)shift_right(x32(0) - t199, x32((uint32)15))) + x32((int16)30)), x32(32767)), x32(-32768)))
     let t201 = int16x32(((x32(0) - t199) - (int32x32)widening_shift_left(int16x32((int32x32)shift_right(x32(0) - t199, x32((uint32)15))), x32((uint16)15))))
     let t202 = (int16x32)rounding_mul_shift_right(t201, t201, x32((uint16)15))
     inv_sum_exp_row[ramp((inv_sum_exp_row.s0.y.yi.base.s - t249) + 64, 1, 32)] = (int16x32)saturating_add(t200, (int16x32)rounding_mul_shift_right(t200, (int16x32)rounding_mul_shift_right(x32((int16)7363), t202, x32((uint16)15)) + ((int16x32)rounding_mul_shift_right(x32((int16)22812), t201, x32((uint16)15)) + (int16x32)rounding_mul_shift_right(x32((int16)2592), (int16x32)rounding_mul_shift_right(t202, t201, x32((uint16)15)), x32((uint16)15))), x32((uint16)15)))
     let t203 = sum_exp_row[ramp(32, 1, 32)]
     let t204 = int16x32((int32x32)count_leading_zeros(t203))
     let t205 = (int16x32)bitwise_and(int16x32((int32x32)shift_left(t203, int32x32((t204 + x32((int16)-16))))), x32((int16)32767))
     let t206 = (int16x32)rounding_mul_shift_right(t205, t205, x32((uint16)15))
     let t207 = (int32x32)saturating_add((int32x32)widening_shift_left(x32((int16)31) - t204, x32((uint16)15)), (int32x32)widening_shift_left(((int16x32)rounding_mul_shift_right(x32((int16)-9421), t206, x32((uint16)15)) + ((int16x32)rounding_mul_shift_right(x32((int16)23249), t205, x32((uint16)15)) + (int16x32)rounding_mul_shift_right(x32((int16)2555), (int16x32)rounding_mul_shift_right(t206, t205, x32((uint16)15)), x32((uint16)15)))) + x32((int16)5), x32((uint16)1)))
     let t208 = int16x32(max(min((int32x32)widening_shift_left(x32((int16)1), int16x32((int32x32)shift_right(x32(0) - t207, x32((uint32)15))) + x32((int16)30)), x32(32767)), x32(-32768)))
     let t209 = int16x32(((x32(0) - t207) - (int32x32)widening_shift_left(int16x32((int32x32)shift_right(x32(0) - t207, x32((uint32)15))), x32((uint16)15))))
     let t210 = (int16x32)rounding_mul_shift_right(t209, t209, x32((uint16)15))
     inv_sum_exp_row[ramp((inv_sum_exp_row.s0.y.yi.base.s - t249) + 96, 1, 32)] = (int16x32)saturating_add(t208, (int16x32)rounding_mul_shift_right(t208, (int16x32)rounding_mul_shift_right(x32((int16)7363), t210, x32((uint16)15)) + ((int16x32)rounding_mul_shift_right(x32((int16)22812), t209, x32((uint16)15)) + (int16x32)rounding_mul_shift_right(x32((int16)2592), (int16x32)rounding_mul_shift_right(t210, t209, x32((uint16)15)), x32((uint16)15))), x32((uint16)15)))
     free sum_exp_row
    }
   }
  }
 }
 produce output {
  consume inv_sum_exp_row {
   consume max_x {
    let t264 = output.min.1*output.stride.1
    let t265 = input.min.1*input.stride.1
    let t261 = (output.extent.0 % 64) != 0
    let t255 = (output.extent.1 + 16)/17
    let t256 = output.extent.0/64
    let t262 = ((output.extent.0 + output.min.0) - t265) - input.min.0
    let t258 = (output.min.0 - t265) - input.min.0
    let t263 = output.extent.0 - t264
    let t257 = 0 - min(output.extent.1, 64)
    let t260 = 0 - t264
    let t259 = (int16)15 - int16((uint16)beta_shift)
    parallel (output.s0.y.y, 0, t255) {
     let output.s0.y.yi.base.s = min(output.s0.y.y*17, output.extent.1 + -17)
     let t266 = output.s0.y.yi.base.s + t257
     let t267 = output.min.1 + output.s0.y.yi.base.s
     for (output.s0.y.yi, 0, 17) {
      let t271 = output.s0.y.yi + t267
      let t270 = (output.stride.1*t271) + t260
      let t269 = (input.stride.1*t271) + t258
      let t268 = output.s0.y.yi + t266
      for (output.s0.x.x, 0, t256) {
       let t214 = (int16x64)rounding_mul_shift_right((int16x64)shift_left(int16x64(input[ramp((output.s0.x.x*64) + t269, 1, 64)]), x64((uint16)6)) + x64(int16(max_x[t268 + 64])*(int16)-64), x64((int16)beta_multiplier), x64((uint16)15))
       let t215 = (int16x64)shift_right(t214, x64((uint16)beta_shift))
       let t216 = int16x64(max(min((int32x64)widening_shift_left(x64((int16)1), t215 + x64((int16)15)), x64(32767)), x64(-32768)))
       let t217 = (int16x64)shift_left(t214 - (int16x64)shift_left(t215, x64((uint16)beta_shift)), x64(t259))
       let t218 = (int16x64)rounding_mul_shift_right(t217, t217, x64((uint16)15))
       output[ramp((output.s0.x.x*64) + t270, 1, 64)] = uint8x64(max(min((int16x64)saturating_add((int16x64)rounding_shift_right((int16x64)rounding_mul_shift_right((int16x64)rounding_mul_shift_right((int16x64)saturating_add(t216, (int16x64)rounding_mul_shift_right(t216, (int16x64)rounding_mul_shift_right(x64((int16)7363), t218, x64((uint16)15)) + ((int16x64)rounding_mul_shift_right(x64((int16)22812), t217, x64((uint16)15)) + (int16x64)rounding_mul_shift_right(x64((int16)2592), (int16x64)rounding_mul_shift_right(t218, t217, x64((uint16)15)), x64((uint16)15))), x64((uint16)15))), x64(inv_sum_exp_row[t268 + 64]), x64((uint16)15)), x64((int16)output_multiplier), x64((uint16)15)), x64((uint16)output_shift)), x64(int16((uint8)output_zero))), x64((int16)255)), x64((int16)0)))
      }
      if (t261) {
       let t221 = output.s0.y.yi + t266
       let t222 = (int16x64)rounding_mul_shift_right((int16x64)shift_left(int16x64(input[ramp((((output.s0.y.yi + t267)*input.stride.1) + t262) + -64, 1, 64)]), x64((uint16)6)) + x64(int16(max_x[t221 + 64])*(int16)-64), x64((int16)beta_multiplier), x64((uint16)15))
       let t223 = (int16x64)shift_right(t222, x64((uint16)beta_shift))
       let t224 = int16x64(max(min((int32x64)widening_shift_left(x64((int16)1), t223 + x64((int16)15)), x64(32767)), x64(-32768)))
       let t225 = (int16x64)shift_left(t222 - (int16x64)shift_left(t223, x64((uint16)beta_shift)), x64(t259))
       let t226 = (int16x64)rounding_mul_shift_right(t225, t225, x64((uint16)15))
       output[ramp((((output.s0.y.yi + t267)*output.stride.1) + t263) + -64, 1, 64)] = uint8x64(max(min((int16x64)saturating_add((int16x64)rounding_shift_right((int16x64)rounding_mul_shift_right((int16x64)rounding_mul_shift_right((int16x64)saturating_add(t224, (int16x64)rounding_mul_shift_right(t224, (int16x64)rounding_mul_shift_right(x64((int16)7363), t226, x64((uint16)15)) + ((int16x64)rounding_mul_shift_right(x64((int16)22812), t225, x64((uint16)15)) + (int16x64)rounding_mul_shift_right(x64((int16)2592), (int16x64)rounding_mul_shift_right(t226, t225, x64((uint16)15)), x64((uint16)15))), x64((uint16)15))), x64(inv_sum_exp_row[t221 + 64]), x64((uint16)15)), x64((int16)output_multiplier), x64((uint16)15)), x64((uint16)output_shift)), x64(int16((uint8)output_zero))), x64((int16)255)), x64((int16)0)))
      }
     }
    }
   }
  }
 }
 free max_x
 free inv_sum_exp_row
}
}


