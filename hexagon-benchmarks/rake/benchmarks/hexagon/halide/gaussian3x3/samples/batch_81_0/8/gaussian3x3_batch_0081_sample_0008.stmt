module name=gaussian3x3_batch_0081_sample_0008, target=x86-64-linux-avx-avx2-disable_llvm_loop_opt-f16c-fma-sse41
external_plus_metadata func gaussian3x3_batch_0081_sample_0008 (input, output) {
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
let input.extent.0.required.s = max(min(min((min(output.extent.0, 32) + (((max(output.extent.0, 32) + 1)/32)*32)) + -2, output.extent.0) + output.min.0, (input.extent.0 + input.min.0) + -1), input.min.0) - max(min(min(output.extent.0, 32) + output.min.0, (input.extent.0 + input.min.0) + 32) + -33, input.min.0)
let input.min.0.required = max(min(min(output.extent.0, 32) + output.min.0, (input.extent.0 + input.min.0) + 32) + -33, input.min.0)
let input.extent.1.required.s = max(min(output.extent.1 + output.min.1, (input.extent.1 + input.min.1) + -1), input.min.1) - max(min(min(output.extent.1, 34) + output.min.1, (input.extent.1 + input.min.1) + 34) + -35, input.min.1)
let input.min.1.required = max(min(min(output.extent.1, 34) + output.min.1, (input.extent.1 + input.min.1) + 34) + -35, input.min.1)
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)input.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)input.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 8, 2, (halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required.s + 1, 1, 0, input.min.1.required, input.extent.1.required.s + 1, input.extent.0.required.s + 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)output.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)output.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 8, 2, (halide_dimension_t *)make_struct((min(output.extent.0, 32) + output.min.0) + -32, max(output.extent.0, 32), 1, 0, (min(output.extent.1, 34) + output.min.1) + -34, max(output.extent.1, 34), max(output.extent.0, 32), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || (uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer))) {
 assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
 assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
 assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
 assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
 assert((input.min.0 <= input.min.0.required) && (((input.extent.0.required.s + input.min.0.required) + 1) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, input.extent.0.required.s + input.min.0.required, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && (((input.extent.1.required.s + input.min.1.required) + 1) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, input.extent.1.required.s + input.min.1.required, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert(32 <= output.extent.0, halide_error_access_out_of_bounds("Output buffer output", 0, (min(output.extent.0, 32) + output.min.0) + -32, (output.extent.0 + output.min.0) + -1, output.min.0, (output.extent.0 + output.min.0) + -1))
 assert(34 <= output.extent.1, halide_error_access_out_of_bounds("Output buffer output", 1, (min(output.extent.1, 34) + output.min.1) + -34, (output.extent.1 + output.min.1) + -1, output.min.1, (output.extent.1 + output.min.1) + -1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert(uint64(output.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", uint64(output.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1)), (uint64)2147483647))
 assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(!output.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer output"))
 assert(input != (void *)reinterpret((uint64)0), halide_error_host_is_null("Input buffer input"))
 assert(output != (void *)reinterpret((uint64)0), halide_error_host_is_null("Output buffer output"))
 produce output {
  let output.s0.y.y.prologue = min((output.extent.1 + 33)/34, max((input.min.1 - output.min.1)/34, -1) + 1)
  let output.s0.y.y.epilogue = max(min((output.extent.1 + 33)/34, max((input.min.1 - output.min.1)/34, -1) + 1), min(((input.extent.1 + input.min.1) - output.min.1) + -1, output.extent.1)/34)
  let t221 = input.extent.0 + input.min.0
  let t222 = output.min.1*output.stride.1
  let t223 = (output.extent.0 + 33)/32
  let t224 = min(max((input.min.0 - output.min.0)/32, -1) + 1, t223)
  let t225 = t221 - output.min.0
  let t226 = output.extent.0 + 1
  let t218 = (output.extent.0 % 32) != 0
  let t210 = max((min(min(min(output.extent.0 + -30, t225), min(t225, t226) + -31), t226)/32) + 1, t224)
  let t207 = (output.extent.1 + 33)/34
  let t215 = (output.extent.0 + 127)/128
  let t220 = (output.extent.0 + 31)/32
  let t216 = output.extent.0/32
  let t208 = ((output.extent.0 + -1)/128)*128
  let t211 = output.min.1 - input.min.1
  let t219 = output.extent.0 - t222
  let t217 = 0 - t222
  parallel (output.s0.y.y, 0, t207) {
   if ((output.s0.y.y.prologue <= output.s0.y.y) && (output.s0.y.y < output.s0.y.y.epilogue)) {
    let output.s0.y.yi.base.s = min(output.s0.y.y*34, output.extent.1 + -34)
    allocate repeat_edge[uint8 * (t208 + 144) * 4] in Stack
    let t231 = t223 - t210
    let t227 = output.s0.y.yi.base.s + t211
    let t228 = output.min.1 + output.s0.y.yi.base.s
    for (output.s0.y.yi.$n.rebased, 0, 36) {
     produce repeat_edge {
      let t233 = (((output.s0.y.yi.$n.rebased + t228) + 3) % 4)*(t208 + 144)
      let t232 = (((output.s0.y.yi.$n.rebased + t227) + -1)*input.stride.1) - input.min.0
      for (repeat_edge.s0._0._0, 0, t224) {
       let repeat_edge.s0._0._0i.base.s = min((repeat_edge.s0._0._0*32) + 30, output.extent.0)
       repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t233) + -30, 1, 32)] = input[max(min(ramp((output.min.0 + repeat_edge.s0._0._0i.base.s) + -31, 1, 32), x32(t221 + -1)), x32(input.min.0)) + x32(t232)]
      }
      let t236 = (((output.s0.y.yi.$n.rebased + t228) + 3) % 4)*(t208 + 144)
      let t234 = t210 - t224
      let t235 = (((output.s0.y.yi.$n.rebased + t227) + -1)*input.stride.1) + (output.min.0 - input.min.0)
      for (repeat_edge.s0._0._0.rebased, 0, t234) {
       let t188 = repeat_edge.s0._0._0.rebased + t224
       repeat_edge[ramp((t188*32) + t236, 1, 32) aligned(16, 0)] = input[ramp(((t188*32) + t235) + -1, 1, 32)]
      }
      let t238 = (((output.s0.y.yi.$n.rebased + t228) + 3) % 4)*(t208 + 144)
      let t237 = (((output.s0.y.yi.$n.rebased + t227) + -1)*input.stride.1) - input.min.0
      for (repeat_edge.s0._0._0.rebased, 0, t231) {
       let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0.rebased + t210)*32) + 30, output.extent.0)
       repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t238) + -30, 1, 32)] = input[max(min(ramp((output.min.0 + repeat_edge.s0._0._0i.base.s) + -31, 1, 32), x32(t221 + -1)), x32(input.min.0)) + x32(t237)]
      }
     }
     if (2 <= output.s0.y.yi.$n.rebased) {
      consume repeat_edge {
       allocate cols[int16 * (t208 + 128) * 1] in Stack
       produce cols {
        let t239 = output.s0.y.yi.$n.rebased + t228
        for (cols.s0.x.x, 0, t215) {
         allocate rows[int16 * 144] in Stack
         produce rows {
          rows[ramp(0, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp((((t239 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128), 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp((((t239 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128), 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp((((t239 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128), 1, 16) aligned(16, 0)])
          rows[ramp(16, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t239 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 16, 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp(((((t239 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 16, 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp(((((t239 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 16, 1, 16) aligned(16, 0)])
          rows[ramp(32, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t239 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 32, 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp(((((t239 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 32, 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp(((((t239 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 32, 1, 16) aligned(16, 0)])
          rows[ramp(48, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t239 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 48, 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp(((((t239 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 48, 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp(((((t239 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 48, 1, 16) aligned(16, 0)])
          rows[ramp(64, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t239 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 64, 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp(((((t239 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 64, 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp(((((t239 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 64, 1, 16) aligned(16, 0)])
          rows[ramp(80, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t239 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 80, 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp(((((t239 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 80, 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp(((((t239 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 80, 1, 16) aligned(16, 0)])
          rows[ramp(96, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t239 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 96, 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp(((((t239 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 96, 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp(((((t239 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 96, 1, 16) aligned(16, 0)])
          rows[ramp(112, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t239 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 112, 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp(((((t239 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 112, 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp(((((t239 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 112, 1, 16) aligned(16, 0)])
          rows[ramp(128, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t239 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 128, 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp(((((t239 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 128, 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp(((((t239 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 128, 1, 16) aligned(16, 0)])
         }
         consume rows {
          cols[ramp(cols.s0.x.x*128, 1, 16) aligned(128, 0)] = (int16x16)shift_left(rows[ramp(1, 1, 16)], x16((uint16)1)) + (rows[ramp(2, 1, 16)] + rows[ramp(0, 1, 16)])
          cols[ramp((cols.s0.x.x*128) + 16, 1, 16) aligned(128, 16)] = (int16x16)shift_left(rows[ramp(17, 1, 16)], x16((uint16)1)) + (rows[ramp(18, 1, 16)] + rows[ramp(16, 1, 16)])
          cols[ramp((cols.s0.x.x*128) + 32, 1, 16) aligned(128, 32)] = (int16x16)shift_left(rows[ramp(33, 1, 16)], x16((uint16)1)) + (rows[ramp(34, 1, 16)] + rows[ramp(32, 1, 16)])
          cols[ramp((cols.s0.x.x*128) + 48, 1, 16) aligned(128, 48)] = (int16x16)shift_left(rows[ramp(49, 1, 16)], x16((uint16)1)) + (rows[ramp(50, 1, 16)] + rows[ramp(48, 1, 16)])
          cols[ramp((cols.s0.x.x*128) + 64, 1, 16) aligned(128, 64)] = (int16x16)shift_left(rows[ramp(65, 1, 16)], x16((uint16)1)) + (rows[ramp(66, 1, 16)] + rows[ramp(64, 1, 16)])
          cols[ramp((cols.s0.x.x*128) + 80, 1, 16) aligned(128, 80)] = (int16x16)shift_left(rows[ramp(81, 1, 16)], x16((uint16)1)) + (rows[ramp(82, 1, 16)] + rows[ramp(80, 1, 16)])
          cols[ramp((cols.s0.x.x*128) + 96, 1, 16) aligned(128, 96)] = (int16x16)shift_left(rows[ramp(97, 1, 16)], x16((uint16)1)) + (rows[ramp(98, 1, 16)] + rows[ramp(96, 1, 16)])
          cols[ramp((cols.s0.x.x*128) + 112, 1, 16) aligned(128, 112)] = (int16x16)shift_left(rows[ramp(113, 1, 16)], x16((uint16)1)) + (rows[ramp(114, 1, 16)] + rows[ramp(112, 1, 16)])
          free rows
         }
        }
       }
       consume cols {
        let t240 = (((output.s0.y.yi.$n.rebased + t228) + -2)*output.stride.1) + t217
        for (output.s0.x.x, 0, t216) {
         output[ramp((output.s0.x.x*32) + t240, 1, 32)] = uint8x32((int16x32)shift_right(cols[ramp(output.s0.x.x*32, 1, 32) aligned(32, 0)] + x32((int16)8), x32((uint16)4)))
        }
        if (t218) {
         output[ramp(((((output.s0.y.yi.$n.rebased + t228) + -2)*output.stride.1) + t219) + -32, 1, 32)] = uint8x32((int16x32)shift_right(cols[ramp(output.extent.0 + -32, 1, 32)] + x32((int16)8), x32((uint16)4)))
        }
        free cols
       }
      }
     }
    }
    free repeat_edge
   } else {
    let output.s0.y.yi.base.s = min(output.s0.y.y*34, output.extent.1 + -34)
    allocate repeat_edge[uint8 * (t208 + 144) * 4] in Stack
    let t241 = output.s0.y.yi.base.s + t211
    let t242 = output.min.1 + output.s0.y.yi.base.s
    for (output.s0.y.yi.$n.rebased, 0, 36) {
     produce repeat_edge {
      let t244 = (((output.s0.y.yi.$n.rebased + t242) + 3) % 4)*(t208 + 144)
      let t243 = ((max(min(output.s0.y.yi.$n.rebased + t241, input.extent.1), 1) + -1)*input.stride.1) - input.min.0
      for (repeat_edge.s0._0._0, 0, t223) {
       let repeat_edge.s0._0._0i.base.s = min((repeat_edge.s0._0._0*32) + 30, output.extent.0)
       repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t244) + -30, 1, 32)] = input[max(min(ramp((output.min.0 + repeat_edge.s0._0._0i.base.s) + -31, 1, 32), x32(t221 + -1)), x32(input.min.0)) + x32(t243)]
      }
     }
     if (2 <= output.s0.y.yi.$n.rebased) {
      consume repeat_edge {
       allocate cols[int16 * (t208 + 128) * 1] in Stack
       produce cols {
        let t245 = output.s0.y.yi.$n.rebased + t242
        for (cols.s0.x.x, 0, t215) {
         allocate rows[int16 * 144] in Stack
         produce rows {
          rows[ramp(0, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp((((t245 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128), 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp((((t245 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128), 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp((((t245 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128), 1, 16) aligned(16, 0)])
          rows[ramp(16, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t245 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 16, 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp(((((t245 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 16, 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp(((((t245 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 16, 1, 16) aligned(16, 0)])
          rows[ramp(32, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t245 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 32, 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp(((((t245 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 32, 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp(((((t245 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 32, 1, 16) aligned(16, 0)])
          rows[ramp(48, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t245 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 48, 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp(((((t245 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 48, 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp(((((t245 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 48, 1, 16) aligned(16, 0)])
          rows[ramp(64, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t245 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 64, 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp(((((t245 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 64, 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp(((((t245 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 64, 1, 16) aligned(16, 0)])
          rows[ramp(80, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t245 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 80, 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp(((((t245 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 80, 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp(((((t245 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 80, 1, 16) aligned(16, 0)])
          rows[ramp(96, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t245 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 96, 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp(((((t245 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 96, 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp(((((t245 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 96, 1, 16) aligned(16, 0)])
          rows[ramp(112, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t245 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 112, 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp(((((t245 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 112, 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp(((((t245 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 112, 1, 16) aligned(16, 0)])
          rows[ramp(128, 1, 16)] = ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t245 + 2) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 128, 1, 16) aligned(16, 0)]), x16((uint16)1)) + int16x16(repeat_edge[ramp(((((t245 + 1) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 128, 1, 16) aligned(16, 0)])) + int16x16(repeat_edge[ramp(((((t245 + 3) % 4)*(t208 + 144)) + (cols.s0.x.x*128)) + 128, 1, 16) aligned(16, 0)])
         }
         consume rows {
          cols[ramp(cols.s0.x.x*128, 1, 16) aligned(128, 0)] = (int16x16)shift_left(rows[ramp(1, 1, 16)], x16((uint16)1)) + (rows[ramp(2, 1, 16)] + rows[ramp(0, 1, 16)])
          cols[ramp((cols.s0.x.x*128) + 16, 1, 16) aligned(128, 16)] = (int16x16)shift_left(rows[ramp(17, 1, 16)], x16((uint16)1)) + (rows[ramp(18, 1, 16)] + rows[ramp(16, 1, 16)])
          cols[ramp((cols.s0.x.x*128) + 32, 1, 16) aligned(128, 32)] = (int16x16)shift_left(rows[ramp(33, 1, 16)], x16((uint16)1)) + (rows[ramp(34, 1, 16)] + rows[ramp(32, 1, 16)])
          cols[ramp((cols.s0.x.x*128) + 48, 1, 16) aligned(128, 48)] = (int16x16)shift_left(rows[ramp(49, 1, 16)], x16((uint16)1)) + (rows[ramp(50, 1, 16)] + rows[ramp(48, 1, 16)])
          cols[ramp((cols.s0.x.x*128) + 64, 1, 16) aligned(128, 64)] = (int16x16)shift_left(rows[ramp(65, 1, 16)], x16((uint16)1)) + (rows[ramp(66, 1, 16)] + rows[ramp(64, 1, 16)])
          cols[ramp((cols.s0.x.x*128) + 80, 1, 16) aligned(128, 80)] = (int16x16)shift_left(rows[ramp(81, 1, 16)], x16((uint16)1)) + (rows[ramp(82, 1, 16)] + rows[ramp(80, 1, 16)])
          cols[ramp((cols.s0.x.x*128) + 96, 1, 16) aligned(128, 96)] = (int16x16)shift_left(rows[ramp(97, 1, 16)], x16((uint16)1)) + (rows[ramp(98, 1, 16)] + rows[ramp(96, 1, 16)])
          cols[ramp((cols.s0.x.x*128) + 112, 1, 16) aligned(128, 112)] = (int16x16)shift_left(rows[ramp(113, 1, 16)], x16((uint16)1)) + (rows[ramp(114, 1, 16)] + rows[ramp(112, 1, 16)])
          free rows
         }
        }
       }
       consume cols {
        let t246 = (((output.s0.y.yi.$n.rebased + t242) + -2)*output.stride.1) + t217
        for (output.s0.x.x, 0, t220) {
         let output.s0.x.xi.base.s = min(output.s0.x.x*32, output.extent.0 + -32)
         output[ramp(output.s0.x.xi.base.s + t246, 1, 32)] = uint8x32((int16x32)shift_right(cols[ramp(output.s0.x.xi.base.s, 1, 32)] + x32((int16)8), x32((uint16)4)))
        }
       }
       free cols
      }
     }
    }
    free repeat_edge
   }
  }
 }
}
}


