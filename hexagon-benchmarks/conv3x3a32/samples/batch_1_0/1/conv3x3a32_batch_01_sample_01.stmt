module name=conv3x3a32_batch_01_sample_01, target=x86-64-linux-avx-avx2-avx512-avx512_skylake-disable_llvm_loop_unroll-disable_llvm_loop_vectorize-f16c-fma-sse41
external_plus_metadata func conv3x3a32_batch_01_sample_01 (input, mask, output) {
assert((reinterpret(uint64, output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output"))
assert((reinterpret(uint64, mask.buffer) != (uint64)0), halide_error_buffer_argument_is_null("mask"))
assert((reinterpret(uint64, input.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input"))
let input = _halide_buffer_get_host(input.buffer)
let input.type = _halide_buffer_get_type(input.buffer)
let input.dimensions = _halide_buffer_get_dimensions(input.buffer)
let input.min.0 = _halide_buffer_get_min(input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent(input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride(input.buffer, 0)
let input.min.1 = _halide_buffer_get_min(input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent(input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride(input.buffer, 1)
let mask = _halide_buffer_get_host(mask.buffer)
let mask.type = _halide_buffer_get_type(mask.buffer)
let mask.dimensions = _halide_buffer_get_dimensions(mask.buffer)
let mask.min.0 = _halide_buffer_get_min(mask.buffer, 0)
let mask.extent.0 = _halide_buffer_get_extent(mask.buffer, 0)
let mask.stride.0 = _halide_buffer_get_stride(mask.buffer, 0)
let mask.min.1 = _halide_buffer_get_min(mask.buffer, 1)
let mask.extent.1 = _halide_buffer_get_extent(mask.buffer, 1)
let mask.stride.1 = _halide_buffer_get_stride(mask.buffer, 1)
let output = _halide_buffer_get_host(output.buffer)
let output.type = _halide_buffer_get_type(output.buffer)
let output.dimensions = _halide_buffer_get_dimensions(output.buffer)
let output.min.0 = _halide_buffer_get_min(output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent(output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride(output.buffer, 0)
let output.min.1 = _halide_buffer_get_min(output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent(output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride(output.buffer, 1)
let input.extent.0.required.s = (max(min(((input.extent.0 + input.min.0) + -1), output.extent.0), input.min.0) - max((min(min(((input.extent.0 + input.min.0) + 62), output.extent.0), 62) + -63), input.min.0))
let input.min.0.required = max((min(min(((input.extent.0 + input.min.0) + 62), output.extent.0), 62) + -63), input.min.0)
let input.extent.1.required.s = (max(min(((input.extent.1 + input.min.1) + -1), output.extent.1), input.min.1) - max((min((input.extent.1 + input.min.1), 0) + -1), input.min.1))
let input.min.1.required = max((min((input.extent.1 + input.min.1), 0) + -1), input.min.1)
assert((!_halide_buffer_is_bounds_query(input.buffer) || ((0 <= input.min.0.required) && (input.min.0.required <= 0))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, input.extent.0.required.s, input.min.0.required, (input.extent.0.required.s + input.min.0.required)))
assert((!_halide_buffer_is_bounds_query(input.buffer) || ((0 <= input.min.1.required) && (input.min.1.required <= 0))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, input.extent.1.required.s, input.min.1.required, (input.extent.1.required.s + input.min.1.required)))
assert((!_halide_buffer_is_bounds_query(output.buffer) || (64 <= output.extent.0)), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, 0, 63, (output.extent.0 + -64), (output.extent.0 + -1)))
assert((!_halide_buffer_is_bounds_query(output.buffer) || (32 <= output.extent.1)), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, 0, 31, (output.extent.1 + -32), (output.extent.1 + -1)))
if (_halide_buffer_is_bounds_query(input.buffer)) {
  _halide_buffer_init(input.buffer, _halide_buffer_get_shape(input.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 2, make_struct((halide_dimension_t *), 0, (input.extent.0.required.s + 1), 1, 0, 0, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1), 0), (uint64)0)
}
if (_halide_buffer_is_bounds_query(mask.buffer)) {
  _halide_buffer_init(mask.buffer, _halide_buffer_get_shape(mask.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 8, 2, make_struct((halide_dimension_t *), 0, 3, 1, 0, 0, 3, 3, 0), (uint64)0)
}
if (_halide_buffer_is_bounds_query(output.buffer)) {
  _halide_buffer_init(output.buffer, _halide_buffer_get_shape(output.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 2, make_struct((halide_dimension_t *), 0, max(output.extent.0, 64), 1, 0, 0, max(output.extent.1, 32), max(output.extent.0, 64), 0), (uint64)0)
}
if (!(_halide_buffer_is_bounds_query(output.buffer) || (_halide_buffer_is_bounds_query(input.buffer) || _halide_buffer_is_bounds_query(mask.buffer)))) {
  assert((input.type == (uint32)67585), halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
  assert((input.dimensions == 2), halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
  assert((mask.type == (uint32)67584), halide_error_bad_type("Input buffer mask", mask.type, (uint32)67584))
  assert((mask.dimensions == 2), halide_error_bad_dimensions("Input buffer mask", mask.dimensions, 2))
  assert((output.type == (uint32)67585), halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
  assert((output.dimensions == 2), halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
  assert(((input.min.0 <= input.min.0.required) && (((input.extent.0.required.s + input.min.0.required) + 1) <= (input.extent.0 + input.min.0))), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.extent.0.required.s + input.min.0.required), input.min.0, ((input.extent.0 + input.min.0) + -1)))
  assert((0 <= input.extent.0), halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
  assert(((input.min.1 <= input.min.1.required) && (((input.extent.1.required.s + input.min.1.required) + 1) <= (input.extent.1 + input.min.1))), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.extent.1.required.s + input.min.1.required), input.min.1, ((input.extent.1 + input.min.1) + -1)))
  assert((0 <= input.extent.1), halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
  assert(((mask.min.0 <= 0) && (3 <= (mask.extent.0 + mask.min.0))), halide_error_access_out_of_bounds("Input buffer mask", 0, 0, 2, mask.min.0, ((mask.extent.0 + mask.min.0) + -1)))
  assert((0 <= mask.extent.0), halide_error_buffer_extents_negative("Input buffer mask", 0, mask.extent.0))
  assert(((mask.min.1 <= 0) && (3 <= (mask.extent.1 + mask.min.1))), halide_error_access_out_of_bounds("Input buffer mask", 1, 0, 2, mask.min.1, ((mask.extent.1 + mask.min.1) + -1)))
  assert((0 <= mask.extent.1), halide_error_buffer_extents_negative("Input buffer mask", 1, mask.extent.1))
  assert((((output.min.0 + 64) <= min(output.extent.0, 64)) && (0 <= output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, (min(output.extent.0, 64) + -64), (output.extent.0 + -1), output.min.0, ((output.extent.0 + output.min.0) + -1)))
  assert((0 <= output.extent.0), halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
  assert((((output.min.1 + 32) <= min(output.extent.1, 32)) && (0 <= output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, (min(output.extent.1, 32) + -32), (output.extent.1 + -1), output.min.1, ((output.extent.1 + output.min.1) + -1)))
  assert((0 <= output.extent.1), halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
  assert((input.stride.0 == 1), halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
  assert((input.min.0 == 0), halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
  assert((input.min.1 == 0), halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
  assert((mask.stride.0 == 1), halide_error_constraint_violated("mask.stride.0", mask.stride.0, "1", 1))
  assert((output.stride.0 == 1), halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
  assert((output.min.0 == 0), halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
  assert((output.min.1 == 0), halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let mask.total_extent.1 = (int64(mask.extent.1)*int64(mask.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((abs(int64(input.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("input", abs(int64(input.extent.0)), (uint64)2147483647))
  assert((abs((int64(input.extent.1)*int64(input.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("input", abs((int64(input.extent.1)*int64(input.stride.1))), (uint64)2147483647))
  assert((input.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
  assert((abs(int64(mask.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("mask", abs(int64(mask.extent.0)), (uint64)2147483647))
  assert((abs((int64(mask.extent.1)*int64(mask.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("mask", abs((int64(mask.extent.1)*int64(mask.stride.1))), (uint64)2147483647))
  assert((mask.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("mask", mask.total_extent.1, (int64)2147483647))
  assert((abs(int64(output.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("output", abs(int64(output.extent.0)), (uint64)2147483647))
  assert((abs((int64(output.extent.1)*int64(output.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("output", abs((int64(output.extent.1)*int64(output.stride.1))), (uint64)2147483647))
  assert((output.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
  assert((input != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Input buffer input"))
  assert((mask != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Input buffer mask"))
  assert((output != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer output"))
  produce output {
    let t137 = max(output.extent.0, 64)
    let t138 = min(output.extent.0, 64)
    let t135 = (0 < (output.extent.0 % 64))
    let t130 = max((128 - t138), (min((min((input.extent.0 - t138), ((min((input.extent.0 + 62), output.extent.0) - t138) + 1)) + 63), t137) + 2))
    let t124 = ((t137 + 65)/64)
    let t121 = ((output.extent.1 + 31)/32)
    let t131 = (output.extent.0/64)
    let t133 = (mask.min.1*mask.stride.1)
    let t122 = (output.extent.1 + -32)
    let t126 = (output.extent.0 + 2)
    let t136 = (output.extent.0 + -64)
    let t128 = (input.extent.0 + -1)
    parallel (output.s0.y.y, 0, t121) {
      let output.s0.y.yi.base = min((output.s0.y.y*32), t122)
      let t162 = (t130/64)
      let t163 = ((0 - t138)/64)
      let t143 = min((output.s0.y.y*32), t122)
      let t151 = (((mask.stride.1*2) - t133) - mask.min.0)
      let t150 = ((mask.stride.1 - t133) - mask.min.0)
      let t154 = ((2 - t133) - mask.min.0)
      let t153 = ((1 - t133) - mask.min.0)
      let t152 = ((0 - t133) - mask.min.0)
      let t146 = (t163 + 2)
      let t147 = ((t162 - t163) + -2)
      for (output.s0.y.yi.yi, 0, 2) {
        allocate repeat_edge[uint8 * (t137 + 2) * 18] in Stack
        produce repeat_edge {
          let repeat_edge.s0._1.prologue.s = min(max(((output.s0.y.yi.yi*16) + output.s0.y.yi.base), 1), (((output.s0.y.yi.yi*16) + output.s0.y.yi.base) + 18))
          let repeat_edge.s0._1.epilogue = max(min((((output.s0.y.yi.yi*16) + output.s0.y.yi.base) + 17), input.extent.1), (min(max(((output.s0.y.yi.yi*16) + output.s0.y.yi.base), 1), (((output.s0.y.yi.yi*16) + output.s0.y.yi.base) + 18)) + -1))
          let t169 = (output.s0.y.yi.yi*16)
          let t170 = (t143 + t169)
          let t165 = ((min(max(t170, 1), (t170 + 18)) - t143) - t169)
          let t167 = ((1 - output.s0.y.yi.base) - t169)
          let t164 = ((output.s0.y.yi.base + t169) + -1)
          let t168 = (t137 + 2)
          let t166 = (input.extent.1 + -1)
          for (repeat_edge.s0._1, t164, t165) {
            let t171 = (max(min(repeat_edge.s0._1, t166), 0)*input.stride.1)
            let t172 = (((repeat_edge.s0._1 + t167)*t168) - t138)
            for (repeat_edge.s0._0._0, 0, t124) {
              let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0*64) + t138), t126)
              repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t172), 1, 64)] = input[(max(min(ramp((repeat_edge.s0._0._0i.base.s + -65), 1, 64), x64(t128)), x64(0)) + x64(t171))]
            }
          }
          let t178 = (output.s0.y.yi.yi*16)
          let t179 = (t143 + t178)
          let t175 = ((1 - output.s0.y.yi.base) - t178)
          let t177 = (t124 - t162)
          let t174 = (max((min((t179 + 17), input.extent.1) - min(max(t179, 1), (t179 + 18))), -1) + 1)
          let t176 = (t137 + 2)
          let t173 = (repeat_edge.s0._1.prologue.s + -1)
          for (repeat_edge.s0._1, t173, t174) {
            let t180 = (input.stride.1*repeat_edge.s0._1)
            let t181 = (((repeat_edge.s0._1 + t175)*t176) - t138)
            for (repeat_edge.s0._0._0, 0, t146) {
              let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0*64) + t138), t126)
              repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t181), 1, 64)] = input[(max(min(ramp((repeat_edge.s0._0._0i.base.s + -65), 1, 64), x64(t128)), x64(0)) + x64(t180))]
            }
            let t183 = (((repeat_edge.s0._1 + t175)*t176) - t138)
            let t182 = ((input.stride.1*repeat_edge.s0._1) + -65)
            for (repeat_edge.s0._0._0, t146, t147) {
              let repeat_edge.s0._0._0i.base.s = ((repeat_edge.s0._0._0*64) + t138)
              repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t183), 1, 64)] = input[ramp((repeat_edge.s0._0._0i.base.s + t182), 1, 64)]
            }
            let t184 = (input.stride.1*repeat_edge.s0._1)
            let t185 = (((repeat_edge.s0._1 + t175)*t176) - t138)
            for (repeat_edge.s0._0._0, t162, t177) {
              let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0*64) + t138), t126)
              repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t185), 1, 64)] = input[(max(min(ramp((repeat_edge.s0._0._0i.base.s + -65), 1, 64), x64(t128)), x64(0)) + x64(t184))]
            }
          }
          let t190 = (output.s0.y.yi.yi*16)
          let t191 = (t143 + t190)
          let t188 = ((1 - output.s0.y.yi.base) - t190)
          let t186 = ((t191 - max(min((t191 + 17), input.extent.1), (min(max(t191, 1), (t191 + 18)) + -1))) + 17)
          let t189 = (t137 + 2)
          let t187 = (input.extent.1 + -1)
          for (repeat_edge.s0._1, repeat_edge.s0._1.epilogue, t186) {
            let t192 = (max(min(repeat_edge.s0._1, t187), 0)*input.stride.1)
            let t193 = (((repeat_edge.s0._1 + t188)*t189) - t138)
            for (repeat_edge.s0._0._0, 0, t124) {
              let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0*64) + t138), t126)
              repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t193), 1, 64)] = input[(max(min(ramp((repeat_edge.s0._0._0i.base.s + -65), 1, 64), x64(t128)), x64(0)) + x64(t192))]
            }
          }
        }
        consume repeat_edge {
          let t202 = ((output.s0.y.yi.yi*16) + output.s0.y.yi.base)
          for (output.s0.y.yi.yii, 0, 16) {
            let t215 = ((output.s0.y.yi.yii + t202)*output.stride.1)
            let t207 = (((output.s0.y.yi.yii + 1)*(t137 + 2)) - t138)
            for (output.s0.x.x, 0, t131) {
              output[ramp(((output.s0.x.x*64) + t215), 1, 64)] = uint8x64(max(min((((((((((int32x64((int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t207) - t137) + 62), 1, 64)])*x64(int16(mask[t152])))) + int32x64((int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t207) - t137) + 63), 1, 64)])*x64(int16(mask[t153]))))) + int32x64((int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t207) - t137) + 64), 1, 64)])*x64(int16(mask[t154]))))) + int32x64((int16x64(repeat_edge[ramp((((output.s0.x.x*64) + t207) + 64), 1, 64)])*x64(int16(mask[t150]))))) + int32x64((int16x64(repeat_edge[ramp((((output.s0.x.x*64) + t207) + 65), 1, 64)])*x64(int16(mask[(t150 + 1)]))))) + int32x64((int16x64(repeat_edge[ramp((((output.s0.x.x*64) + t207) + 66), 1, 64)])*x64(int16(mask[(t150 + 2)]))))) + int32x64((int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t207) + t137) + 66), 1, 64)])*x64(int16(mask[t151]))))) + int32x64((int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t207) + t137) + 67), 1, 64)])*x64(int16(mask[(t151 + 1)]))))) + int32x64((int16x64(repeat_edge[ramp(((((output.s0.x.x*64) + t207) + t137) + 68), 1, 64)])*x64(int16(mask[(t151 + 2)])))))/x64(16)), x64(255)), x64(0)))
            }
            if (t135) {
              output[ramp((((output.s0.y.yi.yii + t202)*output.stride.1) + t136), 1, 64)] = (let t116 = ((output.s0.y.yi.yii + 1)*(t137 + 2)) in uint8x64(max(min((((((((((int32x64((int16x64(repeat_edge[ramp((t116 + -66), 1, 64)])*x64(int16(mask[t152])))) + int32x64((int16x64(repeat_edge[ramp((t116 + -65), 1, 64)])*x64(int16(mask[t153]))))) + int32x64((int16x64(repeat_edge[ramp((t116 + -64), 1, 64)])*x64(int16(mask[t154]))))) + int32x64((int16x64(repeat_edge[ramp(((t116 + t137) + -64), 1, 64)])*x64(int16(mask[t150]))))) + int32x64((int16x64(repeat_edge[ramp(((t116 + t137) + -63), 1, 64)])*x64(int16(mask[(t150 + 1)]))))) + int32x64((int16x64(repeat_edge[ramp(((t116 + t137) + -62), 1, 64)])*x64(int16(mask[(t150 + 2)]))))) + int32x64((int16x64(repeat_edge[ramp((((t137*2) + t116) + -62), 1, 64)])*x64(int16(mask[t151]))))) + int32x64((int16x64(repeat_edge[ramp((((t137*2) + t116) + -61), 1, 64)])*x64(int16(mask[(t151 + 1)]))))) + int32x64((int16x64(repeat_edge[ramp((((t137*2) + t116) + -60), 1, 64)])*x64(int16(mask[(t151 + 2)])))))/x64(16)), x64(255)), x64(0))))
            }
          }
        }
        free repeat_edge
      }
    }
  }
}
}


