module name=median3x3_batch_05_sample_02, target=x86-64-linux-avx-avx2-avx512-avx512_skylake-disable_llvm_loop_unroll-disable_llvm_loop_vectorize-f16c-fma-sse41
external_plus_metadata func median3x3_batch_05_sample_02 (input, output) {
assert((reinterpret(uint64, output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output"))
assert((reinterpret(uint64, input.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input"))
let input = _halide_buffer_get_host(input.buffer)
let input.type = _halide_buffer_get_type(input.buffer)
let input.dimensions = _halide_buffer_get_dimensions(input.buffer)
let input.min.0 = _halide_buffer_get_min(input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent(input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride(input.buffer, 0)
let input.min.1 = _halide_buffer_get_min(input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent(input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride(input.buffer, 1)
let output = _halide_buffer_get_host(output.buffer)
let output.type = _halide_buffer_get_type(output.buffer)
let output.dimensions = _halide_buffer_get_dimensions(output.buffer)
let output.min.0 = _halide_buffer_get_min(output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent(output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride(output.buffer, 0)
let output.min.1 = _halide_buffer_get_min(output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent(output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride(output.buffer, 1)
let input.extent.0.required.s = (max(min(((input.extent.0 + input.min.0) + -1), output.extent.0), input.min.0) - max((min(min(((input.extent.0 + input.min.0) + 62), output.extent.0), 62) + -63), input.min.0))
let input.min.0.required = max((min(min(((input.extent.0 + input.min.0) + 62), output.extent.0), 62) + -63), input.min.0)
let input.extent.1.required.s = (max(min(((input.extent.1 + input.min.1) + -1), output.extent.1), input.min.1) - max((min((input.extent.1 + input.min.1), 0) + -1), input.min.1))
let input.min.1.required = max((min((input.extent.1 + input.min.1), 0) + -1), input.min.1)
assert((!_halide_buffer_is_bounds_query(input.buffer) || ((0 <= input.min.0.required) && (input.min.0.required <= 0))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, input.extent.0.required.s, input.min.0.required, (input.extent.0.required.s + input.min.0.required)))
assert((!_halide_buffer_is_bounds_query(input.buffer) || ((0 <= input.min.1.required) && (input.min.1.required <= 0))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, input.extent.1.required.s, input.min.1.required, (input.extent.1.required.s + input.min.1.required)))
assert((!_halide_buffer_is_bounds_query(output.buffer) || (192 <= output.extent.0)), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, 0, 191, (output.extent.0 + -192), (output.extent.0 + -1)))
assert((!_halide_buffer_is_bounds_query(output.buffer) || (32 <= output.extent.1)), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, 0, 31, (output.extent.1 + -32), (output.extent.1 + -1)))
if (_halide_buffer_is_bounds_query(input.buffer)) {
  _halide_buffer_init(input.buffer, _halide_buffer_get_shape(input.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 2, make_struct((halide_dimension_t *), 0, (input.extent.0.required.s + 1), 1, 0, 0, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1), 0), (uint64)0)
}
if (_halide_buffer_is_bounds_query(output.buffer)) {
  _halide_buffer_init(output.buffer, _halide_buffer_get_shape(output.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 2, make_struct((halide_dimension_t *), 0, max(output.extent.0, 192), 1, 0, 0, max(output.extent.1, 32), max(output.extent.0, 192), 0), (uint64)0)
}
if (!(_halide_buffer_is_bounds_query(input.buffer) || _halide_buffer_is_bounds_query(output.buffer))) {
  assert((input.type == (uint32)67585), halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
  assert((input.dimensions == 2), halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
  assert((output.type == (uint32)67585), halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
  assert((output.dimensions == 2), halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
  assert(((input.min.0 <= input.min.0.required) && (((input.extent.0.required.s + input.min.0.required) + 1) <= (input.extent.0 + input.min.0))), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.extent.0.required.s + input.min.0.required), input.min.0, ((input.extent.0 + input.min.0) + -1)))
  assert((0 <= input.extent.0), halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
  assert(((input.min.1 <= input.min.1.required) && (((input.extent.1.required.s + input.min.1.required) + 1) <= (input.extent.1 + input.min.1))), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.extent.1.required.s + input.min.1.required), input.min.1, ((input.extent.1 + input.min.1) + -1)))
  assert((0 <= input.extent.1), halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
  assert((((output.min.0 + 192) <= min(output.extent.0, 192)) && (0 <= output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, (min(output.extent.0, 192) + -192), (output.extent.0 + -1), output.min.0, ((output.extent.0 + output.min.0) + -1)))
  assert((0 <= output.extent.0), halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
  assert((((output.min.1 + 32) <= min(output.extent.1, 32)) && (0 <= output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, (min(output.extent.1, 32) + -32), (output.extent.1 + -1), output.min.1, ((output.extent.1 + output.min.1) + -1)))
  assert((0 <= output.extent.1), halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
  assert((input.stride.0 == 1), halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
  assert((input.min.0 == 0), halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
  assert((input.min.1 == 0), halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
  assert((output.stride.0 == 1), halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
  assert((output.min.0 == 0), halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
  assert((output.min.1 == 0), halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((abs(int64(input.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("input", abs(int64(input.extent.0)), (uint64)2147483647))
  assert((abs((int64(input.extent.1)*int64(input.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("input", abs((int64(input.extent.1)*int64(input.stride.1))), (uint64)2147483647))
  assert((input.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
  assert((abs(int64(output.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("output", abs(int64(output.extent.0)), (uint64)2147483647))
  assert((abs((int64(output.extent.1)*int64(output.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("output", abs((int64(output.extent.1)*int64(output.stride.1))), (uint64)2147483647))
  assert((output.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
  assert((input != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Input buffer input"))
  assert((output != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer output"))
  produce output {
    let t254 = ((output.extent.0 + 191)/192)
    let t255 = (192 < output.extent.0)
    let t256 = (min(output.extent.0, 192) + -193)
    let t257 = min(select(t255, 1, t256), t256)
    let t258 = (output.extent.0 + -193)
    let t249 = max(min(((max(select(t255, (min((t254*192), (output.extent.0 + 192)) + -191), t258), t258) + (((output.extent.0 - t257)/64)*64)) + 63), output.extent.0), (output.extent.0 + 62))
    let t246 = ((output.extent.1 + 31)/32)
    let t247 = (output.extent.1 + -32)
    parallel (output.s0.y.y, 0, t246) {
      let output.s0.y.yi.base = min((output.s0.y.y*32), t247)
      allocate bounded_input[uint8 * ((t249 - t257) + 1) * 34] in Stack
      let t273 = (t249 - t257)
      let t274 = (t257 - t249)
      let t275 = min((output.s0.y.y*32), t247)
      let t276 = min(max(output.s0.y.yi.base, 1), (output.s0.y.yi.base + 34))
      let t277 = min((t275 + 33), input.extent.1)
      let t278 = min(max(t275, 1), (t275 + 34))
      let t269 = ((t275 - max((t278 + -1), t277)) + 33)
      let t268 = (max((t277 - t278), -1) + 1)
      let t261 = max(min((output.s0.y.yi.base + 33), input.extent.1), (t276 + -1))
      let t263 = (1 - min(t275, 1))
      let t272 = (t274 + 62)
      let t271 = (t274 + -2)
      let t264 = (input.extent.1 + -1)
      for (output.s0.x.x, 0, t254) {
        let output.s0.x.xi.base = min((output.s0.x.x*192), (output.extent.0 + -192))
        let bounded_input.s0.x.min_2 = select((0 < output.s0.x.x), (min((output.s0.x.x*192), output.extent.0) + 1), (output.s0.x.xi.base + -1))
        produce bounded_input {
          let t283 = (1 - output.s0.y.yi.base)
          let t280 = (((output.s0.x.xi.base - bounded_input.s0.x.min_2)/64) + 4)
          let t284 = (t273 + 1)
          let t279 = (output.s0.y.yi.base + -1)
          let t281 = (output.s0.x.xi.base + 129)
          let t282 = (input.extent.0 + -1)
          for (bounded_input.s0.y, t279, t263) {
            let t285 = (max(min(bounded_input.s0.y, t264), 0)*input.stride.1)
            let t286 = (((bounded_input.s0.y + t283)*t284) - t257)
            for (bounded_input.s0.x.x, 0, t280) {
              let bounded_input.s0.x.xi.base = min(((bounded_input.s0.x.x*64) + bounded_input.s0.x.min_2), t281)
              bounded_input[ramp((bounded_input.s0.x.xi.base + t286), 1, 64)] = input[(max(min(ramp(bounded_input.s0.x.xi.base, 1, 64), x64(t282)), x64(0)) + x64(t285))]
            }
          }
          let t296 = (output.s0.x.xi.base - bounded_input.s0.x.min_2)
          let t297 = ((t296/64) + 4)
          let t298 = min(max(((63 - bounded_input.s0.x.min_2)/64), 0), t297)
          let t289 = max((min(min(min((input.extent.0 - bounded_input.s0.x.min_2), (t296 + 193)), ((min((output.s0.x.xi.base + 130), input.extent.0) - bounded_input.s0.x.min_2) + 63)), (t296 + 256))/64), t298)
          let t292 = (1 - output.s0.y.yi.base)
          let t287 = (t276 + -1)
          let t293 = (t273 + 1)
          let t290 = (output.s0.x.xi.base + 129)
          let t291 = (input.extent.0 + -1)
          for (bounded_input.s0.y, t287, t268) {
            let t299 = (bounded_input.s0.y*input.stride.1)
            let t300 = (((bounded_input.s0.y + t292)*t293) - t257)
            for (bounded_input.s0.x.x, 0, t298) {
              let bounded_input.s0.x.xi.base = min(((bounded_input.s0.x.x*64) + bounded_input.s0.x.min_2), t290)
              bounded_input[ramp((bounded_input.s0.x.xi.base + t300), 1, 64)] = input[(max(min(ramp(bounded_input.s0.x.xi.base, 1, 64), x64(t291)), x64(0)) + x64(t299))]
            }
            let t301 = (t289 - t298)
            let t303 = (((bounded_input.s0.y + t292)*t293) + (bounded_input.s0.x.min_2 - t257))
            let t302 = ((bounded_input.s0.y*input.stride.1) + bounded_input.s0.x.min_2)
            for (bounded_input.s0.x.x, t298, t301) {
              bounded_input[ramp(((bounded_input.s0.x.x*64) + t303), 1, 64)] = input[ramp(((bounded_input.s0.x.x*64) + t302), 1, 64)]
            }
            let t305 = (bounded_input.s0.y*input.stride.1)
            let t306 = (((bounded_input.s0.y + t292)*t293) - t257)
            let t304 = (t297 - t289)
            for (bounded_input.s0.x.x, t289, t304) {
              let bounded_input.s0.x.xi.base = min(((bounded_input.s0.x.x*64) + bounded_input.s0.x.min_2), t290)
              bounded_input[ramp((bounded_input.s0.x.xi.base + t306), 1, 64)] = input[(max(min(ramp(bounded_input.s0.x.xi.base, 1, 64), x64(t291)), x64(0)) + x64(t305))]
            }
          }
          let t310 = (1 - output.s0.y.yi.base)
          let t307 = (((output.s0.x.xi.base - bounded_input.s0.x.min_2)/64) + 4)
          let t311 = (t273 + 1)
          let t308 = (output.s0.x.xi.base + 129)
          let t309 = (input.extent.0 + -1)
          for (bounded_input.s0.y, t261, t269) {
            let t312 = (max(min(bounded_input.s0.y, t264), 0)*input.stride.1)
            let t313 = (((bounded_input.s0.y + t310)*t311) - t257)
            for (bounded_input.s0.x.x, 0, t307) {
              let bounded_input.s0.x.xi.base = min(((bounded_input.s0.x.x*64) + bounded_input.s0.x.min_2), t308)
              bounded_input[ramp((bounded_input.s0.x.xi.base + t313), 1, 64)] = input[(max(min(ramp(bounded_input.s0.x.xi.base, 1, 64), x64(t309)), x64(0)) + x64(t312))]
            }
          }
        }
        allocate max_y[uint8 * 8192] in Stack
        produce max_y {
          consume bounded_input {
            let t314 = (output.s0.x.xi.base - t257)
            for (max_y.s0.y, output.s0.y.yi.base, 32) {
              let t319 = (max_y.s0.y - output.s0.y.yi.base)
              let t318 = (t319*4)
              let t317 = (((t319 + 1)*(t273 + 1)) + t314)
              for (max_y.s0.x.x, 0, 4) {
                max_y[ramp(((max_y.s0.x.x + t318)*64), 1, 64) aligned(64, 0)] = max(bounded_input[ramp((((max_y.s0.x.x*64) + t317) + t271), 1, 64)], max(bounded_input[ramp((((max_y.s0.x.x*64) + t317) + -1), 1, 64)], bounded_input[ramp((((max_y.s0.x.x*64) + t317) + t273), 1, 64)]))
              }
            }
          }
        }
        consume max_y {
          consume bounded_input {
            let t320 = (output.s0.x.xi.base - t257)
            for (output.s0.x.xi.xi, 0, 3) {
              allocate minmax_x[uint8 * 2048] in Stack
              produce minmax_x {
                for (minmax_x.s0.y, output.s0.y.yi.base, 32) {
                  minmax_x[ramp(((minmax_x.s0.y - output.s0.y.yi.base)*64), 1, 64) aligned(64, 0)] = min(max_y[ramp(((((minmax_x.s0.y - output.s0.y.yi.base)*4) + output.s0.x.xi.xi)*64), 1, 64) aligned(64, 0)], min(max_y[ramp((((((minmax_x.s0.y - output.s0.y.yi.base)*4) + output.s0.x.xi.xi)*64) + 1), 1, 64) aligned(64, 1)], max_y[ramp((((((minmax_x.s0.y - output.s0.y.yi.base)*4) + output.s0.x.xi.xi)*64) + 2), 1, 64) aligned(64, 2)]))
                }
              }
              consume minmax_x {
                let t327 = (output.s0.x.xi.xi*64)
                let t323 = (t320 + t327)
                let t326 = (output.s0.x.xi.base + t327)
                for (output.s0.y.yi.yi, 0, 2) {
                  allocate min_y[uint8 * 128] in Stack
                  allocate mid_y[uint8 * 128] in Stack
                  let t333 = (output.s0.y.yi.yi*16)
                  let t332 = (output.s0.y.yi.base + t333)
                  for (output.s0.y.yi.yii, 0, 16) {
                    produce min_y {
                      min_y[ramp(0, 1, 64)] = (let t231.s = (((output.s0.y.yi.yii + t333) + 1)*(t273 + 1)) in min(bounded_input[ramp(((t231.s + t323) + t271), 1, 64)], min(bounded_input[ramp(((t231.s + t323) + -1), 1, 64)], bounded_input[ramp(((t231.s + t323) + t273), 1, 64)])))
                      min_y[ramp(64, 1, 64)] = (let t233.s = (((output.s0.y.yi.yii + t333) + 1)*(t273 + 1)) in min(bounded_input[ramp(((t233.s + t323) + t272), 1, 64)], min(bounded_input[ramp(((t233.s + t323) + 63), 1, 64)], bounded_input[ramp((((t233.s + t323) + t273) + 64), 1, 64)])))
                    }
                    produce mid_y {
                      mid_y[ramp(0, 1, 64)] = (let t235.s = (((output.s0.y.yi.yii + t333) + 1)*(t273 + 1)) in (let t236 = bounded_input[ramp(((t235.s + t323) + t271), 1, 64)] in (let t237 = bounded_input[ramp(((t235.s + t323) + -1), 1, 64)] in max(min(bounded_input[ramp(((t235.s + t323) + t273), 1, 64)], max(t236, t237)), min(t236, t237)))))
                      mid_y[ramp(64, 1, 64)] = (let t239.s = (((output.s0.y.yi.yii + t333) + 1)*(t273 + 1)) in (let t240 = bounded_input[ramp(((t239.s + t323) + t272), 1, 64)] in (let t241 = bounded_input[ramp(((t239.s + t323) + 63), 1, 64)] in max(min(bounded_input[ramp((((t239.s + t323) + t273) + 64), 1, 64)], max(t240, t241)), min(t240, t241)))))
                    }
                    allocate midmid_x[uint8 * 64] in Stack
                    produce midmid_x {
                      consume mid_y {
                        midmid_x[ramp(0, 1, 64)] = (let t242 = mid_y[ramp(0, 1, 64)] in (let t243 = mid_y[ramp(1, 1, 64)] in max(min(mid_y[ramp(2, 1, 64)], max(t242, t243)), min(t242, t243))))
                      }
                    }
                    consume midmid_x {
                      consume min_y {
                        output[ramp((((output.s0.y.yi.yii + t332)*output.stride.1) + t326), 1, 64)] = (let t244 = minmax_x[ramp(((output.s0.y.yi.yii + t333)*64), 1, 64) aligned(64, 0)] in (let t245 = max(min_y[ramp(0, 1, 64)], max(min_y[ramp(1, 1, 64)], min_y[ramp(2, 1, 64)])) in max(min(midmid_x[ramp(0, 1, 64)], max(t244, t245)), min(t244, t245))))
                      }
                    }
                    free midmid_x
                  }
                  free min_y
                  free mid_y
                }
              }
              free minmax_x
            }
          }
        }
        free max_y
      }
      free bounded_input
    }
  }
}
}


