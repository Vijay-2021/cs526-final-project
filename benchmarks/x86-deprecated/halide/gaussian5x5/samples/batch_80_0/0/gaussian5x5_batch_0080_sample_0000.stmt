module name=gaussian5x5_batch_0080_sample_0000, target=x86-64-linux-avx-avx2-disable_llvm_loop_opt-f16c-fma-sse41
external_plus_metadata func gaussian5x5_batch_0080_sample_0000 (input, output) {
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
let input.extent.0.required.s = max(min(min(output.extent.0 + 100, min(output.extent.0, 128) + (((max(output.extent.0, 128) + 3)/32)*32)) + output.min.0, (input.extent.0 + input.min.0) + 98) + -99, input.min.0) - max(min(min(output.extent.0, 128) + output.min.0, (input.extent.0 + input.min.0) + 129) + -130, input.min.0)
let input.min.0.required = max(min(min(output.extent.0, 128) + output.min.0, (input.extent.0 + input.min.0) + 129) + -130, input.min.0)
let input.extent.1.required = max(min((output.extent.1 + output.min.1) + 2, input.extent.1 + input.min.1), input.min.1 + 1) - max(min(min(output.extent.1, 36) + output.min.1, (input.extent.1 + input.min.1) + 37) + -38, input.min.1)
let input.min.1.required = max(min(min(output.extent.1, 36) + output.min.1, (input.extent.1 + input.min.1) + 37) + -38, input.min.1)
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)input.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)input.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 8, 2, (halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required.s + 1, 1, 0, input.min.1.required, input.extent.1.required, input.extent.0.required.s + 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)output.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)output.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 8, 2, (halide_dimension_t *)make_struct((min(output.extent.0, 128) + output.min.0) + -128, max(output.extent.0, 128), 1, 0, (min(output.extent.1, 36) + output.min.1) + -36, max(output.extent.1, 36), max(output.extent.0, 128), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || (uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer))) {
 assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
 assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
 assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
 assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
 assert((input.min.0 <= input.min.0.required) && (((input.extent.0.required.s + input.min.0.required) + 1) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, input.extent.0.required.s + input.min.0.required, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && ((input.extent.1.required + input.min.1.required) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.extent.1.required + input.min.1.required) + -1, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert(128 <= output.extent.0, halide_error_access_out_of_bounds("Output buffer output", 0, (min(output.extent.0, 128) + output.min.0) + -128, (output.extent.0 + output.min.0) + -1, output.min.0, (output.extent.0 + output.min.0) + -1))
 assert(36 <= output.extent.1, halide_error_access_out_of_bounds("Output buffer output", 1, (min(output.extent.1, 36) + output.min.1) + -36, (output.extent.1 + output.min.1) + -1, output.min.1, (output.extent.1 + output.min.1) + -1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert(uint64(output.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", uint64(output.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1)), (uint64)2147483647))
 assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(!output.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer output"))
 assert(input != (void *)reinterpret((uint64)0), halide_error_host_is_null("Input buffer input"))
 assert(output != (void *)reinterpret((uint64)0), halide_error_host_is_null("Output buffer output"))
 produce output {
  let t392 = input.extent.0 + input.min.0
  let t393 = (output.extent.0 + 35)/32
  let t394 = min(max(((input.min.0 - output.min.0) + 33)/32, 0), t393)
  let t395 = t392 - output.min.0
  let t388 = max((min(min(min(t395 + 29, output.extent.0) + 2, t395), output.extent.0 + 33) + 2)/32, t394)
  let t382 = (output.extent.1 + 35)/36
  let t390 = (output.extent.0 + 127)/128
  let t391 = 0 - (output.min.1*output.stride.1)
  parallel (output.s0.y.y, 0, t382) {
   let output.s0.y.yi.base.s = min(output.s0.y.y*36, output.extent.1 + -36)
   allocate repeat_edge[uint8 * (output.extent.0 + 16) * 16] in Stack
   let t404 = input.extent.1 + input.min.1
   let t405 = min(output.s0.y.y*36, output.extent.1 + -36)
   let t398 = (input.min.1 - output.min.1) - t405
   let t403 = t404 - t405
   let t399 = output.min.1 + t405
   let t396 = output.min.1 + output.s0.y.yi.base.s
   for (output.s0.y.yi.yi.$n.rebased, 0, 5) {
    produce repeat_edge {
     let repeat_edge.s0._1.prologue = min(max((max(output.s0.y.yi.yi.$n.rebased*9, 5) + t396) + -7, input.min.1), (min(output.s0.y.yi.yi.$n.rebased*9, 5) + (max(output.s0.y.yi.yi.$n.rebased*9, 5) + t396)) + -3)
     let repeat_edge.s0._1.epilogue = min(max(max((max(output.s0.y.yi.yi.$n.rebased*9, 5) + t396) + -7, input.min.1), t404), (min(output.s0.y.yi.yi.$n.rebased*9, 5) + (max(output.s0.y.yi.yi.$n.rebased*9, 5) + t396)) + -3)
     let t408 = output.s0.y.yi.yi.$n.rebased*9
     let t409 = max(t408, 5)
     let t406 = min(min(max(t398 - t409, -7) + 3, t408), 5)
     let t407 = t396 + t409
     for (repeat_edge.s0._1.rebased, 0, t406 + 4) {
      let t411 = (((repeat_edge.s0._1.rebased + t407) + 9) % 16)*(output.extent.0 + 16)
      let t410 = ((max(min((t407 - input.min.1) + repeat_edge.s0._1.rebased, input.extent.1 + 6), 7) + -7)*input.stride.1) - input.min.0
      for (repeat_edge.s0._0._0, 0, t393) {
       let repeat_edge.s0._0._0i.base.s = min((repeat_edge.s0._0._0*32) + 28, output.extent.0)
       repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t411) + -28, 1, 32)] = input[max(min(ramp((output.min.0 + repeat_edge.s0._0._0i.base.s) + -30, 1, 32), x32(t392 + -1)), x32(input.min.0)) + x32(t410)]
      }
     }
     let t417 = output.s0.y.yi.yi.$n.rebased*9
     let t418 = (max(t417, 5) + t399) + -7
     let t419 = (t399 + t417) + 2
     let t412 = min(max(t404, t418), t419) - min(max(input.min.1, t418), t419)
     let t416 = t393 - t388
     let t413 = repeat_edge.s0._1.prologue - input.min.1
     for (repeat_edge.s0._1.rebased, 0, t412) {
      let t421 = ((repeat_edge.s0._1.prologue + repeat_edge.s0._1.rebased) % 16)*(output.extent.0 + 16)
      let t420 = ((repeat_edge.s0._1.rebased + t413)*input.stride.1) - input.min.0
      for (repeat_edge.s0._0._0, 0, t394) {
       let repeat_edge.s0._0._0i.base.s = min((repeat_edge.s0._0._0*32) + 28, output.extent.0)
       repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t421) + -28, 1, 32)] = input[max(min(ramp((output.min.0 + repeat_edge.s0._0._0i.base.s) + -30, 1, 32), x32(t392 + -1)), x32(input.min.0)) + x32(t420)]
      }
      let t424 = ((repeat_edge.s0._1.prologue + repeat_edge.s0._1.rebased) % 16)*(output.extent.0 + 16)
      let t422 = t388 - t394
      let t423 = ((repeat_edge.s0._1.rebased + t413)*input.stride.1) + (output.min.0 - input.min.0)
      for (repeat_edge.s0._0._0.rebased, 0, t422) {
       let t381 = repeat_edge.s0._0._0.rebased + t394
       repeat_edge[ramp((t381*32) + t424, 1, 32)] = input[ramp(((t381*32) + t423) + -2, 1, 32)]
      }
      let t426 = ((repeat_edge.s0._1.prologue + repeat_edge.s0._1.rebased) % 16)*(output.extent.0 + 16)
      let t425 = ((repeat_edge.s0._1.rebased + t413)*input.stride.1) - input.min.0
      for (repeat_edge.s0._0._0.rebased, 0, t416) {
       let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0.rebased + t388)*32) + 28, output.extent.0)
       repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t426) + -28, 1, 32)] = input[max(min(ramp((output.min.0 + repeat_edge.s0._0._0i.base.s) + -30, 1, 32), x32(t392 + -1)), x32(input.min.0)) + x32(t425)]
      }
     }
     let t429 = output.s0.y.yi.yi.$n.rebased*9
     let t427 = max((output.min.1 + t429) - max((max(t429, 5) + output.min.1) + -7, t403), -2)
     let t428 = repeat_edge.s0._1.epilogue - input.min.1
     for (repeat_edge.s0._1.rebased, 0, t427 + 2) {
      let t431 = ((repeat_edge.s0._1.epilogue + repeat_edge.s0._1.rebased) % 16)*(output.extent.0 + 16)
      let t430 = (max(min(repeat_edge.s0._1.rebased + t428, input.extent.1 + -1), 0)*input.stride.1) - input.min.0
      for (repeat_edge.s0._0._0, 0, t393) {
       let repeat_edge.s0._0._0i.base.s = min((repeat_edge.s0._0._0*32) + 28, output.extent.0)
       repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t431) + -28, 1, 32)] = input[max(min(ramp((output.min.0 + repeat_edge.s0._0._0i.base.s) + -30, 1, 32), x32(t392 + -1)), x32(input.min.0)) + x32(t430)]
      }
     }
    }
    if (1 <= output.s0.y.yi.yi.$n.rebased) {
     consume repeat_edge {
      let t432 = (output.s0.y.yi.yi.$n.rebased*9) + t396
      for (output.s0.x.x, 0, t390) {
       let output.s0.x.xi.base.s = min(output.s0.x.x*128, output.extent.0 + -128)
       allocate rows[int16 * 144] in Stack
       let t433 = output.s0.x.xi.base.s + t391
       for (output.s0.y.yi.yii, 0, 9) {
        produce rows {
         let t368 = output.s0.y.yi.yii + t432
         rows[ramp(0, 1, 16)] = (((int16x16)shift_left(int16x16(repeat_edge[ramp((((t368 + 6) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s, 1, 16)]), x16((uint16)2)) + ((int16x16)shift_left(int16x16(repeat_edge[ramp((((t368 + 8) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s, 1, 16)]), x16((uint16)2)) + (int16x16)widening_mul(repeat_edge[ramp((((t368 + 7) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s, 1, 16)], x16((int8)6)))) + int16x16(repeat_edge[ramp((((t368 + 5) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s, 1, 16)])) + int16x16(repeat_edge[ramp((((t368 + 9) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s, 1, 16)])
         rows[ramp(16, 1, 16)] = (((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t368 + 6) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 16, 1, 16)]), x16((uint16)2)) + ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t368 + 8) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 16, 1, 16)]), x16((uint16)2)) + (int16x16)widening_mul(repeat_edge[ramp(((((t368 + 7) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 16, 1, 16)], x16((int8)6)))) + int16x16(repeat_edge[ramp(((((t368 + 5) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 16, 1, 16)])) + int16x16(repeat_edge[ramp(((((t368 + 9) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 16, 1, 16)])
         rows[ramp(32, 1, 16)] = (((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t368 + 6) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 32, 1, 16)]), x16((uint16)2)) + ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t368 + 8) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 32, 1, 16)]), x16((uint16)2)) + (int16x16)widening_mul(repeat_edge[ramp(((((t368 + 7) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 32, 1, 16)], x16((int8)6)))) + int16x16(repeat_edge[ramp(((((t368 + 5) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 32, 1, 16)])) + int16x16(repeat_edge[ramp(((((t368 + 9) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 32, 1, 16)])
         rows[ramp(48, 1, 16)] = (((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t368 + 6) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 48, 1, 16)]), x16((uint16)2)) + ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t368 + 8) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 48, 1, 16)]), x16((uint16)2)) + (int16x16)widening_mul(repeat_edge[ramp(((((t368 + 7) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 48, 1, 16)], x16((int8)6)))) + int16x16(repeat_edge[ramp(((((t368 + 5) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 48, 1, 16)])) + int16x16(repeat_edge[ramp(((((t368 + 9) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 48, 1, 16)])
         rows[ramp(64, 1, 16)] = (((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t368 + 6) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 64, 1, 16)]), x16((uint16)2)) + ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t368 + 8) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 64, 1, 16)]), x16((uint16)2)) + (int16x16)widening_mul(repeat_edge[ramp(((((t368 + 7) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 64, 1, 16)], x16((int8)6)))) + int16x16(repeat_edge[ramp(((((t368 + 5) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 64, 1, 16)])) + int16x16(repeat_edge[ramp(((((t368 + 9) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 64, 1, 16)])
         rows[ramp(80, 1, 16)] = (((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t368 + 6) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 80, 1, 16)]), x16((uint16)2)) + ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t368 + 8) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 80, 1, 16)]), x16((uint16)2)) + (int16x16)widening_mul(repeat_edge[ramp(((((t368 + 7) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 80, 1, 16)], x16((int8)6)))) + int16x16(repeat_edge[ramp(((((t368 + 5) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 80, 1, 16)])) + int16x16(repeat_edge[ramp(((((t368 + 9) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 80, 1, 16)])
         rows[ramp(96, 1, 16)] = (((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t368 + 6) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 96, 1, 16)]), x16((uint16)2)) + ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t368 + 8) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 96, 1, 16)]), x16((uint16)2)) + (int16x16)widening_mul(repeat_edge[ramp(((((t368 + 7) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 96, 1, 16)], x16((int8)6)))) + int16x16(repeat_edge[ramp(((((t368 + 5) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 96, 1, 16)])) + int16x16(repeat_edge[ramp(((((t368 + 9) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 96, 1, 16)])
         rows[ramp(112, 1, 16)] = (((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t368 + 6) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 112, 1, 16)]), x16((uint16)2)) + ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t368 + 8) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 112, 1, 16)]), x16((uint16)2)) + (int16x16)widening_mul(repeat_edge[ramp(((((t368 + 7) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 112, 1, 16)], x16((int8)6)))) + int16x16(repeat_edge[ramp(((((t368 + 5) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 112, 1, 16)])) + int16x16(repeat_edge[ramp(((((t368 + 9) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 112, 1, 16)])
         rows[ramp(128, 1, 16)] = (((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t368 + 6) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 128, 1, 16)]), x16((uint16)2)) + ((int16x16)shift_left(int16x16(repeat_edge[ramp(((((t368 + 8) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 128, 1, 16)]), x16((uint16)2)) + (int16x16)widening_mul(repeat_edge[ramp(((((t368 + 7) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 128, 1, 16)], x16((int8)6)))) + int16x16(repeat_edge[ramp(((((t368 + 5) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 128, 1, 16)])) + int16x16(repeat_edge[ramp(((((t368 + 9) % 16)*(output.extent.0 + 16)) + output.s0.x.xi.base.s) + 128, 1, 16)])
        }
        consume rows {
         allocate cols[int16 * 32] in Stack
         produce cols {
          cols[ramp(0, 1, 16)] = (int16x16)shift_left(rows[ramp(1, 1, 16)], x16((uint16)2)) + (rows[ramp(0, 1, 16)] + ((rows[ramp(2, 1, 16)]*x16((int16)6)) + (rows[ramp(4, 1, 16)] + (int16x16)shift_left(rows[ramp(3, 1, 16)], x16((uint16)2)))))
          cols[ramp(16, 1, 16)] = (int16x16)shift_left(rows[ramp(17, 1, 16)], x16((uint16)2)) + (rows[ramp(16, 1, 16)] + ((rows[ramp(18, 1, 16)]*x16((int16)6)) + (rows[ramp(20, 1, 16)] + (int16x16)shift_left(rows[ramp(19, 1, 16)], x16((uint16)2)))))
         }
         consume cols {
          output[ramp((((output.s0.y.yi.yii + t432) + -9)*output.stride.1) + t433, 1, 32)] = uint8x32((int16x32)shift_right(cols[ramp(0, 1, 32)], x32((uint16)8)))
         }
         free cols
         allocate cols[int16 * 32] in Stack
         produce cols {
          cols[ramp(0, 1, 16)] = (int16x16)shift_left(rows[ramp(33, 1, 16)], x16((uint16)2)) + (rows[ramp(32, 1, 16)] + ((rows[ramp(34, 1, 16)]*x16((int16)6)) + (rows[ramp(36, 1, 16)] + (int16x16)shift_left(rows[ramp(35, 1, 16)], x16((uint16)2)))))
          cols[ramp(16, 1, 16)] = (int16x16)shift_left(rows[ramp(49, 1, 16)], x16((uint16)2)) + (rows[ramp(48, 1, 16)] + ((rows[ramp(50, 1, 16)]*x16((int16)6)) + (rows[ramp(52, 1, 16)] + (int16x16)shift_left(rows[ramp(51, 1, 16)], x16((uint16)2)))))
         }
         consume cols {
          output[ramp(((((output.s0.y.yi.yii + t432) + -9)*output.stride.1) + t433) + 32, 1, 32)] = uint8x32((int16x32)shift_right(cols[ramp(0, 1, 32)], x32((uint16)8)))
         }
         free cols
         allocate cols[int16 * 32] in Stack
         produce cols {
          cols[ramp(0, 1, 16)] = (int16x16)shift_left(rows[ramp(65, 1, 16)], x16((uint16)2)) + (rows[ramp(64, 1, 16)] + ((rows[ramp(66, 1, 16)]*x16((int16)6)) + (rows[ramp(68, 1, 16)] + (int16x16)shift_left(rows[ramp(67, 1, 16)], x16((uint16)2)))))
          cols[ramp(16, 1, 16)] = (int16x16)shift_left(rows[ramp(81, 1, 16)], x16((uint16)2)) + (rows[ramp(80, 1, 16)] + ((rows[ramp(82, 1, 16)]*x16((int16)6)) + (rows[ramp(84, 1, 16)] + (int16x16)shift_left(rows[ramp(83, 1, 16)], x16((uint16)2)))))
         }
         consume cols {
          output[ramp(((((output.s0.y.yi.yii + t432) + -9)*output.stride.1) + t433) + 64, 1, 32)] = uint8x32((int16x32)shift_right(cols[ramp(0, 1, 32)], x32((uint16)8)))
         }
         free cols
         allocate cols[int16 * 32] in Stack
         produce cols {
          cols[ramp(0, 1, 16)] = (int16x16)shift_left(rows[ramp(97, 1, 16)], x16((uint16)2)) + (rows[ramp(96, 1, 16)] + ((rows[ramp(98, 1, 16)]*x16((int16)6)) + (rows[ramp(100, 1, 16)] + (int16x16)shift_left(rows[ramp(99, 1, 16)], x16((uint16)2)))))
          cols[ramp(16, 1, 16)] = (int16x16)shift_left(rows[ramp(113, 1, 16)], x16((uint16)2)) + (rows[ramp(112, 1, 16)] + ((rows[ramp(114, 1, 16)]*x16((int16)6)) + (rows[ramp(116, 1, 16)] + (int16x16)shift_left(rows[ramp(115, 1, 16)], x16((uint16)2)))))
         }
         consume cols {
          output[ramp(((((output.s0.y.yi.yii + t432) + -9)*output.stride.1) + t433) + 96, 1, 32)] = uint8x32((int16x32)shift_right(cols[ramp(0, 1, 32)], x32((uint16)8)))
         }
         free cols
        }
       }
       free rows
      }
     }
    }
   }
   free repeat_edge
  }
 }
}
}


