module name=max_pool_batch_0086_sample_0002, target=x86-64-linux-avx-avx2-disable_llvm_loop_opt-f16c-fma-sse41
external_plus_metadata func max_pool_batch_0086_sample_0002 (input, stride_x, stride_y, filter_width, filter_height, output_min, output_max, output) {
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let input.min.2 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 2)
let input.extent.2 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 2)
let input.stride.2 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 2)
let input.min.3 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 3)
let input.extent.3 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 3)
let input.stride.3 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 3)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
let output.min.2 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 2)
let output.extent.2 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 2)
let output.stride.2 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 2)
let output.min.3 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 3)
let output.extent.3 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 3)
let output.stride.3 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 3)
let input.extent.1.required.s = let t694 = (stride_x < 0) in (let t695 = min(max(max(-2 - output.extent.1, output.extent.1 + -1)/2, 0)*2, output.extent.1 + -2) in (let t697.s = select(t694, t695 + 1, min(output.extent.1, 2) + -2) in (let t698.s = select(t694, min(output.extent.1, 2) + -2, t695 + 1) in (max(min(input.extent.1 + input.min.1, min((input.extent.1 + input.min.1) - ((output.min.1 + t697.s)*stride_x), filter_width) + ((output.min.1 + t698.s)*stride_x)) + -1, input.min.1) - max(min((input.extent.1 + input.min.1) + -1, max(input.min.1 - ((output.min.1 + t698.s)*stride_x), 0) + ((output.min.1 + t697.s)*stride_x)), input.min.1)))))
let input.min.1.required = let t699 = (stride_x < 0) in (let t701 = min(max(max(-2 - output.extent.1, output.extent.1 + -1)/2, 0)*2, output.extent.1 + -2) in max(min((input.extent.1 + input.min.1) + -1, max(input.min.1 - ((select(t699, min(output.extent.1, 2) + -2, t701 + 1) + output.min.1)*stride_x), 0) + ((select(t699, t701 + 1, min(output.extent.1, 2) + -2) + output.min.1)*stride_x)), input.min.1))
let input.extent.2.required.s = let t703 = (stride_y < 0) in (let t704 = (0 < output.extent.1) in (let t705 = (((((output.extent.1 + 1)/2)*((output.extent.2 + 10)/11)) + -1)/((output.extent.1 + 1)/2)) in (let t706 = min(select(t704, t705, 0)*11, output.extent.2 + -11) in (let t707 = min(select(t704, 0, t705)*11, output.extent.2 + -11) in (let t708.s = select(t703, t706 + 10, t707) in (max(min(input.extent.2 + input.min.2, min((input.extent.2 + input.min.2) - ((output.min.2 + t708.s)*stride_y), filter_height) + ((select(t703, t707, t706 + 10) + output.min.2)*stride_y)) + -1, input.min.2) - max(min((output.min.2 + t708.s)*stride_y, (input.extent.2 + input.min.2) + -1), input.min.2)))))))
let input.min.2.required = let t709 = (0 < output.extent.1) in (let t710 = (((((output.extent.1 + 1)/2)*((output.extent.2 + 10)/11)) + -1)/((output.extent.1 + 1)/2)) in max(min((select(stride_y < 0, min(select(t709, t710, 0)*11, output.extent.2 + -11) + 10, min(select(t709, 0, t710)*11, output.extent.2 + -11)) + output.min.2)*stride_y, (input.extent.2 + input.min.2) + -1), input.min.2))
let input.stride.2.required = max(output.extent.0, 32)*(input.extent.1.required.s + 1)
let output.extent.1.required.s = min(max(max(-2 - output.extent.1, output.extent.1 + -1)/2, 0)*2, output.extent.1 + -2)
let output.extent.2.required.s = let t711 = (0 < output.extent.1) in (let t712 = (((((output.extent.1 + 1)/2)*((output.extent.2 + 10)/11)) + -1)/((output.extent.1 + 1)/2)) in (min(select(t711, t712, 0)*11, output.extent.2 + -11) - min(select(t711, 0, t712)*11, output.extent.2 + -11)))
let output.min.2.required.s = min(select(0 < output.extent.1, 0, ((((output.extent.1 + 1)/2)*((output.extent.2 + 10)/11)) + -1)/((output.extent.1 + 1)/2))*11, output.extent.2 + -11)
let output.stride.2.required = max(output.extent.0, 32)*(max(output.extent.1.required.s, 0) + 2)
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)input.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)input.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 8, 4, (halide_dimension_t *)make_struct((min(output.extent.0, 32) + output.min.0) + -32, max(output.extent.0, 32), 1, 0, input.min.1.required, input.extent.1.required.s + 1, max(output.extent.0, 32), 0, input.min.2.required, input.extent.2.required.s + 1, input.stride.2.required, 0, output.min.3, output.extent.3, (input.extent.2.required.s + 1)*input.stride.2.required, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)output.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)output.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 8, 4, (halide_dimension_t *)make_struct((min(output.extent.0, 32) + output.min.0) + -32, max(output.extent.0, 32), 1, 0, (min(output.extent.1, 2) + output.min.1) + -2, max(output.extent.1.required.s, 0) + 2, max(output.extent.0, 32), 0, output.min.2 + output.min.2.required.s, output.extent.2.required.s + 11, output.stride.2.required, 0, output.min.3, output.extent.3, (output.extent.2.required.s + 11)*output.stride.2.required, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || (uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer))) {
 assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
 assert(input.dimensions == 4, halide_error_bad_dimensions("Input buffer input", input.dimensions, 4))
 assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
 assert(output.dimensions == 4, halide_error_bad_dimensions("Output buffer output", output.dimensions, 4))
 assert(((input.min.0 + 32) <= (min(output.extent.0, 32) + output.min.0)) && ((output.extent.0 + output.min.0) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, (min(output.extent.0, 32) + output.min.0) + -32, (output.extent.0 + output.min.0) + -1, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && (((input.extent.1.required.s + input.min.1.required) + 1) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, input.extent.1.required.s + input.min.1.required, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert((input.min.2 <= input.min.2.required) && (((input.extent.2.required.s + input.min.2.required) + 1) <= (input.extent.2 + input.min.2)), halide_error_access_out_of_bounds("Input buffer input", 2, input.min.2.required, input.extent.2.required.s + input.min.2.required, input.min.2, (input.extent.2 + input.min.2) + -1))
 assert(0 <= input.extent.2, halide_error_buffer_extents_negative("Input buffer input", 2, input.extent.2))
 assert((input.min.3 <= output.min.3) && ((output.extent.3 + output.min.3) <= (input.extent.3 + input.min.3)), halide_error_access_out_of_bounds("Input buffer input", 3, output.min.3, (output.extent.3 + output.min.3) + -1, input.min.3, (input.extent.3 + input.min.3) + -1))
 assert(0 <= input.extent.3, halide_error_buffer_extents_negative("Input buffer input", 3, input.extent.3))
 assert(32 <= output.extent.0, halide_error_access_out_of_bounds("Output buffer output", 0, (min(output.extent.0, 32) + output.min.0) + -32, (output.extent.0 + output.min.0) + -1, output.min.0, (output.extent.0 + output.min.0) + -1))
 assert(max(max(output.extent.1.required.s, 0) + min(output.extent.1, 2), 2) <= output.extent.1, halide_error_access_out_of_bounds("Output buffer output", 1, (min(output.extent.1, 2) + output.min.1) + -2, ((max(output.extent.1.required.s, 0) + min(output.extent.1, 2)) + output.min.1) + -1, output.min.1, (output.extent.1 + output.min.1) + -1))
 assert((0 <= output.min.2.required.s) && ((((output.min.2 + output.min.2.required.s) + output.extent.2.required.s) + 11) <= (output.extent.2 + output.min.2)), halide_error_access_out_of_bounds("Output buffer output", 2, output.min.2 + output.min.2.required.s, ((output.min.2 + output.min.2.required.s) + output.extent.2.required.s) + 10, output.min.2, (output.extent.2 + output.min.2) + -1))
 assert(0 <= output.extent.2, halide_error_buffer_extents_negative("Output buffer output", 2, output.extent.2))
 assert(0 <= output.extent.3, halide_error_buffer_extents_negative("Output buffer output", 3, output.extent.3))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let input.total_extent.2 = input.total_extent.1*int64(input.extent.2)
 let input.total_extent.3 = input.total_extent.2*int64(input.extent.3)
 let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
 let output.total_extent.2 = output.total_extent.1*int64(output.extent.2)
 let output.total_extent.3 = output.total_extent.2*int64(output.extent.3)
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.2)*int64(input.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.2)*int64(input.stride.2)), (uint64)2147483647))
 assert(input.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.2, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.3)*int64(input.stride.3)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.3)*int64(input.stride.3)), (uint64)2147483647))
 assert(input.total_extent.3 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.3, (int64)2147483647))
 assert(uint64(output.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", uint64(output.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1)), (uint64)2147483647))
 assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(output.extent.2)*int64(output.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.2)*int64(output.stride.2)), (uint64)2147483647))
 assert(output.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.2, (int64)2147483647))
 assert((uint64)abs(int64(output.extent.3)*int64(output.stride.3)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.3)*int64(output.stride.3)), (uint64)2147483647))
 assert(output.total_extent.3 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.3, (int64)2147483647))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(!output.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer output"))
 assert(input != (void *)reinterpret((uint64)0), halide_error_host_is_null("Input buffer input"))
 assert(output != (void *)reinterpret((uint64)0), halide_error_host_is_null("Output buffer output"))
 let output.s0.x.x.x.loop_extent = ((output.extent.1 + 1)/2)*((output.extent.2 + 10)/11)
 produce output {
  let t740 = input.min.3*input.stride.3
  let t741 = input.min.2*input.stride.2
  let t742 = input.min.1*input.stride.1
  let t743 = output.min.3*output.stride.3
  let t744 = output.min.2*output.stride.2
  let t745 = output.min.1*output.stride.1
  let t746 = output.extent.0 + output.min.0
  let t728 = stride_y < 0
  let t730 = stride_x < 0
  let t735 = (output.extent.0 % 32) != 0
  let t727 = (output.extent.1 + 1)/2
  let t737 = (output.extent.0 + 31)/32
  let t733 = output.extent.0/32
  let t732 = ((output.extent.0 + -1)/32)*32
  let t739 = (((t746 - t743) - t744) - t745) - output.min.0
  let t736 = (((t746 - t740) - t741) - t742) - input.min.0
  let t738 = (((output.min.0 - t743) - t744) - t745) - output.min.0
  let t734 = (((output.min.0 - t740) - t741) - t742) - input.min.0
  let t729 = input.extent.2 + input.min.2
  let t731 = input.extent.1 + input.min.1
  for (output.s0.b.rebased, 0, output.extent.3) {
   let t755 = output.min.3 + output.s0.b.rebased
   let t756 = input.stride.3*t755
   let t757 = output.stride.3*t755
   let t750 = select(t730, 1, 0) + output.min.1
   let t749 = select(t730, 0, 1) + output.min.1
   let t747 = select(t728, 10, 0) + output.min.2
   let t748 = select(t728, 0, 10) + output.min.2
   let t754 = t739 + t757
   let t753 = t738 + t757
   let t752 = t736 + t756
   let t751 = t734 + t756
   parallel (output.s0.x.x.x, 0, output.s0.x.x.x.loop_extent) {
    let output.s0.x.xi.base.s = min((output.s0.x.x.x % t727)*2, output.extent.1 + -2)
    let output.s0.y.yi.base.s = min((output.s0.x.x.x/t727)*11, output.extent.2 + -11)
    let input_bounded.y.min_realized = min(max((output.s0.y.yi.base.s + t747)*stride_y, input.min.2), max(input.min.2 - ((output.s0.y.yi.base.s + t748)*stride_y), 0) + ((output.s0.y.yi.base.s + t747)*stride_y))
    let input_bounded.y.extent_realized.s = min(t729 - ((output.s0.y.yi.base.s + t747)*stride_y), filter_height) + ((output.s0.y.yi.base.s + t748)*stride_y)
    let input_bounded.x.min_realized = max(input.min.1 - ((output.s0.x.xi.base.s + t749)*stride_x), 0) + ((output.s0.x.xi.base.s + t750)*stride_x)
    let input_bounded.x.extent_realized.s = min(t731 - ((output.s0.x.xi.base.s + t750)*stride_x), filter_width) + ((output.s0.x.xi.base.s + t749)*stride_x)
    allocate input_bounded[uint8 * (t732 + 32) * (input_bounded.x.extent_realized.s - input_bounded.x.min_realized) * (input_bounded.y.extent_realized.s - input_bounded.y.min_realized) * 1]
    let t763 = (output.s0.x.xi.base.s + t750)*stride_x
    let t764 = (output.s0.x.xi.base.s + t749)*stride_x
    let t761 = (input_bounded.x.extent_realized.s - input_bounded.x.min_realized)*(t732 + 32)
    let t760 = max(input.min.1 - t764, 0) + t763
    let t759 = min(t731 - t763, filter_width) + t764
    let t758 = output.min.2 + output.s0.y.yi.base.s
    let t762 = output.min.1 + output.s0.x.xi.base.s
    for (output.s0.y.yi, 0, 11) {
     let input_bounded.s0.y.max_2.s = min(((output.s0.y.yi + t758)*stride_y) + filter_height, t729)
     let input_bounded.s0.y.min_2 = max((output.s0.y.yi + t758)*stride_y, input.min.2)
     produce input_bounded {
      let t768 = t760 - input_bounded.x.min_realized
      let t766 = t759 - t760
      let t767 = input_bounded.s0.y.min_2 - input_bounded.y.min_realized
      let t765 = input_bounded.s0.y.max_2.s - input_bounded.s0.y.min_2
      for (input_bounded.s0.y.rebased, 0, t765) {
       let t773 = (input_bounded.s0.y.rebased + t767)*t761
       let t774 = max(min(t729 + -1, input_bounded.s0.y.min_2 + input_bounded.s0.y.rebased), input.min.2)*input.stride.2
       let t771 = t752 + t774
       let t769 = t751 + t774
       let t772 = output.extent.0 + t773
       for (input_bounded.s0.x.rebased, 0, t766) {
        let t775 = (max(min(t731 + -1, input_bounded.s0.x.rebased + t760), input.min.1)*input.stride.1) + t769
        let t776 = ((input_bounded.s0.x.rebased + t768)*(t732 + 32)) + t773
        for (input_bounded.s0.c.c, 0, t733) {
         input_bounded[ramp((input_bounded.s0.c.c*32) + t776, 1, 32) aligned(32, 0)] = input[ramp((input_bounded.s0.c.c*32) + t775, 1, 32)]
        }
        if (t735) {
         input_bounded[ramp((((input_bounded.s0.x.rebased + t768)*(t732 + 32)) + t772) + -32, 1, 32)] = input[ramp(((max(min(t731 + -1, input_bounded.s0.x.rebased + t760), input.min.1)*input.stride.1) + t771) + -32, 1, 32)]
        }
       }
      }
     }
     allocate maximum[uint8 * (t732 + 32) * 2 * 1 * 1] in Stack
     produce maximum {
      for (maximum.s0.x.rebased, 0, 2) {
       let t777 = (t732 + 32)*maximum.s0.x.rebased
       for (maximum.s0.c.c, 0, t737) {
        maximum[ramp((maximum.s0.c.c*32) + t777, 1, 32) aligned(32, 0)] = x32((uint8)output_min)
       }
      }
      consume input_bounded {
       let t781 = (output.s0.y.yi + t758)*stride_y
       let t779 = min(t729 - t781, filter_height)
       let t778 = min(input.min.2 - t781, filter_height)
       let t780 = t781 - input_bounded.y.min_realized
       for (maximum.s1.x.rebased, 0, 2) {
        let t789 = max(t778, 0)
        let t790 = (maximum.s1.x.rebased + t762)*stride_x
        let t782 = max(t778, t779)
        let t785 = min(t731 - t790, filter_width)
        let t784 = min(input.min.1 - t790, filter_width)
        let t786 = (t732 + 32)*maximum.s1.x.rebased
        let t788 = t790 - input_bounded.x.min_realized
        let t787 = t780 + t789
        for (maximum.s1.c.c, 0, t737) {
         let t797 = maximum.s1.c.c*32
         let t798 = max(t784, 0)
         let t792 = max(t784, t785)
         let t791 = max(t782, 0) - t789
         let t796 = t788 + t798
         let t794 = t786 + t797
         for (maximum.s1.r12$y.rebased, 0, t791) {
          let t799 = max(t792, 0) - t798
          let t800 = ((maximum.s1.r12$y.rebased + t787)*t761) + t797
          for (maximum.s1.r12$x.rebased, 0, t799) {
           maximum[ramp(t794, 1, 32) aligned(32, 0)] = max(maximum[ramp(t794, 1, 32) aligned(32, 0)], input_bounded[ramp(((maximum.s1.r12$x.rebased + t796)*(t732 + 32)) + t800, 1, 32) aligned(32, 0)])
          }
         }
        }
       }
      }
     }
     consume maximum {
      let t803 = (output.s0.y.yi + t758)*output.stride.2
      let t802 = t754 + t803
      let t801 = t753 + t803
      for (output.s0.x.xi, 0, 2) {
       let t804 = (t732 + 32)*output.s0.x.xi
       let t805 = ((output.s0.x.xi + t762)*output.stride.1) + t801
       for (output.s0.c.c, 0, t733) {
        output[ramp((output.s0.c.c*32) + t805, 1, 32)] = min(maximum[ramp((output.s0.c.c*32) + t804, 1, 32) aligned(32, 0)], x32((uint8)output_max))
       }
       if (t735) {
        output[ramp((((output.s0.x.xi + t762)*output.stride.1) + t802) + -32, 1, 32)] = min(maximum[ramp((((t732 + 32)*output.s0.x.xi) + output.extent.0) + -32, 1, 32)], x32((uint8)output_max))
       }
      }
     }
     free maximum
    }
    free input_bounded
   }
  }
 }
}
}


