module name=dilate7x7_batch_0054_sample_0007, target=x86-64-linux-avx-avx2-avx512-avx512_sapphirerapids-avx512_skylake-disable_llvm_loop_opt-f16c-fma-sse41
external_plus_metadata func dilate7x7_batch_0054_sample_0007 (input, output) {
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
let input.extent.0.required.s = max(min(min(output.extent.0 + 6, min(output.extent.0, 64) + (((max(output.extent.0, 64) + 5)/64)*64)) + output.min.0, (input.extent.0 + input.min.0) + 3) + -4, input.min.0) - max(min(min(output.extent.0, 64) + output.min.0, (input.extent.0 + input.min.0) + 66) + -67, input.min.0)
let input.min.0.required = max(min(min(output.extent.0, 64) + output.min.0, (input.extent.0 + input.min.0) + 66) + -67, input.min.0)
let input.extent.1.required = max(min(output.extent.1 + output.min.1, input.extent.1 + input.min.1), input.min.1 + 1) - max(min(min(output.extent.1, 108) + output.min.1, (input.extent.1 + input.min.1) + 107) + -108, input.min.1)
let input.min.1.required = max(min(min(output.extent.1, 108) + output.min.1, (input.extent.1 + input.min.1) + 107) + -108, input.min.1)
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)input.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)input.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 8, 2, (halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required.s + 1, 1, 0, input.min.1.required, input.extent.1.required, input.extent.0.required.s + 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)output.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)output.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 8, 2, (halide_dimension_t *)make_struct((min(output.extent.0, 64) + output.min.0) + -64, max(output.extent.0, 64), 1, 0, (min(output.extent.1, 108) + output.min.1) + -108, max(output.extent.1, 108), max(output.extent.0, 64), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || (uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer))) {
 assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
 assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
 assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
 assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
 assert((input.min.0 <= input.min.0.required) && (((input.extent.0.required.s + input.min.0.required) + 1) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, input.extent.0.required.s + input.min.0.required, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && ((input.extent.1.required + input.min.1.required) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.extent.1.required + input.min.1.required) + -1, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert(64 <= output.extent.0, halide_error_access_out_of_bounds("Output buffer output", 0, (min(output.extent.0, 64) + output.min.0) + -64, (output.extent.0 + output.min.0) + -1, output.min.0, (output.extent.0 + output.min.0) + -1))
 assert(108 <= output.extent.1, halide_error_access_out_of_bounds("Output buffer output", 1, (min(output.extent.1, 108) + output.min.1) + -108, (output.extent.1 + output.min.1) + -1, output.min.1, (output.extent.1 + output.min.1) + -1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert(uint64(output.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", uint64(output.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1)), (uint64)2147483647))
 assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(!output.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer output"))
 assert(input != (void *)reinterpret((uint64)0), halide_error_host_is_null("Input buffer input"))
 assert(output != (void *)reinterpret((uint64)0), halide_error_host_is_null("Output buffer output"))
 produce output {
  let t133 = input.extent.0 + input.min.0
  let t134 = input.extent.1 + input.min.1
  let t135 = output.min.1*output.stride.1
  let t136 = (output.extent.0 + 69)/64
  let t137 = min(max(((input.min.0 - output.min.0) + 66)/64, 0), t136)
  let t138 = t133 - output.min.0
  let t131 = (output.extent.0 % 64) != 0
  let t126 = max((min(min(min(t138 + 60, output.extent.0) + 3, t138), output.extent.0 + 66) + 3)/64, t137)
  let t118 = (output.extent.1 + 107)/108
  let t129 = output.extent.0/64
  let t119 = ((output.extent.0 + 5)/64)*64
  let t132 = output.extent.0 - t135
  let t130 = 0 - t135
  parallel (output.s0.y.y, 0, t118) {
   let output.s0.y.yi.base.s = min(output.s0.y.y*108, output.extent.1 + -108)
   allocate repeat_edge[uint8 * (t119 + 64) * 108]
   produce repeat_edge {
    let repeat_edge.s0._1.prologue = min(max(output.min.1 + output.s0.y.yi.base.s, input.min.1), (output.min.1 + output.s0.y.yi.base.s) + 108)
    let repeat_edge.s0._1.epilogue = min(max(max(output.min.1 + output.s0.y.yi.base.s, input.min.1), t134), (output.min.1 + output.s0.y.yi.base.s) + 108)
    let t139 = max(min((input.min.1 - output.min.1) - min(output.s0.y.y*108, output.extent.1 + -108), 108), 0)
    let t140 = (output.min.1 - input.min.1) + output.s0.y.yi.base.s
    for (repeat_edge.s0._1.rebased, 0, t139) {
     let t142 = (t119 + 64)*repeat_edge.s0._1.rebased
     let t141 = (max(min(repeat_edge.s0._1.rebased + t140, input.extent.1 + -1), 0)*input.stride.1) - input.min.0
     for (repeat_edge.s0._0._0, 0, t136) {
      let repeat_edge.s0._0._0i.base.s = min((repeat_edge.s0._0._0*64) + 58, output.extent.0)
      repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t142) + -58, 1, 64)] = input[max(min(ramp((output.min.0 + repeat_edge.s0._0._0i.base.s) + -61, 1, 64), x64(t133 + -1)), x64(input.min.0)) + x64(t141)]
     }
    }
    let t149 = min(output.s0.y.y*108, output.extent.1 + -108)
    let t150 = output.min.1 + t149
    let t151 = t150 + 108
    let t143 = min(max(t134, t150), t151) - min(max(input.min.1, t150), t151)
    let t148 = t136 - t126
    let t145 = repeat_edge.s0._1.prologue - input.min.1
    for (repeat_edge.s0._1.rebased, 0, t143) {
     let t153 = ((repeat_edge.s0._1.rebased + t145)*input.stride.1) - input.min.0
     for (repeat_edge.s0._0._0, 0, t137) {
      let repeat_edge.s0._0._0i.base.s = min((repeat_edge.s0._0._0*64) + 58, output.extent.0)
      repeat_edge[ramp((((max(min((input.min.1 - output.min.1) - t149, 108), 0) + repeat_edge.s0._1.rebased)*(t119 + 64)) + repeat_edge.s0._0._0i.base.s) + -58, 1, 64)] = input[max(min(ramp((output.min.0 + repeat_edge.s0._0._0i.base.s) + -61, 1, 64), x64(t133 + -1)), x64(input.min.0)) + x64(t153)]
     }
     let t154 = t126 - t137
     let t156 = ((repeat_edge.s0._1.rebased + t145)*input.stride.1) + (output.min.0 - input.min.0)
     for (repeat_edge.s0._0._0.rebased, 0, t154) {
      let t113 = repeat_edge.s0._0._0.rebased + t137
      repeat_edge[ramp(((max(min((input.min.1 - output.min.1) - t149, 108), 0) + repeat_edge.s0._1.rebased)*(t119 + 64)) + (t113*64), 1, 64) aligned(64, 0)] = input[ramp(((t113*64) + t156) + -3, 1, 64)]
     }
     let t158 = ((repeat_edge.s0._1.rebased + t145)*input.stride.1) - input.min.0
     for (repeat_edge.s0._0._0.rebased, 0, t148) {
      let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0.rebased + t126)*64) + 58, output.extent.0)
      repeat_edge[ramp((((max(min((input.min.1 - output.min.1) - t149, 108), 0) + repeat_edge.s0._1.rebased)*(t119 + 64)) + repeat_edge.s0._0._0i.base.s) + -58, 1, 64)] = input[max(min(ramp((output.min.0 + repeat_edge.s0._0._0i.base.s) + -61, 1, 64), x64(t133 + -1)), x64(input.min.0)) + x64(t158)]
     }
    }
    let t162 = min(output.s0.y.y*108, output.extent.1 + -108)
    let t159 = max(min((output.min.1 - t134) + t162, 0), -108)
    let t161 = repeat_edge.s0._1.epilogue - input.min.1
    for (repeat_edge.s0._1.rebased, 0, t159 + 108) {
     let t164 = (max(min(repeat_edge.s0._1.rebased + t161, input.extent.1 + -1), 0)*input.stride.1) - input.min.0
     for (repeat_edge.s0._0._0, 0, t136) {
      let repeat_edge.s0._0._0i.base.s = min((repeat_edge.s0._0._0*64) + 58, output.extent.0)
      repeat_edge[ramp((((max(min((t134 - output.min.1) - t162, 108), 0) + repeat_edge.s0._1.rebased)*(t119 + 64)) + repeat_edge.s0._0._0i.base.s) + -58, 1, 64)] = input[max(min(ramp((output.min.0 + repeat_edge.s0._0._0i.base.s) + -61, 1, 64), x64(t133 + -1)), x64(input.min.0)) + x64(t164)]
     }
    }
   }
   consume repeat_edge {
    let t165 = output.min.1 + output.s0.y.yi.base.s
    for (output.s0.y.yi.yi, 0, 3) {
     allocate bounded_input[uint8 * (t119 + 64) * 16] in Stack
     let t167 = output.s0.y.yi.yi*36
     let t166 = output.s0.y.yi.yi*4
     for (output.s0.y.yi.yii.yii.$n, 0, 4) {
      produce bounded_input {
       let t170 = (output.s0.y.yi.yii.yii.$n + t166)*9
       let t168 = t165 + t170
       for (bounded_input.s0.y.rebased, 0, 9) {
        let t173 = t119 + 64
        let t172 = ((bounded_input.s0.y.rebased + t168) % 16)*t173
        let t171 = (bounded_input.s0.y.rebased + t170)*t173
        for (bounded_input.s0.x.x, 0, t136) {
         bounded_input[ramp((bounded_input.s0.x.x*64) + t172, 1, 64) aligned(64, 0)] = repeat_edge[ramp((bounded_input.s0.x.x*64) + t171, 1, 64) aligned(64, 0)]
        }
       }
      }
      consume bounded_input {
       let t174 = (output.s0.y.yi.yii.yii.$n*9) + t167
       for (output.s0.y.yi.yii.yiii, 0, 9) {
        let output.s0.y.yi = output.s0.y.yi.yii.yiii + t174
        let t177 = output.s0.y.yi + t165
        let t175 = (t177 % 16)*(t119 + 64)
        let t176 = (output.stride.1*t177) + t130
        for (output.s0.x.x, 0, t129) {
         let t71 = (output.s0.x.x*64) + t175
         output[ramp((output.s0.x.x*64) + t176, 1, 64)] = max(bounded_input[ramp(t71, 1, 64) aligned(64, 0)], max(bounded_input[ramp(t71 + 1, 1, 64) aligned(64, 1)], max(bounded_input[ramp(t71 + 2, 1, 64) aligned(64, 2)], max(bounded_input[ramp(t71 + 3, 1, 64) aligned(64, 3)], max(bounded_input[ramp(t71 + 4, 1, 64) aligned(64, 4)], max(bounded_input[ramp(t71 + 5, 1, 64) aligned(64, 5)], bounded_input[ramp(t71 + 6, 1, 64) aligned(64, 6)]))))))
        }
        if (t131) {
         let t73.s = ((output.s0.y.yi + t165) % 16)*(t119 + 64)
         let t117 = output.extent.0 + t73.s
         output[ramp((((output.s0.y.yi + t165)*output.stride.1) + t132) + -64, 1, 64)] = max(bounded_input[ramp(t117 + -64, 1, 64)], max(bounded_input[ramp(t117 + -63, 1, 64)], max(bounded_input[ramp(t117 + -62, 1, 64)], max(bounded_input[ramp(t117 + -61, 1, 64)], max(bounded_input[ramp(t117 + -60, 1, 64)], max(bounded_input[ramp(t117 + -59, 1, 64)], bounded_input[ramp(t117 + -58, 1, 64)]))))))
        }
       }
      }
     }
     free bounded_input
    }
   }
   free repeat_edge
  }
 }
}
}


