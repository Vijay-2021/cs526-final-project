module name=average_pool_batch_0009_sample_0025, target=x86-64-linux-avx-avx2-disable_llvm_loop_opt-f16c-fma-sse41
external_plus_metadata func average_pool_batch_0009_sample_0025 (input, stride_x, stride_y, filter_width, filter_height, output_min, output_max, output) {
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let input.min.2 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 2)
let input.extent.2 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 2)
let input.stride.2 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 2)
let input.min.3 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 3)
let input.extent.3 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 3)
let input.stride.3 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 3)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
let output.min.2 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 2)
let output.extent.2 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 2)
let output.stride.2 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 2)
let output.min.3 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 3)
let output.extent.3 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 3)
let output.stride.3 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 3)
let input.extent.0.required.s = min(max(max(-512 - output.extent.0, output.extent.0 + -1)/512, 0)*512, output.extent.0 + -512)
let input.extent.1.required.s = let t656 = (stride_x < 0) in (let t657 = (0 < output.extent.0) in (let t658 = (((((output.extent.0 + 511)/512)*((output.extent.1 + 3)/4)) + -1)/((output.extent.0 + 511)/512)) in (let t659 = min(select(t657, t658, 0)*4, output.extent.1 + -4) in (let t660 = min(select(t657, 0, t658)*4, output.extent.1 + -4) in (let t661.s = select(t656, t659 + 3, t660) in (max(min(input.extent.1 + input.min.1, min((input.extent.1 + input.min.1) - ((output.min.1 + t661.s)*stride_x), filter_width) + ((select(t656, t660, t659 + 3) + output.min.1)*stride_x)) + -1, input.min.1) - max(min((output.min.1 + t661.s)*stride_x, (input.extent.1 + input.min.1) + -1), input.min.1)))))))
let input.min.1.required = let t662 = (0 < output.extent.0) in (let t663 = (((((output.extent.0 + 511)/512)*((output.extent.1 + 3)/4)) + -1)/((output.extent.0 + 511)/512)) in max(min((select(stride_x < 0, min(select(t662, t663, 0)*4, output.extent.1 + -4) + 3, min(select(t662, 0, t663)*4, output.extent.1 + -4)) + output.min.1)*stride_x, (input.extent.1 + input.min.1) + -1), input.min.1))
let input.extent.2.required.s = let t665 = (stride_y < 0) in (let t667.s = select(t665, output.extent.2 + 8, min(output.extent.2, 9)) in (let t668.s = select(t665, min(output.extent.2, 9), output.extent.2 + 8) in (max(min(input.extent.2 + input.min.2, min((input.extent.2 + input.min.2) - (((output.min.2 + t667.s) + -9)*stride_y), filter_height) + (((output.min.2 + t668.s) + -9)*stride_y)) + -1, input.min.2) - max(min((input.extent.2 + input.min.2) + -1, max(input.min.2 - (((output.min.2 + t668.s) + -9)*stride_y), 0) + (((output.min.2 + t667.s) + -9)*stride_y)), input.min.2))))
let input.min.2.required = let t669 = (stride_y < 0) in max(min((input.extent.2 + input.min.2) + -1, max(input.min.2 - (((select(t669, min(output.extent.2, 9), output.extent.2 + 8) + output.min.2) + -9)*stride_y), 0) + (((select(t669, output.extent.2 + 8, min(output.extent.2, 9)) + output.min.2) + -9)*stride_y)), input.min.2)
let input.stride.2.required = (max(input.extent.0.required.s, 0) + 512)*(input.extent.1.required.s + 1)
let output.extent.1.required.s = let t671 = (0 < output.extent.0) in (let t672 = (((((output.extent.0 + 511)/512)*((output.extent.1 + 3)/4)) + -1)/((output.extent.0 + 511)/512)) in (min(select(t671, t672, 0)*4, output.extent.1 + -4) - min(select(t671, 0, t672)*4, output.extent.1 + -4)))
let output.min.1.required.s = min(select(0 < output.extent.0, 0, ((((output.extent.0 + 511)/512)*((output.extent.1 + 3)/4)) + -1)/((output.extent.0 + 511)/512))*4, output.extent.1 + -4)
let output.stride.2.required = (max(input.extent.0.required.s, 0) + 512)*(output.extent.1.required.s + 4)
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)input.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)input.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 8, 4, (halide_dimension_t *)make_struct((min(output.extent.0, 512) + output.min.0) + -512, max(input.extent.0.required.s, 0) + 512, 1, 0, input.min.1.required, input.extent.1.required.s + 1, max(input.extent.0.required.s, 0) + 512, 0, input.min.2.required, input.extent.2.required.s + 1, input.stride.2.required, 0, output.min.3, output.extent.3, (input.extent.2.required.s + 1)*input.stride.2.required, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)output.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)output.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 8, 4, (halide_dimension_t *)make_struct((min(output.extent.0, 512) + output.min.0) + -512, max(input.extent.0.required.s, 0) + 512, 1, 0, output.min.1 + output.min.1.required.s, output.extent.1.required.s + 4, max(input.extent.0.required.s, 0) + 512, 0, (min(output.extent.2, 9) + output.min.2) + -9, max(output.extent.2, 9), output.stride.2.required, 0, output.min.3, output.extent.3, max(output.extent.2, 9)*output.stride.2.required, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || (uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer))) {
 assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
 assert(input.dimensions == 4, halide_error_bad_dimensions("Input buffer input", input.dimensions, 4))
 assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
 assert(output.dimensions == 4, halide_error_bad_dimensions("Output buffer output", output.dimensions, 4))
 assert(((input.min.0 + 512) <= (min(output.extent.0, 512) + output.min.0)) && (((max(input.extent.0.required.s, 0) + min(output.extent.0, 512)) + output.min.0) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, (min(output.extent.0, 512) + output.min.0) + -512, ((max(input.extent.0.required.s, 0) + min(output.extent.0, 512)) + output.min.0) + -1, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && (((input.extent.1.required.s + input.min.1.required) + 1) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, input.extent.1.required.s + input.min.1.required, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert((input.min.2 <= input.min.2.required) && (((input.extent.2.required.s + input.min.2.required) + 1) <= (input.extent.2 + input.min.2)), halide_error_access_out_of_bounds("Input buffer input", 2, input.min.2.required, input.extent.2.required.s + input.min.2.required, input.min.2, (input.extent.2 + input.min.2) + -1))
 assert(0 <= input.extent.2, halide_error_buffer_extents_negative("Input buffer input", 2, input.extent.2))
 assert((input.min.3 <= output.min.3) && ((output.extent.3 + output.min.3) <= (input.extent.3 + input.min.3)), halide_error_access_out_of_bounds("Input buffer input", 3, output.min.3, (output.extent.3 + output.min.3) + -1, input.min.3, (input.extent.3 + input.min.3) + -1))
 assert(0 <= input.extent.3, halide_error_buffer_extents_negative("Input buffer input", 3, input.extent.3))
 assert(max(max(input.extent.0.required.s, 0) + min(output.extent.0, 512), 512) <= output.extent.0, halide_error_access_out_of_bounds("Output buffer output", 0, (min(output.extent.0, 512) + output.min.0) + -512, ((max(input.extent.0.required.s, 0) + min(output.extent.0, 512)) + output.min.0) + -1, output.min.0, (output.extent.0 + output.min.0) + -1))
 assert((0 <= output.min.1.required.s) && ((((output.min.1 + output.min.1.required.s) + output.extent.1.required.s) + 4) <= (output.extent.1 + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, output.min.1 + output.min.1.required.s, ((output.min.1 + output.min.1.required.s) + output.extent.1.required.s) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
 assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
 assert(9 <= output.extent.2, halide_error_access_out_of_bounds("Output buffer output", 2, (min(output.extent.2, 9) + output.min.2) + -9, (output.extent.2 + output.min.2) + -1, output.min.2, (output.extent.2 + output.min.2) + -1))
 assert(0 <= output.extent.3, halide_error_buffer_extents_negative("Output buffer output", 3, output.extent.3))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let input.total_extent.2 = input.total_extent.1*int64(input.extent.2)
 let input.total_extent.3 = input.total_extent.2*int64(input.extent.3)
 let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
 let output.total_extent.2 = output.total_extent.1*int64(output.extent.2)
 let output.total_extent.3 = output.total_extent.2*int64(output.extent.3)
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.2)*int64(input.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.2)*int64(input.stride.2)), (uint64)2147483647))
 assert(input.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.2, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.3)*int64(input.stride.3)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.3)*int64(input.stride.3)), (uint64)2147483647))
 assert(input.total_extent.3 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.3, (int64)2147483647))
 assert(uint64(output.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", uint64(output.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1)), (uint64)2147483647))
 assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(output.extent.2)*int64(output.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.2)*int64(output.stride.2)), (uint64)2147483647))
 assert(output.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.2, (int64)2147483647))
 assert((uint64)abs(int64(output.extent.3)*int64(output.stride.3)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.3)*int64(output.stride.3)), (uint64)2147483647))
 assert(output.total_extent.3 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.3, (int64)2147483647))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(!output.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer output"))
 assert(input != (void *)reinterpret((uint64)0), halide_error_host_is_null("Input buffer input"))
 assert(output != (void *)reinterpret((uint64)0), halide_error_host_is_null("Output buffer output"))
 let output.s0.c.c.c.loop_extent = ((output.extent.0 + 511)/512)*((output.extent.1 + 3)/4)
 produce output {
  let t701 = input.extent.2 + input.min.2
  let t702 = output.extent.2 + 8
  let t703 = stride_y < 0
  let t704 = ((select(t703, 9, t702) + output.min.2) + -9)*stride_y
  let t705 = ((select(t703, t702, 9) + output.min.2) + -9)*stride_y
  let t706 = output.extent.2 + -1
  let t707 = (select(t703, 0, t706) + output.min.2)*stride_y
  let t708 = (select(t703, t706, 0) + output.min.2)*stride_y
  let t693 = max(min(t701 - t705, filter_height) + t704, min(t701 - t708, filter_height) + t707) + -1
  let t692 = min(max(input.min.2 - t704, 0) + t705, max(input.min.2 - t707, 0) + t708)
  let t694 = stride_x < 0
  let t696 = t702/9
  let t691 = (output.extent.0 + 511)/512
  let t700 = (((output.min.0 - (output.min.3*output.stride.3)) - (output.min.2*output.stride.2)) - (output.min.1*output.stride.1)) - output.min.0
  let t699 = ((input.min.1*input.stride.1) + ((input.min.3*input.stride.3) + (input.min.2*input.stride.2))) + input.min.0
  let t695 = input.extent.1 + input.min.1
  for (output.s0.b.rebased, 0, output.extent.3) {
   let t716 = output.min.3 + output.s0.b.rebased
   let t714 = (input.stride.3*t716) - t699
   let t711 = t693 - t692
   let t712 = select(t703, 8, 0) + output.min.2
   let t713 = select(t703, 0, 8) + output.min.2
   let t709 = select(t694, 3, 0) + output.min.1
   let t710 = select(t694, 0, 3) + output.min.1
   let t715 = (output.stride.3*t716) + t700
   parallel (output.s0.c.c.c, 0, output.s0.c.c.c.loop_extent) {
    let output.s0.c.ci.base.s = min((output.s0.c.c.c % t691)*512, output.extent.0 + -512)
    let output.s0.x.xi.base.s = min((output.s0.c.c.c/t691)*4, output.extent.1 + -4)
    let input_bounded.x.min_realized = min(max((output.s0.x.xi.base.s + t709)*stride_x, input.min.1), max(input.min.1 - ((output.s0.x.xi.base.s + t710)*stride_x), 0) + ((output.s0.x.xi.base.s + t709)*stride_x))
    let input_bounded.x.extent_realized.s = min(t695 - ((output.s0.x.xi.base.s + t709)*stride_x), filter_width) + ((output.s0.x.xi.base.s + t710)*stride_x)
    allocate input_bounded[uint8 * 512 * (input_bounded.x.extent_realized.s - input_bounded.x.min_realized) * (t711 + 1) * 1]
    let t719 = input_bounded.x.extent_realized.s - input_bounded.x.min_realized
    let t720 = output.s0.c.ci.base.s + t715
    let t717 = output.min.1 + output.s0.x.xi.base.s
    let t718 = output.min.0 + output.s0.c.ci.base.s
    for (output.s0.y.y, 0, t696) {
     let output.s0.y.yi.base.s = min(output.s0.y.y*9, output.extent.2 + -9)
     let t724 = (output.s0.y.yi.base.s + t712)*stride_y
     let t725 = (output.s0.y.yi.base.s + t713)*stride_y
     let t722 = max(input.min.2 - t725, 0) + t724
     let t721 = min(t701 - t724, filter_height) + t725
     let t723 = output.min.2 + output.s0.y.yi.base.s
     for (output.s0.x.xi, 0, 4) {
      let input_bounded.s0.x.max_2.s = min(((output.s0.x.xi + t717)*stride_x) + filter_width, t695)
      let input_bounded.s0.x.min_2 = max((output.s0.x.xi + t717)*stride_x, input.min.1)
      produce input_bounded {
       let t728 = t722 - t692
       let t726 = t721 - t722
       let t729 = input_bounded.s0.x.min_2 - input_bounded.x.min_realized
       let t727 = input_bounded.s0.x.max_2.s - input_bounded.s0.x.min_2
       for (input_bounded.s0.y.rebased, 0, t726) {
        let t731 = (((input_bounded.s0.y.rebased + t728)*t719)*512) - t718
        let t730 = (max(min(t701 + -1, input_bounded.s0.y.rebased + t722), input.min.2)*input.stride.2) + t714
        for (input_bounded.s0.x.rebased, 0, t727) {
         let t732 = (max(min(t695 + -1, input_bounded.s0.x.min_2 + input_bounded.s0.x.rebased), input.min.1)*input.stride.1) + t730
         let t733 = ((input_bounded.s0.x.rebased + t729)*512) + t731
         for (input_bounded.s0.c.c, 0, 16) {
          let input_bounded.s0.c.ci.base = (input_bounded.s0.c.c*32) + t718
          input_bounded[ramp(input_bounded.s0.c.ci.base + t733, 1, 32)] = input[ramp(input_bounded.s0.c.ci.base + t732, 1, 32)]
         }
        }
       }
      }
      consume input_bounded {
       let t739 = output.s0.x.xi + t717
       let t740 = stride_x*t739
       let t735 = min(t695 - t740, filter_width)
       let t734 = min(input.min.1 - t740, filter_width)
       let t736 = t740 - input_bounded.x.min_realized
       let t738 = (output.stride.1*t739) + t720
       for (output.s0.y.yi, 0, 9) {
        let t749 = output.s0.y.yi + t723
        let t750 = max(t734, 0)
        let t751 = stride_y*t749
        let t743 = max(t734, t735)
        let t742 = min(t701 - t751, filter_height)
        let t741 = min(input.min.2 - t751, filter_height)
        let t747 = (min(filter_width + t740, t695) - max(input.min.1, t740))*(min(filter_height + t751, t701) - max(input.min.2, t751))
        let t745 = t751 - t692
        let t746 = t736 + t750
        let t748 = (output.stride.2*t749) + t738
        for (output.s0.c.ci.ci, 0, 16) {
         allocate sum[uint16 * 32] in Stack
         produce sum {
          sum[ramp(0, 1, 16)] = x16((uint16)0)
          sum[ramp(16, 1, 16)] = x16((uint16)0)
          let sum.s1.r12$y.new_max.s = max(t741, t742)
          let t755 = max(t741, 0)
          let t753 = max(t743, 0) - t750
          let t752 = max(sum.s1.r12$y.new_max.s, 0) - t755
          let t754 = t745 + t755
          for (sum.s1.r12$y.rebased, 0, t752) {
           let t756 = (((sum.s1.r12$y.rebased + t754)*t719)*16) + output.s0.c.ci.ci
           for (sum.s1.r12$x.rebased, 0, t753) {
            sum[ramp(0, 1, 32)] = sum[ramp(0, 1, 32)] + uint16x32(input_bounded[ramp((((sum.s1.r12$x.rebased + t746)*16) + t756)*32, 1, 32) aligned(32, 0)])
           }
          }
         }
         consume sum {
          output[ramp((output.s0.c.ci.ci*32) + t748, 1, 32)] = max(min(uint8x32(min((uint16x32)rounding_mul_shift_right(sum[ramp(0, 1, 32)], x32(uint16(max(min((t747 + 131072)/(t747*2), 65535), 0))), x32((uint16)16)), x32((uint16)255))), x32((uint8)output_max)), x32((uint8)output_min))
         }
         free sum
        }
       }
      }
     }
    }
    free input_bounded
   }
  }
 }
}
}


