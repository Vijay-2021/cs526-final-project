module name=chroma_batch_0055_sample_0000, target=x86-64-linux-avx-avx2-avx512-avx512_sapphirerapids-avx512_skylake-disable_llvm_loop_opt-f16c-fma-sse41
external_plus_metadata func chroma_batch_0055_sample_0000 (input, output) {
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let input.min.2 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 2)
let input.extent.2 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 2)
let input.stride.2 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 2)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
let output.min.2 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 2)
let output.extent.2 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 2)
let output.stride.2 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 2)
let input.stride.2.required = max(output.extent.0, 32)*max(output.extent.1, 4)
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)input.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)input.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 16, 3, (halide_dimension_t *)make_struct((min(output.extent.0, 32) + output.min.0) + -32, max(output.extent.0, 32), 1, 0, (min(output.extent.1, 4) + output.min.1) + -4, max(output.extent.1, 4), max(output.extent.0, 32), 0, 0, 3, input.stride.2.required, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)output.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)output.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 16, 3, (halide_dimension_t *)make_struct((min(output.extent.0, 32) + output.min.0) + -32, max(output.extent.0, 32), 1, 0, (min(output.extent.1, 4) + output.min.1) + -4, max(output.extent.1, 4), max(output.extent.0, 32), 0, output.min.2, output.extent.2, input.stride.2.required, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || (uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer))) {
 assert(input.type == (uint32)69633, halide_error_bad_type("Input buffer input", input.type, (uint32)69633))
 assert(input.dimensions == 3, halide_error_bad_dimensions("Input buffer input", input.dimensions, 3))
 assert(output.type == (uint32)69633, halide_error_bad_type("Output buffer output", output.type, (uint32)69633))
 assert(output.dimensions == 3, halide_error_bad_dimensions("Output buffer output", output.dimensions, 3))
 assert(((input.min.0 + 32) <= (min(output.extent.0, 32) + output.min.0)) && ((output.extent.0 + output.min.0) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, (min(output.extent.0, 32) + output.min.0) + -32, (output.extent.0 + output.min.0) + -1, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert(((input.min.1 + 4) <= (min(output.extent.1, 4) + output.min.1)) && ((output.extent.1 + output.min.1) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, (min(output.extent.1, 4) + output.min.1) + -4, (output.extent.1 + output.min.1) + -1, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert((input.min.2 <= 0) && (3 <= (input.extent.2 + input.min.2)), halide_error_access_out_of_bounds("Input buffer input", 2, 0, 2, input.min.2, (input.extent.2 + input.min.2) + -1))
 assert(0 <= input.extent.2, halide_error_buffer_extents_negative("Input buffer input", 2, input.extent.2))
 assert(32 <= output.extent.0, halide_error_access_out_of_bounds("Output buffer output", 0, (min(output.extent.0, 32) + output.min.0) + -32, (output.extent.0 + output.min.0) + -1, output.min.0, (output.extent.0 + output.min.0) + -1))
 assert(4 <= output.extent.1, halide_error_access_out_of_bounds("Output buffer output", 1, (min(output.extent.1, 4) + output.min.1) + -4, (output.extent.1 + output.min.1) + -1, output.min.1, (output.extent.1 + output.min.1) + -1))
 assert(0 <= output.extent.2, halide_error_buffer_extents_negative("Output buffer output", 2, output.extent.2))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let input.total_extent.2 = input.total_extent.1*int64(input.extent.2)
 let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
 let output.total_extent.2 = output.total_extent.1*int64(output.extent.2)
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.2)*int64(input.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.2)*int64(input.stride.2)), (uint64)2147483647))
 assert(input.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.2, (int64)2147483647))
 assert(uint64(output.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", uint64(output.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1)), (uint64)2147483647))
 assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(output.extent.2)*int64(output.stride.2)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.2)*int64(output.stride.2)), (uint64)2147483647))
 assert(output.total_extent.2 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.2, (int64)2147483647))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(!output.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer output"))
 assert(input != (void *)reinterpret((uint64)0), halide_error_host_is_null("Input buffer input"))
 assert(output != (void *)reinterpret((uint64)0), halide_error_host_is_null("Output buffer output"))
 produce output {
  let t248 = output.extent.0 + output.min.0
  let t249 = output.min.2*output.stride.2
  let t250 = output.min.1*output.stride.1
  let t244 = (output.extent.0 % 32) != 0
  let t240 = (output.extent.1 + 3)/4
  let t241 = output.extent.0/32
  let t247 = ((t248 - t249) - t250) - output.min.0
  let t246 = 0 - (t249 + t250)
  let t242 = ((input.min.2*input.stride.2) + (input.min.1*input.stride.1)) + input.min.0
  parallel (output.s0.v1.v1, 0, t240) {
   let output.s0.v1.v1i.base.s = min(output.s0.v1.v1*4, output.extent.1 + -4)
   let t253 = (input.stride.2*2) - t242
   let t252 = input.stride.2 - t242
   let t251 = output.min.1 + output.s0.v1.v1i.base.s
   for (output.s0.v1.v1i, 0, 4) {
    allocate f2[uint16 * output.extent.0 * 1] in Stack
    produce f2 {
     let t254 = ((output.s0.v1.v1i + t251)*input.stride.1) + output.min.0
     for (f2.s0.v0.v0, 0, t241) {
      allocate f1[uint16 * 32] in Stack
      produce f1 {
       let t202 = (f2.s0.v0.v0*32) + t254
       f1[ramp(0, 1, 32)] = min(input[ramp(t202 - t242, 1, 32)], min(input[ramp(t202 + t252, 1, 32)], input[ramp(t202 + t253, 1, 32)]))
      }
      consume f1 {
       let t204 = (f2.s0.v0.v0*32) + t254
       f2[ramp(f2.s0.v0.v0*32, 1, 32) aligned(32, 0)] = max(input[ramp(t204 - t242, 1, 32)], max(input[ramp(t204 + t252, 1, 32)], input[ramp(t204 + t253, 1, 32)])) - f1[ramp(0, 1, 32)]
      }
      free f1
     }
     if (t244) {
      allocate f1[uint16 * 32] in Stack
      produce f1 {
       let t206 = ((output.s0.v1.v1i + t251)*input.stride.1) + t248
       f1[ramp(0, 1, 32)] = min(input[ramp((t206 - t242) + -32, 1, 32)], min(input[ramp((t206 + t252) + -32, 1, 32)], input[ramp((t206 + t253) + -32, 1, 32)]))
      }
      consume f1 {
       let t208 = ((output.s0.v1.v1i + t251)*input.stride.1) + t248
       f2[ramp(output.extent.0 + -32, 1, 32)] = max(input[ramp((t208 - t242) + -32, 1, 32)], max(input[ramp((t208 + t252) + -32, 1, 32)], input[ramp((t208 + t253) + -32, 1, 32)])) - f1[ramp(0, 1, 32)]
      }
      free f1
     }
    }
    consume f2 {
     let t259 = output.s0.v1.v1i + t251
     let t260 = input.stride.1*t259
     let t261 = output.stride.1*t259
     let t258 = t247 + t261
     let t256 = t246 + t261
     let t257 = t248 + t260
     let t255 = output.min.0 + t260
     for (output.s0.v2.rebased, 0, output.extent.2) {
      let t262 = output.min.2 + output.s0.v2.rebased
      for (output.s0.v0.v0, 0, t241) {
       let t210 = f2[ramp(output.s0.v0.v0*32, 1, 32) aligned(32, 0)]
       let t213 = (output.s0.v0.v0*32) + t255
       let t215 = input[ramp(t213 - t242, 1, 32)]
       let t216 = input[ramp(t213 + t252, 1, 32)]
       let t217 = input[ramp(t213 + t253, 1, 32)]
       let t218 = max(max(t216, t217), t215)
       let t219 = t218 - (uint16x32)shift_right(t210, x32((uint16)1))
       output[ramp((output.s0.v0.v0*32) + ((output.stride.2*t262) + t256), 1, 32)] = select(t262 == 0, select(t210 == x32((uint16)0), x32((uint16)0), select(t215 == t218, ((t216 - t217)/t210)*x32((uint16)60), select(t216 == t218, (((t217 - t215)/t210)*x32((uint16)60)) + x32((uint16)120), (((t215 - t216)/t210)*x32((uint16)60)) + x32((uint16)240))))/x32((uint16)360), select(t262 == 1, (t218 - t219)/min(x32((uint16)1) - t219, t219), t219))
      }
      if (t244) {
       let t220 = f2[ramp(output.extent.0 + -32, 1, 32)]
       let t225 = input[ramp((t257 - t242) + -32, 1, 32)]
       let t226 = input[ramp((t252 + t257) + -32, 1, 32)]
       let t227 = input[ramp((t253 + t257) + -32, 1, 32)]
       let t228 = max(max(t226, t227), t225)
       let t229 = t228 - (uint16x32)shift_right(t220, x32((uint16)1))
       let t239 = output.min.2 + output.s0.v2.rebased
       output[ramp(((output.stride.2*t239) + t258) + -32, 1, 32)] = select(t239 == 0, select(t220 == x32((uint16)0), x32((uint16)0), select(t225 == t228, ((t226 - t227)/t220)*x32((uint16)60), select(t226 == t228, (((t227 - t225)/t220)*x32((uint16)60)) + x32((uint16)120), (((t225 - t226)/t220)*x32((uint16)60)) + x32((uint16)240))))/x32((uint16)360), select(t239 == 1, (t228 - t229)/min(x32((uint16)1) - t229, t229), t229))
      }
     }
    }
    free f2
   }
  }
 }
}
}


