module name=conv3x3a16_batch_0017_sample_0002, target=x86-64-linux-avx-avx2-avx512-avx512_sapphirerapids-avx512_skylake-disable_llvm_loop_opt-f16c-fma-sse41
external_plus_metadata func conv3x3a16_batch_0017_sample_0002 (input, mask, output) {
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)mask.buffer) != (uint64)0, halide_error_buffer_argument_is_null("mask"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let mask = (void *)_halide_buffer_get_host((halide_buffer_t *)mask.buffer)
let mask.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)mask.buffer)
let mask.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)mask.buffer)
let mask.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)mask.buffer)
let mask.min.0 = _halide_buffer_get_min((halide_buffer_t *)mask.buffer, 0)
let mask.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)mask.buffer, 0)
let mask.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)mask.buffer, 0)
let mask.min.1 = _halide_buffer_get_min((halide_buffer_t *)mask.buffer, 1)
let mask.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)mask.buffer, 1)
let mask.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)mask.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.device_dirty = (uint1)_halide_buffer_get_device_dirty((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
let input.extent.0.required.s = max(min(min((min(output.extent.0, 64) + (((max(output.extent.0, 64) + 1)/64)*64)) + -2, output.extent.0) + output.min.0, (input.extent.0 + input.min.0) + -1), input.min.0) - max(min(min(output.extent.0, 64) + output.min.0, (input.extent.0 + input.min.0) + 64) + -65, input.min.0)
let input.min.0.required = max(min(min(output.extent.0, 64) + output.min.0, (input.extent.0 + input.min.0) + 64) + -65, input.min.0)
let input.extent.1.required.s = max(min(output.extent.1 + output.min.1, (input.extent.1 + input.min.1) + -1), input.min.1) - max(min(min(output.extent.1, 108) + output.min.1, (input.extent.1 + input.min.1) + 108) + -109, input.min.1)
let input.min.1.required = max(min(min(output.extent.1, 108) + output.min.1, (input.extent.1 + input.min.1) + 108) + -109, input.min.1)
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)input.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)input.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 8, 2, (halide_dimension_t *)make_struct(input.min.0.required, input.extent.0.required.s + 1, 1, 0, input.min.1.required, input.extent.1.required.s + 1, input.extent.0.required.s + 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)mask.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)mask.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)mask.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 0, 8, 2, (halide_dimension_t *)make_struct(0, 3, 1, 0, 0, 3, 3, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer)) {
 (halide_buffer_t *)_halide_buffer_init((halide_buffer_t *)output.buffer, (halide_dimension_t *)_halide_buffer_get_shape((halide_buffer_t *)output.buffer), (void *)reinterpret((uint64)0), (uint64)0, (halide_device_interface_t *)reinterpret((uint64)0), 1, 8, 2, (halide_dimension_t *)make_struct((min(output.extent.0, 64) + output.min.0) + -64, max(output.extent.0, 64), 1, 0, (min(output.extent.1, 108) + output.min.1) + -108, max(output.extent.1, 108), max(output.extent.0, 64), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || (uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)mask.buffer)))) {
 assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
 assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
 assert(mask.type == (uint32)67584, halide_error_bad_type("Input buffer mask", mask.type, (uint32)67584))
 assert(mask.dimensions == 2, halide_error_bad_dimensions("Input buffer mask", mask.dimensions, 2))
 assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
 assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
 assert((input.min.0 <= input.min.0.required) && (((input.extent.0.required.s + input.min.0.required) + 1) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, input.extent.0.required.s + input.min.0.required, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= input.min.1.required) && (((input.extent.1.required.s + input.min.1.required) + 1) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, input.extent.1.required.s + input.min.1.required, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert((mask.min.0 <= 0) && (3 <= (mask.extent.0 + mask.min.0)), halide_error_access_out_of_bounds("Input buffer mask", 0, 0, 2, mask.min.0, (mask.extent.0 + mask.min.0) + -1))
 assert(0 <= mask.extent.0, halide_error_buffer_extents_negative("Input buffer mask", 0, mask.extent.0))
 assert((mask.min.1 <= 0) && (3 <= (mask.extent.1 + mask.min.1)), halide_error_access_out_of_bounds("Input buffer mask", 1, 0, 2, mask.min.1, (mask.extent.1 + mask.min.1) + -1))
 assert(0 <= mask.extent.1, halide_error_buffer_extents_negative("Input buffer mask", 1, mask.extent.1))
 assert(64 <= output.extent.0, halide_error_access_out_of_bounds("Output buffer output", 0, (min(output.extent.0, 64) + output.min.0) + -64, (output.extent.0 + output.min.0) + -1, output.min.0, (output.extent.0 + output.min.0) + -1))
 assert(108 <= output.extent.1, halide_error_access_out_of_bounds("Output buffer output", 1, (min(output.extent.1, 108) + output.min.1) + -108, (output.extent.1 + output.min.1) + -1, output.min.1, (output.extent.1 + output.min.1) + -1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 assert(mask.stride.0 == 1, halide_error_constraint_violated("mask.stride.0", mask.stride.0, "1", 1))
 assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 let mask.total_extent.1 = int64(mask.extent.1)*int64(mask.extent.0)
 let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
 assert(uint64(input.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", uint64(input.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert(uint64(mask.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("mask", uint64(mask.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(mask.extent.1)*int64(mask.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("mask", (uint64)abs(int64(mask.extent.1)*int64(mask.stride.1)), (uint64)2147483647))
 assert(mask.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("mask", mask.total_extent.1, (int64)2147483647))
 assert(uint64(output.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", uint64(output.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1)), (uint64)2147483647))
 assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(!mask.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer mask"))
 assert(!output.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer output"))
 assert(input != (void *)reinterpret((uint64)0), halide_error_host_is_null("Input buffer input"))
 assert(mask != (void *)reinterpret((uint64)0), halide_error_host_is_null("Input buffer mask"))
 assert(output != (void *)reinterpret((uint64)0), halide_error_host_is_null("Output buffer output"))
 produce output {
  let t326 = input.extent.0 + input.min.0
  let t327 = input.extent.1 + input.min.1
  let t328 = output.min.1*output.stride.1
  let t329 = output.extent.0 + 1
  let t330 = (output.extent.0 + 65)/64
  let t331 = min(max((input.min.0 - output.min.0)/64, -1) + 1, t330)
  let t332 = t326 - output.min.0
  let t324 = (output.extent.0 % 64) != 0
  let t316 = max((min(min(min(output.extent.0 + -62, t332), min(t329, t332) + -63), t329)/64) + 1, t331)
  let t308 = (output.extent.1 + 107)/108
  let t319 = output.extent.0/64
  let t309 = (t329/64)*64
  let t322 = mask.min.1*mask.stride.1
  let t321 = ((2 - mask.min.1)*mask.stride.1) - mask.min.0
  let t320 = ((1 - mask.min.1)*mask.stride.1) - mask.min.0
  let t325 = output.extent.0 - t328
  let t323 = 0 - t328
  parallel (output.s0.y.y, 0, t308) {
   let output.s0.y.yi.base.s = min(output.s0.y.y*108, output.extent.1 + -108)
   allocate repeat_edge[uint8 * (t309 + 64) * 110]
   produce repeat_edge {
    let repeat_edge.s0._1.prologue = min(max((output.min.1 + output.s0.y.yi.base.s) + -1, input.min.1), (output.min.1 + output.s0.y.yi.base.s) + 109)
    let repeat_edge.s0._1.epilogue = min(max(max((output.min.1 + output.s0.y.yi.base.s) + -1, input.min.1), t327), (output.min.1 + output.s0.y.yi.base.s) + 109)
    let t333 = max(min((input.min.1 - output.min.1) - min(output.s0.y.y*108, output.extent.1 + -108), 109), -1)
    let t334 = (output.min.1 - input.min.1) + output.s0.y.yi.base.s
    for (repeat_edge.s0._1.rebased, 0, t333 + 1) {
     let t336 = (t309 + 64)*repeat_edge.s0._1.rebased
     let t335 = ((max(min(repeat_edge.s0._1.rebased + t334, input.extent.1), 1) + -1)*input.stride.1) - input.min.0
     for (repeat_edge.s0._0._0, 0, t330) {
      let repeat_edge.s0._0._0i.base.s = min((repeat_edge.s0._0._0*64) + 62, output.extent.0)
      repeat_edge[ramp((repeat_edge.s0._0._0i.base.s + t336) + -62, 1, 64)] = input[max(min(ramp((output.min.0 + repeat_edge.s0._0._0i.base.s) + -63, 1, 64), x64(t326 + -1)), x64(input.min.0)) + x64(t335)]
     }
    }
    let t343 = min(output.s0.y.y*108, output.extent.1 + -108)
    let t344 = output.min.1 + t343
    let t345 = t344 + -1
    let t346 = t344 + 109
    let t337 = min(max(t327, t345), t346) - min(max(input.min.1, t345), t346)
    let t342 = t330 - t316
    let t339 = repeat_edge.s0._1.prologue - input.min.1
    for (repeat_edge.s0._1.rebased, 0, t337) {
     let t348 = ((repeat_edge.s0._1.rebased + t339)*input.stride.1) - input.min.0
     for (repeat_edge.s0._0._0, 0, t331) {
      let repeat_edge.s0._0._0i.base.s = min((repeat_edge.s0._0._0*64) + 62, output.extent.0)
      repeat_edge[ramp(((((max(min((input.min.1 - output.min.1) - t343, 109), -1) + repeat_edge.s0._1.rebased) + 1)*(t309 + 64)) + repeat_edge.s0._0._0i.base.s) + -62, 1, 64)] = input[max(min(ramp((output.min.0 + repeat_edge.s0._0._0i.base.s) + -63, 1, 64), x64(t326 + -1)), x64(input.min.0)) + x64(t348)]
     }
     let t349 = t316 - t331
     let t351 = ((repeat_edge.s0._1.rebased + t339)*input.stride.1) + (output.min.0 - input.min.0)
     for (repeat_edge.s0._0._0.rebased, 0, t349) {
      let t297 = repeat_edge.s0._0._0.rebased + t331
      repeat_edge[ramp((((max(min((input.min.1 - output.min.1) - t343, 109), -1) + repeat_edge.s0._1.rebased) + 1)*(t309 + 64)) + (t297*64), 1, 64) aligned(64, 0)] = input[ramp(((t297*64) + t351) + -1, 1, 64)]
     }
     let t353 = ((repeat_edge.s0._1.rebased + t339)*input.stride.1) - input.min.0
     for (repeat_edge.s0._0._0.rebased, 0, t342) {
      let repeat_edge.s0._0._0i.base.s = min(((repeat_edge.s0._0._0.rebased + t316)*64) + 62, output.extent.0)
      repeat_edge[ramp(((((max(min((input.min.1 - output.min.1) - t343, 109), -1) + repeat_edge.s0._1.rebased) + 1)*(t309 + 64)) + repeat_edge.s0._0._0i.base.s) + -62, 1, 64)] = input[max(min(ramp((output.min.0 + repeat_edge.s0._0._0i.base.s) + -63, 1, 64), x64(t326 + -1)), x64(input.min.0)) + x64(t353)]
     }
    }
    let t357 = min(output.s0.y.y*108, output.extent.1 + -108)
    let t354 = max(min((output.min.1 - t327) + t357, 1), -109)
    let t356 = repeat_edge.s0._1.epilogue - input.min.1
    for (repeat_edge.s0._1.rebased, 0, t354 + 109) {
     let t359 = (max(min(repeat_edge.s0._1.rebased + t356, input.extent.1 + -1), 0)*input.stride.1) - input.min.0
     for (repeat_edge.s0._0._0, 0, t330) {
      let repeat_edge.s0._0._0i.base.s = min((repeat_edge.s0._0._0*64) + 62, output.extent.0)
      repeat_edge[ramp(((((max(min((t327 - output.min.1) - t357, 109), -1) + repeat_edge.s0._1.rebased) + 1)*(t309 + 64)) + repeat_edge.s0._0._0i.base.s) + -62, 1, 64)] = input[max(min(ramp((output.min.0 + repeat_edge.s0._0._0i.base.s) + -63, 1, 64), x64(t326 + -1)), x64(input.min.0)) + x64(t359)]
     }
    }
   }
   consume repeat_edge {
    let t361 = (2 - t322) - mask.min.0
    let t363 = (1 - t322) - mask.min.0
    let t362 = (0 - t322) - mask.min.0
    let t360 = output.min.1 + output.s0.y.yi.base.s
    for (output.s0.y.yi.yi, 0, 3) {
     allocate input_bounded[uint8 * (t309 + 64) * 16] in Stack
     let t364 = output.s0.y.yi.yi*36
     for (output.s0.y.yi.yii.yii.$n.rebased, 0, 5) {
      let input_bounded.s0.y.min_3.s.s = max(output.s0.y.yi.yii.yii.$n.rebased*9, 7) + t364
      produce input_bounded {
       let t365 = min(output.s0.y.yi.yii.yii.$n.rebased*9, 7)
       let t366 = input_bounded.s0.y.min_3.s.s + t360
       for (input_bounded.s0.y.rebased, 0, t365 + 2) {
        let t369 = t309 + 64
        let t368 = (((input_bounded.s0.y.rebased + t366) + 8) % 16)*t369
        let t367 = ((input_bounded.s0.y.min_3.s.s + input_bounded.s0.y.rebased) + -7)*t369
        for (input_bounded.s0.x.x, 0, t330) {
         input_bounded[ramp((input_bounded.s0.x.x*64) + t368, 1, 64) aligned(64, 0)] = repeat_edge[ramp((input_bounded.s0.x.x*64) + t367, 1, 64) aligned(64, 0)]
        }
       }
      }
      if (1 <= output.s0.y.yi.yii.yii.$n.rebased) {
       consume input_bounded {
        let t370 = (output.s0.y.yi.yii.yii.$n.rebased*9) + t364
        for (output.s0.y.yi.yii.yiii, 0, 9) {
         let output.s0.y.yi.s = output.s0.y.yi.yii.yiii + t370
         let t375 = output.s0.y.yi.s + t360
         let t376 = t309 + 64
         let t371 = ((t375 + 8) % 16)*t376
         let t372 = ((t375 + 7) % 16)*t376
         let t373 = ((t375 + 6) % 16)*t376
         let t374 = ((t375 + -9)*output.stride.1) + t323
         for (output.s0.x.x, 0, t319) {
          let t245 = (output.s0.x.x*64) + t371
          let t247 = (output.s0.x.x*64) + t372
          let t250 = (output.s0.x.x*64) + t373
          output[ramp((output.s0.x.x*64) + t374, 1, 64)] = uint8x64(max(min((int16x64)shift_right((int16x64)widening_mul(input_bounded[ramp(t250 + 1, 1, 64) aligned(64, 1)], x64(mask[t363])) + ((int16x64)widening_mul(input_bounded[ramp(t250, 1, 64) aligned(64, 0)], x64(mask[t362])) + ((int16x64)widening_mul(input_bounded[ramp(t250 + 2, 1, 64) aligned(64, 2)], x64(mask[t361])) + ((int16x64)widening_mul(input_bounded[ramp(t247, 1, 64) aligned(64, 0)], x64(mask[t320])) + ((int16x64)widening_mul(input_bounded[ramp(t247 + 1, 1, 64) aligned(64, 1)], x64(mask[t320 + 1])) + ((int16x64)widening_mul(input_bounded[ramp(t247 + 2, 1, 64) aligned(64, 2)], x64(mask[t320 + 2])) + ((int16x64)widening_mul(input_bounded[ramp(t245, 1, 64) aligned(64, 0)], x64(mask[t321])) + ((int16x64)widening_mul(input_bounded[ramp(t245 + 2, 1, 64) aligned(64, 2)], x64(mask[t321 + 2])) + (int16x64)widening_mul(input_bounded[ramp(t245 + 1, 1, 64) aligned(64, 1)], x64(mask[t321 + 1]))))))))), x64((uint16)4)), x64((int16)255)), x64((int16)0)))
         }
         if (t324) {
          let t252.s = (((output.s0.y.yi.s + t360) + 8) % 16)*(t309 + 64)
          let t254.s = (((output.s0.y.yi.s + t360) + 7) % 16)*(t309 + 64)
          let t257.s = (((output.s0.y.yi.s + t360) + 6) % 16)*(t309 + 64)
          let t303 = output.extent.0 + t252.s
          let t305 = output.extent.0 + t254.s
          let t306 = output.extent.0 + t257.s
          output[ramp(((((output.s0.y.yi.s + t360) + -9)*output.stride.1) + t325) + -64, 1, 64)] = uint8x64(max(min((int16x64)shift_right((int16x64)widening_mul(input_bounded[ramp(t306 + -63, 1, 64)], x64(mask[t363])) + ((int16x64)widening_mul(input_bounded[ramp(t306 + -64, 1, 64)], x64(mask[t362])) + ((int16x64)widening_mul(input_bounded[ramp(t306 + -62, 1, 64)], x64(mask[t361])) + ((int16x64)widening_mul(input_bounded[ramp(t305 + -64, 1, 64)], x64(mask[t320])) + ((int16x64)widening_mul(input_bounded[ramp(t305 + -63, 1, 64)], x64(mask[t320 + 1])) + ((int16x64)widening_mul(input_bounded[ramp(t305 + -62, 1, 64)], x64(mask[t320 + 2])) + ((int16x64)widening_mul(input_bounded[ramp(t303 + -64, 1, 64)], x64(mask[t321])) + ((int16x64)widening_mul(input_bounded[ramp(t303 + -62, 1, 64)], x64(mask[t321 + 2])) + (int16x64)widening_mul(input_bounded[ramp(t303 + -63, 1, 64)], x64(mask[t321 + 1]))))))))), x64((uint16)4)), x64((int16)255)), x64((int16)0)))
         }
        }
       }
      }
     }
     free input_bounded
    }
   }
   free repeat_edge
  }
 }
}
}


