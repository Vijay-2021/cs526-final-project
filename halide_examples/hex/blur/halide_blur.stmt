module name=halide_blur, target=hexagon-32-noos-hvx-hvx_128-no_asserts-no_bounds_query
external_plus_metadata func halide_blur (input, blur_y) {
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
assert((uint64)reinterpret((halide_buffer_t *)blur_y.buffer) != (uint64)0, halide_error_buffer_argument_is_null("blur_y"))
let blur_y = (void *)_halide_buffer_get_host((halide_buffer_t *)blur_y.buffer)
let blur_y.min.0 = _halide_buffer_get_min((halide_buffer_t *)blur_y.buffer, 0)
let blur_y.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)blur_y.buffer, 0)
let blur_y.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)blur_y.buffer, 0)
let blur_y.min.1 = _halide_buffer_get_min((halide_buffer_t *)blur_y.buffer, 1)
let blur_y.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)blur_y.buffer, 1)
let blur_y.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)blur_y.buffer, 1)
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
assert(blur_y.stride.0 == 1, 0)
assert(input.stride.0 == 1, 0)
produce blur_y {
 let t112 = min(blur_y.extent.0, 256)
 let t113 = max(blur_y.extent.0, 256)
 let t114 = ((t113 + -1)/128)*128
 let t115 = blur_y.min.1*blur_y.stride.1
 let t116 = input.min.1*input.stride.1
 let t117 = max(blur_y.extent.0/256, 0)
 let t106 = (t113 % 128) != 0
 let t103 = t113/128
 let t93 = (blur_y.extent.1 + 127)/128
 let t110 = ((blur_y.extent.0 + 255)/256) - t117
 let t105 = ((2 - input.min.1)*input.stride.1) - input.min.0
 let t107 = ((((input.stride.1*2) + blur_y.extent.0) + blur_y.min.0) - t116) - input.min.0
 let t111 = blur_y.extent.0 - t115
 let t109 = 0 - t115
 let t99 = (t112 + t114) + blur_y.min.0
 let t98 = input.extent.1 + input.min.1
 let t97 = input.extent.0 + input.min.0
 let t96 = blur_y.extent.0 + blur_y.min.0
 for<Hexagon> (blur_y.s0.__outermost, 0, 1) {
  let t123 = blur_y.min.0 + t112
  let t119 = (input.min.0 + 256) <= t123
  let t121 = (max(min(t99 + -128, t96), min(t96 + 128, t99) + -127) - t112) - blur_y.min.0
  let t120 = ((((input.stride.1*-128) + t112) + blur_y.min.0) - t116) - input.min.0
  let t118 = (t112 + t114) + blur_y.min.0
  parallel (blur_y.s0.y.y, 0, t93) {
   if (let t130 = (blur_y.min.1 + min((blur_y.s0.y.y*128) + 384, blur_y.extent.1)) in (((((max(min(t118 + -128, t96), min(t96 + 128, t118) + -127) + 1) <= t97) && t119) && ((input.min.1 + 128) <= t130)) && ((t130 + 2) <= t98))) {
    (uint16)prefetch(input, (((min((blur_y.s0.y.y*128) + 384, blur_y.extent.1) + blur_y.min.1)*input.stride.1) + t120) + -256, t121 + 257, 1, 130, input.stride.1)
   }
   let blur_y.s0.y.yi.base.s = min(blur_y.s0.y.y*128, blur_y.extent.1 + -128)
   allocate blur_x[uint16 * t113 * 4]
   let t124 = blur_y.min.1 + blur_y.s0.y.yi.base.s
   for (blur_y.s0.y.yi.$n.rebased, 0, 130) {
    produce blur_x {
     let t127 = blur_y.s0.y.yi.$n.rebased + t124
     let t126 = ((t127 % 4)*t113) - t123
     let t125 = ((t127 + -2)*input.stride.1) + t105
     for (blur_x.s0.x.x, 0, t103) {
      let blur_x.s0.x.v1.base.s = (blur_x.s0.x.x*128) + t123
      let t75 = blur_x.s0.x.v1.base.s + t125
      blur_x[ramp(blur_x.s0.x.v1.base.s + t126, 1, 128)] = (input[ramp(t75 + -255, 1, 128)] + (input[ramp(t75 + -254, 1, 128)] + input[ramp(t75 + -256, 1, 128)]))/x128((uint16)3)
     }
     if (t106) {
      let t77 = (((blur_y.s0.y.yi.$n.rebased + t124) + -2)*input.stride.1) + t107
      blur_x[ramp(((((blur_y.s0.y.yi.$n.rebased + t124) % 4) + 1)*t113) + -128, 1, 128)] = (input[ramp(t77 + -127, 1, 128)] + (input[ramp(t77 + -126, 1, 128)] + input[ramp(t77 + -128, 1, 128)]))/x128((uint16)3)
     }
    }
    if (2 <= blur_y.s0.y.yi.$n.rebased) {
     consume blur_x {
      let t128 = blur_y.s0.y.yi.$n.rebased + t124
      for (blur_y.s0.x.x, 0, t117) {
       let t80 = (blur_y.s0.x.x*256) - t112
       blur_y[ramp((blur_y.s0.x.x*256) + (((t128 + -2)*blur_y.stride.1) + t109), 1, 256)] = (blur_x[ramp(((((t128 + 3) % 4)*t113) + t80) + 256, 1, 256)] + (blur_x[ramp((((t128 % 4)*t113) + t80) + 256, 1, 256)] + blur_x[ramp(((((t128 + 2) % 4)*t113) + t80) + 256, 1, 256)]))/x256((uint16)3)
      }
      let t129 = blur_y.s0.y.yi.$n.rebased + t124
      for (blur_y.s0.x.x, 0, t110) {
       blur_y[ramp((((t129 + -2)*blur_y.stride.1) + t111) + -256, 1, 256)] = (blur_x[ramp(((((t129 + 3) % 4) + 1)*t113) + -256, 1, 256)] + (blur_x[ramp((((t129 % 4) + 1)*t113) + -256, 1, 256)] + blur_x[ramp(((((t129 + 2) % 4) + 1)*t113) + -256, 1, 256)]))/x256((uint16)3)
      }
     }
    }
   }
   free blur_x
  }
 }
}
}


